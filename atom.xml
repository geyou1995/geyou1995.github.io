<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我就是胖着玩玩的</title>
  
  <subtitle>坚持产生意外✊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-30T07:43:43.417Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Youga</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot配置多数据源</title>
    <link href="http://yoursite.com/2020/09/30/SpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <id>http://yoursite.com/2020/09/30/SpringBoot配置多数据源/</id>
    <published>2020-09-30T06:29:55.000Z</published>
    <updated>2020-09-30T07:43:43.417Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>随着业务数据量增多，单个数据库已经承受不了高并发多压力。一个项目使用多个数据库来分担数据压力变得越来越重要；也可以用来做读写分离操作。下面是记录一种方式，如何在SpringBoot项目中配置多个数据源。</p><h1 id="步骤描述"><a href="#步骤描述" class="headerlink" title="步骤描述"></a>步骤描述</h1><h3 id="在application-properties配置数据源"><a href="#在application-properties配置数据源" class="headerlink" title="在application.properties配置数据源"></a>在application.properties配置数据源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下所示这里我配置了两个数据源</span></span><br><span class="line"><span class="comment">// 一个是本地的root数据库（mysql）</span></span><br><span class="line"><span class="comment">// 另一个是远程的一个pro数据库（PostgreSql）</span></span><br><span class="line">root.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/test </span></span><br><span class="line">root.datasource.username=root </span><br><span class="line">root.datasource.password=<span class="number">123456</span> </span><br><span class="line">root.datasource.driverClassName=com.mysql.jdbc.Driver </span><br><span class="line">root.datasource.initialSize=<span class="number">3</span> </span><br><span class="line">root.datasource.minIdle=<span class="number">3</span> </span><br><span class="line">root.datasource.maxActive=<span class="number">55</span> </span><br><span class="line">root.datasource.maxWait=<span class="number">20000</span> </span><br><span class="line">root.datasource.timeBetweenEvictionRunsMillis=<span class="number">60000</span> </span><br><span class="line">root.datasource.minEvictableIdleTimeMillis=<span class="number">300000</span></span><br><span class="line">root.datasource.validationQuery=SELECT <span class="string">'x'</span> </span><br><span class="line">root.datasource.testWhileIdle=<span class="keyword">true</span> </span><br><span class="line">root.datasource.testOnBorrow=<span class="keyword">false</span> </span><br><span class="line">root.datasource.testOnReturn=<span class="keyword">false</span> </span><br><span class="line">root.datasource.filters=wall</span><br><span class="line"></span><br><span class="line">pro.datasource.url=jdbc:postgresql:<span class="comment">//192.168.95.143:5432/maycur-pro</span></span><br><span class="line">pro.datasource.username=team1</span><br><span class="line">pro.datasource.password=maycur</span><br><span class="line">pro.datasource.driverClassName=org.postgresql.Driver</span><br><span class="line">pro.datasource.initialSize=<span class="number">3</span></span><br><span class="line">pro.datasource.minIdle=<span class="number">3</span></span><br><span class="line">pro.datasource.maxActive=<span class="number">55</span></span><br><span class="line">pro.datasource.maxWait=<span class="number">20000</span></span><br><span class="line">pro.datasource.timeBetweenEvictionRunsMillis=<span class="number">60000</span></span><br><span class="line">pro.datasource.minEvictableIdleTimeMillis=<span class="number">300000</span></span><br><span class="line">pro.datasource.validationQuery=SELECT <span class="string">'x'</span></span><br><span class="line">pro.datasource.testWhileIdle=<span class="keyword">true</span></span><br><span class="line">pro.datasource.testOnBorrow=<span class="keyword">false</span></span><br><span class="line">pro.datasource.testOnReturn=<span class="keyword">false</span></span><br><span class="line">pro.datasource.filters=wall</span><br></pre></td></tr></table></figure><p><strong>配置参数介绍</strong><br><img src="https://github.com/geyou1995/picture/blob/master/dataSourcepz.jpeg?raw=true" alt=""></p><h3 id="准备数据源参数"><a href="#准备数据源参数" class="headerlink" title="准备数据源参数"></a>准备数据源参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> initialSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxActive;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWait;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis;</span><br><span class="line">    <span class="keyword">private</span> String validationQuery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn;</span><br><span class="line">    <span class="keyword">private</span> String filters;</span><br><span class="line">    <span class="keyword">private</span> String dbType;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里配置pro数据库配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"application.properties"</span>) <span class="comment">// 指定加载的配置文件</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = ProDataSourceProperties.PREFIX) <span class="comment">// 通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上,将配置文件对应的数据赋值给BaseDataSourceProperties里的成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDataSourceProperties</span> <span class="keyword">extends</span> <span class="title">BaseDataSourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"pro.datasource"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同理配置root数据库</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"application.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = RootDataSourceProperties.PREFIX)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootDataSourceProperties</span> <span class="keyword">extends</span> <span class="title">BaseDataSourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"root.datasource"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建数据源配置类"><a href="#创建数据源配置类" class="headerlink" title="创建数据源配置类"></a>创建数据源配置类</h3><p>这里我是将Mapper分包处理，不同的数据源去扫描不同的Mapper文件去操作数据库。结构如下<br><img src="https://github.com/geyou1995/picture/blob/master/dataSourcejg1.png?raw=true" alt=""></p><p><strong>开始配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置pro数据库的配置</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 申明为配置类</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.youga.springboot.dao.pro"</span>, sqlSessionTemplateRef = <span class="string">"proSessionTemplate"</span>) <span class="comment">// 扫描该路近下的mapper文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProConfigurtion</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProDataSourceProperties properties; <span class="comment">// 注入上步骤配置好的数据源配置文件类信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(properties.getDriverClassName());</span><br><span class="line">        dataSource.setUrl(properties.getUrl());</span><br><span class="line">        dataSource.setUsername(properties.getUsername());</span><br><span class="line">        dataSource.setPassword(properties.getPassword());</span><br><span class="line">        dataSource.setInitialSize(properties.getInitialSize());</span><br><span class="line">        dataSource.setMinIdle(properties.getMinIdle());</span><br><span class="line">        dataSource.setMaxActive(properties.getMaxActive());</span><br><span class="line">        dataSource.setMaxWait(properties.getMaxWait());</span><br><span class="line">       dataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis()); </span><br><span class="line">        dataSource.setValidationQuery(properties.getValidationQuery());</span><br><span class="line">        dataSource.setTestWhileIdle(properties.isTestWhileIdle());</span><br><span class="line">        dataSource.setTestOnBorrow(properties.isTestOnBorrow());</span><br><span class="line">        dataSource.setTestOnReturn(properties.isTestOnReturn());</span><br><span class="line">        dataSource.setDbType(properties.getDbType());</span><br><span class="line">        dataSource.setFilters(properties.getFilters());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// @Qualifier注解限定哪个bean应该被自动注入.</span></span><br><span class="line">  <span class="comment">// 当Spring无法判断出哪个bean应该被注入时有助于消除歧义bean的自动注入</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proDataSourceTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">(@Qualifier(<span class="string">"proDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SqlSessionFactory是MyBatis的关键对象</span></span><br><span class="line"><span class="comment">     * 它是个单个数据库映射关系经过编译后的内存镜像.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"proDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">      <span class="comment">// 配置数据源 </span></span><br><span class="line">        sessionFactory.setDataSource(dataSource);</span><br><span class="line">       <span class="comment">// 配置执行Mapper文件存放的位置</span></span><br><span class="line">        sessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:*/com/youga/springboot/dao/pro/mapper/*.xml"</span>));</span><br><span class="line">      <span class="comment">// 这里可以配置typeAliasesPackage -- 表示对应我们的实体类所在的包</span></span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SqlSessionTemplate是MyBatis-Spring的核心。</span></span><br><span class="line"><span class="comment">     * 这个类负责管理MyBatis的SqlSession,调用MyBatis的SQL方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sessionTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"proSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同理配置root数据库配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.youga.springboot.dao.root"</span>, sqlSessionTemplateRef = <span class="string">"rootSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RootDataSourceProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(properties.getDriverClassName());</span><br><span class="line">        dataSource.setUrl(properties.getUrl());</span><br><span class="line">        dataSource.setUsername(properties.getUsername());</span><br><span class="line">        dataSource.setPassword(properties.getPassword());</span><br><span class="line">        dataSource.setInitialSize(properties.getInitialSize());</span><br><span class="line">        dataSource.setMinIdle(properties.getMinIdle());</span><br><span class="line">        dataSource.setMaxActive(properties.getMaxActive());</span><br><span class="line">        dataSource.setMaxWait(properties.getMaxWait());</span><br><span class="line">       dataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis());</span><br><span class="line"> dataSource.setTimeBetweenEvictionRunsMillis(properties.getTimeBetweenEvictionRunsMillis());</span><br><span class="line">        dataSource.setValidationQuery(properties.getValidationQuery());</span><br><span class="line">        dataSource.setTestWhileIdle(properties.isTestWhileIdle());</span><br><span class="line">        dataSource.setTestOnBorrow(properties.isTestOnBorrow());</span><br><span class="line">        dataSource.setTestOnReturn(properties.isTestOnReturn());</span><br><span class="line">        dataSource.setDbType(properties.getDbType());</span><br><span class="line">        dataSource.setFilters(properties.getFilters());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootDataSourceTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">(@Qualifier(<span class="string">"rootDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"rootDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sessionFactory.setDataSource(dataSource);</span><br><span class="line">        sessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:*/com/youga/springboot/dao/root/mapper/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sessionTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"rootSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@GetMapping</span>(<span class="string">"/dateSourceTest"</span>)</span><br><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">dateSourceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> List&lt;ProcessLogDO&gt; processLogDOS = processLogMapper.select();</span><br><span class="line">    UserDO userDO = userMapper.select(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"proData:"</span> + JSON.toJSONString(processLogDOS.get(<span class="number">0</span>)) </span><br><span class="line">          +<span class="string">"rootData:"</span> + JSON.toJSONString(userDO);</span><br><span class="line">&#125;</span><br><span class="line">---------------结果---------------</span><br><span class="line">proData:&#123;<span class="string">"entCode"</span>:<span class="string">"EC16040611HZCQGW"</span>,<span class="string">"formDataCode"</span>:<span class="string">"BX1907081H2S2SCG"</span>&#125;</span><br><span class="line">rootData:&#123;<span class="string">"age"</span>:<span class="number">27</span>,<span class="string">"ext"</span>:<span class="string">"北冥神功"</span>,<span class="string">"id"</span>:<span class="number">2</span>,<span class="string">"name"</span>:<span class="string">"虚竹"</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybaits拦截器实现水平分表</title>
    <link href="http://yoursite.com/2020/09/26/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%E4%B9%8Bmybatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/09/26/水平分表之mybatis拦截器实现/</id>
    <published>2020-09-26T10:49:55.000Z</published>
    <updated>2020-09-26T12:28:17.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>最近项目中的几张表数据行超过了1000万行，所以需要对这些表进行水平分表，提高数据查询的性能。可选的方案有sharding-jdbc中间件还有就是Mybatis拦截器。由于个别表数据涉及了复杂的sql查询，可能会有意想不到的坑，所以决定采用Mybatis拦截器的方式。所以决定记录下来实现过程。</p><h1 id="分表思路"><a href="#分表思路" class="headerlink" title="分表思路"></a>分表思路</h1><p>这里我需要分表的表名为process_log,这里不是根据正常的id字段去分表（因为这张表连id字段都没有…）,而是选择这张表的唯一字段form_data_code来作为分表字段，将form_data_code字段值进行hashCode()然后进行取模。目前这张表的数据足足5000多万，考虑之后还会增加，需要将表数据控制在百万级内，所以你决定分表20张。先来了解一下Mybatis拦截器…</p><h1 id="Mybaits拦截器"><a href="#Mybaits拦截器" class="headerlink" title="Mybaits拦截器"></a>Mybaits拦截器</h1><h2 id="对四大接口进行拦截"><a href="#对四大接口进行拦截" class="headerlink" title="对四大接口进行拦截"></a>对四大接口进行拦截</h2><p><img src="https://github.com/geyou1995/picture/blob/master/mybatisIN.png?raw=true" alt=""></p><p><strong>Executor</strong>:是mybatis的内部执行器，它通过调用StatementHandler来操作数据库<br><strong>StatementHandler</strong>:是mybatis直接和数据库执行sql脚本的对象<br><strong>ResultSetHandler</strong>:是mybaits把ResultSet集合映射成POJO的接口对象<br><strong>ParameterHandler</strong>:是mybatis实现sql入参设置的对象</p><h2 id="Interceptor-接口"><a href="#Interceptor-接口" class="headerlink" title="Interceptor 接口"></a>Interceptor 接口</h2><p>mtbatis拦截器必须实现Interceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// 拦截器执行的逻辑方法</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;  </span><br><span class="line">  <span class="comment">// 用来封装目标对象。可以返回目标对象本身也可以根据实际需要，创建一个代理对象</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  <span class="comment">// 在Mybatis进行配置插件的时候可以配置自定义相关属性</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Intercepts注解参数数名</span></span><br><span class="line"><span class="comment">// Intercepts 拦截器: 标识我的类是一个拦截器</span></span><br><span class="line"><span class="comment">// Signature 署名: 则是指明我们的拦截器需要拦截哪一个接口的哪一个方法</span></span><br><span class="line"><span class="comment">//  type 对应四类接口中的某一个，比如是 StatementHandler</span></span><br><span class="line"><span class="comment">//  method 对应接口中的哪类方法，比如 StatementHandler 的 prepare 方法</span></span><br><span class="line"><span class="comment">//  args对应接口中的哪一个方法，方法参数</span></span><br><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(type = StatementHandler.class,method = <span class="string">"prepare"</span>,args = &#123;Connection.class,Integer.class&#125;))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardTableInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实战实现"><a href="#实战实现" class="headerlink" title="实战实现"></a>实战实现</h3><p><strong>1.实现自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SegmentTable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">tableName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class <span class="title">strategyClazz</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要分表的table的Mapper接口</span></span><br><span class="line"><span class="meta">@SegmentTable</span>(tableName = <span class="string">"process_log"</span>, strategyClazz = ProcessLogStrategy.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessLogMapper</span> </span>&#123;<span class="comment">// todo&#125;</span></span><br></pre></td></tr></table></figure><p>2.<strong>使用策略模式实现算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShardTableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分表算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> statementHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">shardAlgorithm</span><span class="params">(StatementHandler statementHandler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardTableContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ShardTableStrategy tableStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShardTableContext</span><span class="params">(ShardTableStrategy tableStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tableStrategy = tableStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doShardAlgorithm</span><span class="params">(StatementHandler statementHandler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tableStrategy.shardAlgorithm(statementHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process_log表算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLogStrategy</span> <span class="keyword">implements</span> <span class="title">ShardTableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ProcessLogStrategy.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分表20张</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer PROCESS_LOG_TABLE_NUM = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特殊处理字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PROCESS_LOG_TABLE_CONFIRM_INDEX = <span class="string">"subTableConfirmIndex"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分表字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PROCESS_LOG_TABLE_SUB_FIELD = <span class="string">"formDataCode"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PROCESS_LOG_BLANK_INDEX = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shardAlgorithm</span><span class="params">(StatementHandler statementHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (statementHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"statementHandler is null"</span>);</span><br><span class="line">            <span class="keyword">return</span> PROCESS_LOG_BLANK_INDEX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">        Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">        Map param2ValeMap = JSONObject.parseObject(JSON.toJSONString(parameterObject), Map.class);</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(param2ValeMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PROCESS_LOG_BLANK_INDEX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊处理foreach循环语句</span></span><br><span class="line">        Object confirmIndexValue = param2ValeMap.get(PROCESS_LOG_TABLE_CONFIRM_INDEX);</span><br><span class="line">        <span class="keyword">if</span> (confirmIndexValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> SHARD_TABLE_INDEX_LINE + confirmIndexValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object subFieldValue = param2ValeMap.get(PROCESS_LOG_TABLE_SUB_FIELD);</span><br><span class="line">        <span class="keyword">return</span> SHARD_TABLE_INDEX_LINE + Math.abs(subFieldValue.hashCode() % PROCESS_LOG_TABLE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.拦截器intercept()执行逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line">       <span class="comment">// 全局操作读对象</span></span><br><span class="line">       MetaObject metaObject = MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line">       <span class="comment">// @SegmentTable -- 只拦截有注解的Mapper</span></span><br><span class="line">       SegmentTable segmentTable = getSegmentTable(metaObject);</span><br><span class="line">       <span class="keyword">if</span> (segmentTable == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.对value进行算法 -&gt; 确定表名</span></span><br><span class="line">       Class strategyClazz = segmentTable.strategyClazz();</span><br><span class="line">       ShardTableStrategy strategy = (ShardTableStrategy) strategyClazz.newInstance();</span><br><span class="line">       String index = <span class="keyword">new</span> ShardTableContext(strategy).doShardAlgorithm(statementHandler);</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">"ShardTableInterceptor segmentTable=&#123;&#125;,index=&#123;&#125;"</span>, JSON.toJSONString(segmentTable), index);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.替换表名</span></span><br><span class="line">       <span class="comment">// 获取原始sql</span></span><br><span class="line">       String tableName = segmentTable.tableName();</span><br><span class="line">       String sql = (String) metaObject.getValue(BOUND_SQL_NAME);</span><br><span class="line">       metaObject.setValue(BOUND_SQL_NAME, sql.replaceFirst(tableName, tableName + index));</span><br><span class="line">       <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="总结遇到的问题"><a href="#总结遇到的问题" class="headerlink" title="总结遇到的问题"></a>总结遇到的问题</h1><p>1.这张表用了多表关联<br>现在终于明白，为什么要单表查询了，许多数据库性能的优化，都需要在单表的基础上才能更好的实施，所以现在的做法是，首先将多表关联的部分，采用单表查询在业务里处理掉.</p><p>2.分页插件pagehelper导致自定义插件无效<br>项目系统里也用了mybatis的分页插件pagehelper,pagehelper的intercept方法中没有invocation.proceed()，所以导致自定义的拦截器失效，没有传递下去。所以需要调整注册顺序。– 参考<br><a href="http://xtong.tech/2018/08/01/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%9B%A0pagehelper%E8%80%8C%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">http://xtong.tech/2018/08/01/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%9B%A0pagehelper%E8%80%8C%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</a></p><p>3.迁移老数据<br>分表首先要做的就是老数据的迁移，由于这里是根据Java的hashcode()计算关键字段，数据库的函数也要同一种hash算法，这里用的数据库是postgreSql,里面提供了一些hash算法但是和java的不同，因为要用阿里的DataWorks迁移，经过调研，Pg可以提供自定义算法，所以可以创建于JAVA hashCode()相同的自定义算法，这样就可以保证数据的迁移。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 自定义java hashCode算法</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span>  hash_code(<span class="built_in">text</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> hash_code(<span class="built_in">text</span>) <span class="keyword">RETURNS</span> <span class="built_in">integer</span></span><br><span class="line">    <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    i <span class="built_in">integer</span> := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span></span><br><span class="line">    h <span class="built_in">bigint</span>  := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.length($<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">LOOP</span></span><br><span class="line">            h = (h * <span class="number">31</span> + <span class="keyword">ascii</span>(<span class="keyword">substring</span>($<span class="number">1</span>, i, <span class="number">1</span>))) &amp; <span class="number">4294967295</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    RETURN cast(cast(h AS bit(32)) AS int4);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://yoursite.com/2020/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/19/设计模式-策略模式/</id>
    <published>2020-09-19T07:26:55.000Z</published>
    <updated>2020-09-19T06:53:38.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义一系列的算法，把他们一个个封装起来，并且使它们可相互替换。</p><h1 id="结构及说明"><a href="#结构及说明" class="headerlink" title="结构及说明"></a>结构及说明</h1><p><img src="https://github.com/geyou1995/picture/blob/master/strategy.png?raw=true" alt=""></p><p>Strategy:策略接口，用来约束一系列具体的策略算法。Context使用这个接口来调用具体的算法。<br>ConcreteStrategy:具体的策略实现，也就是具体的算法实现。<br>Context:上下文,负责和具体的策略类交互通常会持有一个正常的策略实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 算法方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下文接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的策略实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"算法A实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h1><p>假设某公司一款产品，针对不同的客户报价不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ProductStragety stragety;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductContext</span><span class="params">(ProductStragety stragety)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stragety = stragety;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stragety.sell(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalCustomer</span> <span class="keyword">implements</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通用户/新用户，原价出售"</span>);</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldCustomer</span> <span class="keyword">implements</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老用户，95折"</span>);</span><br><span class="line">        <span class="keyword">return</span> money*<span class="number">0.95</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeCustomer</span> <span class="keyword">implements</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大用户，9折"</span>);</span><br><span class="line">        <span class="keyword">return</span> money*<span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ProductContext context1 = <span class="keyword">new</span> ProductContext(<span class="keyword">new</span> NormalCustomer());</span><br><span class="line">   ProductContext context2 = <span class="keyword">new</span> ProductContext(<span class="keyword">new</span> OldCustomer());</span><br><span class="line">   ProductContext context3 = <span class="keyword">new</span> ProductContext(<span class="keyword">new</span> LargeCustomer());</span><br><span class="line">   System.out.println(context1.sell(<span class="number">1000</span>));</span><br><span class="line">   System.out.println(context2.sell(<span class="number">1000</span>));</span><br><span class="line">   System.out.println(context3.sell(<span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   -----------------------------------------</span><br><span class="line">   输出：</span><br><span class="line">   普通用户/新用户，原价出售</span><br><span class="line"><span class="number">1000.0</span></span><br><span class="line">老用户，<span class="number">95</span>折</span><br><span class="line"><span class="number">950.0</span></span><br><span class="line">大用户，<span class="number">9</span>折</span><br><span class="line"><span class="number">900.0</span></span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>JDK的Comparator就是使用了策略模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        list.sort(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = Lists.newArrayList();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>,<span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">24</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">25</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">18</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> PersonSortByName());--</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> ersonSortByAge());--</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 自定义比较策略</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">PersonSortByName</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 自定义比较策略</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ersonSortByAge</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">  输出</span><br><span class="line">  [Person&#123;name=<span class="string">'d'</span>, age=<span class="number">30</span>&#125;, Person&#123;name=<span class="string">'c'</span>, age=<span class="number">24</span>&#125;, Person&#123;name=<span class="string">'b'</span>, age=<span class="number">25</span>&#125;, Person&#123;name=<span class="string">'a'</span>, age=<span class="number">18</span>&#125;]</span><br><span class="line">  </span><br><span class="line">[Person&#123;name=<span class="string">'a'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'b'</span>, age=<span class="number">25</span>&#125;, Person&#123;name=<span class="string">'c'</span>, age=<span class="number">24</span>&#125;, Person&#123;name=<span class="string">'d'</span>, age=<span class="number">30</span>&#125;]</span><br><span class="line">  </span><br><span class="line">[Person&#123;name=<span class="string">'a'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'c'</span>, age=<span class="number">24</span>&#125;, Person&#123;name=<span class="string">'b'</span>, age=<span class="number">25</span>&#125;, Person&#123;name=<span class="string">'d'</span>, age=<span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="http://yoursite.com/2020/09/19/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/09/19/分库分表/</id>
    <published>2020-09-19T02:01:55.000Z</published>
    <updated>2020-09-19T03:48:47.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么需要分库分表？"><a href="#为什么需要分库分表？" class="headerlink" title="为什么需要分库分表？"></a>为什么需要分库分表？</h1><p>数据库数据会随着业务的发展而不断增多，单表单库性能就存在很大的问题了，如增删改查的开销也会越来越大。<br>当一张单表的容量低于1千万以下是可接受的，这时B+Tree索引树高在3～5之间。</p><h1 id="数据库瓶颈"><a href="#数据库瓶颈" class="headerlink" title="数据库瓶颈"></a><strong>数据库瓶颈</strong></h1><h3 id="IO瓶颈"><a href="#IO瓶颈" class="headerlink" title="IO瓶颈"></a>IO瓶颈</h3><p>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询都会产生大量的IO，降低查询速度。（分库和垂直分表）<br>第二种：网络IO瓶颈，请求的数据太多，网络宽带不够。（分库）</p><h3 id="CPU瓶颈"><a href="#CPU瓶颈" class="headerlink" title="CPU瓶颈"></a>CPU瓶颈</h3><p>第一种：SQL问题，如SQL中包含join、group by、非索引字段条件等,增加CPU运算等操作(SQL优化,优化索引)<br>第二种：单表数据量太大，查询时扫描等行太多，SQL效率太多，CPU率先出现瓶颈（水平分表）</p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a><strong>垂直分库</strong></h4><p><strong>说明</strong><br>根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务进行独立划分。项目一开始是一个单体应用，所有表数据都放在一个数据库里。之后随着业务增大，根据业务拆分成多个数据库。</p><p><strong>特点</strong><br>每个库的结构都不一样.<br>每个库的数据都不一样，没有交集。<br>所有库数据的交集就是全量数据。</p><p><strong>示例图</strong></p><p><img src="https://github.com/geyou1995/picture/blob/master/czfk.png?raw=true" alt=""></p><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p><strong>说明</strong><br>把一张表的多个字段分别拆分成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。也可以叫主表和葱表,从而提升数据库性能.</p><p><strong>特点</strong><br>每个表的结构不一样。<br>每个表的数据也不一样。一般每个表至少有一列交集，一般是主键，用于关联数据。<br>所有表的数据就是全量数据。</p><p><strong>示例图</strong><br><img src="https://github.com/geyou1995/picture/blob/master/czfb.png?raw=true" alt=""></p><p>如上将商品的详情数据(冷数据)和基本信息(热数据)拆分成两张表。</p><h4 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h4><p><strong>说明</strong><br>以字段为依据，根据一定策略（hash、rangde等），将一个库中的数据拆分到多个库中。</p><p><strong>特点</strong><br>每个库的结构都一样。<br>每个库的数据都不一样。<br>所有库的数据时候全量数据。</p><p><strong>示例图</strong></p><p><img src="https://github.com/geyou1995/picture/blob/master/spfk.png?raw=true" alt=""></p><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p><strong>说明</strong><br>以<strong>字段</strong>为依据，按照一定策略（hash、range等），将一个<strong>表</strong>中的数据拆分到多个<strong>表</strong>中。一般单表数据超过1千万就要考虑水平分表了。</p><p><strong>特点</strong><br>每个表的结构都一样。<br>每个表的数据都不一样。<br>所有表的并集是全量数据。</p><p><strong>示例图</strong></p><p><img src="https://github.com/geyou1995/picture/blob/master/spfb.png?raw=true" alt=""></p><h1 id="数据分片规则"><a href="#数据分片规则" class="headerlink" title="数据分片规则"></a>数据分片规则</h1><h4 id="Hash取模分表"><a href="#Hash取模分表" class="headerlink" title="Hash取模分表"></a>Hash取模分表</h4><p>一般采用Hash取模的切分方式，例如：假设按goods_id分4张表。（goods_id%4 取整确定表）<br><img src="https://github.com/geyou1995/picture/blob/master/hash.png?raw=true" alt=""></p><h4 id="数值Range分表"><a href="#数值Range分表" class="headerlink" title="数值Range分表"></a>数值Range分表</h4><p>按照时间区间或ID区间来切分。例如：将goods_id为11000的记录分到第一个表，10012000的分到第二个表，以此类推。<br><img src="https://github.com/geyou1995/picture/blob/master/range.png?raw=true" alt=""></p><h1 id="工具及方案"><a href="#工具及方案" class="headerlink" title="工具及方案"></a>工具及方案</h1><p>1.sharding-sphere：jar，前身是sharding-jdbc.<br>2.TDDL：jar，Taobao Distribute Data Layer.<br>3.Mycat：中间件.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里总结的只是一些基础概念的东西，还需要结合实际操作增加认识与扩展。之后小编刚好会有一个实战项目，水平分表的实战，之后会结合总结的。</p><p>详细参考文章：<br><a href="https://juejin.im/post/6844903863464493064" target="_blank" rel="noopener">https://juejin.im/post/6844903863464493064</a><br><a href="https://www.cnblogs.com/qdhxhz/p/11608222.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/11608222.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之工厂方法模式</title>
    <link href="http://yoursite.com/2020/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/04/设计模式-工厂方法模式/</id>
    <published>2020-09-04T07:26:55.000Z</published>
    <updated>2020-09-04T08:25:30.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>在工厂方法模式之前，先了解简单工厂.<br>首先简单工厂不是一个标准的设计模式！简单工厂不是一个标准的设计模式！简单工厂不是一个标准的设计模式！<br>简单的本质就是选择实现。工厂就是用来创建对象的，根据传入的参数，返回对应的实例对象。<br>优点：帮助封装、解耦。<br>缺点：不符合开闭原则，有新对象就要修改工厂类的代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面分别是小米手机类、华为手机类和苹果手机类</span></span><br><span class="line"><span class="comment">// 1.正常创建使用</span></span><br><span class="line"><span class="comment">// 我们创建它们的时候需要一个一个对象去new</span></span><br><span class="line">MiPhone mi = <span class="keyword">new</span> MiPhone();</span><br><span class="line">IPhone i = <span class="keyword">new</span> IPhone();</span><br><span class="line">HwPhone i = <span class="keyword">new</span> HWPhone();</span><br><span class="line"><span class="comment">// todo...</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.使用简单工厂</span></span><br><span class="line"><span class="comment">// 都实现同一个接口或继承同一个对象Phone</span></span><br><span class="line">HWPhone implements Phone </span><br><span class="line">IPhone implements Phone </span><br><span class="line">MiPhone implements Phone</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 手机工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">makePhone</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Mi"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"I"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"HW"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HWPhone();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有该类型产品 type="</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line">Phone mi = PhoneFactory.makePhone(<span class="string">"Mi"</span>);</span><br><span class="line">Phone i = PhoneFactory.makePhone(<span class="string">"I"</span>);</span><br><span class="line">Phone hw = PhoneFactory.makePhone(<span class="string">"HW"</span>);</span><br><span class="line"><span class="comment">// todo...</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>简单工厂就是把对象全部向一个工厂里创建,根据类型参数返回不同的实力对象.<br>优点：封装、实现客户端和具体实现类的解耦.<br>缺点：不符合开闭原则，每次需要添加新的产品对象使都要修改工厂类.</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个用于创建对象的接口,让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到其子类。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://github.com/geyou1995/picture/blob/master/gcff.png?raw=true" alt=""></p><p>Creator:抽象工厂角色，是工厂方法模式的核心，与应用程序无关。<br>ConcreteCreator：具体的工厂，Product方法的具体实现。<br>Product：抽象产品角色，声明工厂方法，通常会返回一个Product类型的实例对象<br>ConcreteProduct：具体的产品对象，实现抽象产品的所有方法。</p><h3 id="具体示例代码"><a href="#具体示例代码" class="headerlink" title="具体示例代码"></a>具体示例代码</h3><p>1.定义一个抽象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">mackPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.产品各自的工厂实现这个抽象工厂,重写工厂方法，可以看到各自的工厂生产各自的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 苹果手机工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">mackPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小米手机工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Phone <span class="title">mackPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 华为手机工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">mackPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HWPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.客户端使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MIFactory miFactory = <span class="keyword">new</span> MIFactory();</span><br><span class="line">       miFactory.mackPhone();</span><br><span class="line">       IFactory iFactory = <span class="keyword">new</span> IFactory();</span><br><span class="line">       iFactory.mackPhone();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 新增一个类型产品，只需添加新工厂，不要修改原有工厂</span></span><br><span class="line">       HWFactory hwFactory = <span class="keyword">new</span> HWFactory();</span><br><span class="line">       hwFactory.mackPhone();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>相比较于简单工厂，工厂方法模式就是将工厂抽象化，将具体的产品分布在不同的具体工厂中操作,<br>而且复合开闭原则，新的产品只要再写一个新的工厂就行，不用修改原来的工厂类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-构建者模式</title>
    <link href="http://yoursite.com/2020/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/08/29/设计模式-构建者模式/</id>
    <published>2020-08-29T11:37:55.000Z</published>
    <updated>2020-08-29T12:59:31.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h1 id="结构与说明"><a href="#结构与说明" class="headerlink" title="结构与说明"></a>结构与说明</h1><p><img src="https://github.com/geyou1995/picture/blob/master/gzq.jpg?raw=true" alt=""></p><p><strong>Builder</strong>: 构建者接口，定义创建一个Product对象所需的各个部件的操作。<br><strong>ConcreteBuilder</strong>:具体的构建器实现，实现各个部件的创建，并负责组装Product对象的各个部件，同时还提供一个让用户获取组装完成后的产品对象的方法。<br><strong>Director</strong>:指导者，主要用来使用Builder接口，以一个统一的过程来构建所需要的Product对象。<br><strong>Product</strong>: 产品，表示被构建器构建的复杂对象。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>现在有这样一个Hero类需要构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">  <span class="comment">// 代号(必须)</span></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line">  <span class="comment">// 姓名(必须)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">// 年龄(必须)</span></span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="comment">// 主技能(必须)</span></span><br><span class="line">  <span class="keyword">private</span> String skillMain;</span><br><span class="line">  <span class="comment">// 技能1（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill1;</span><br><span class="line">  <span class="comment">// 技能2（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill2;</span><br><span class="line">  <span class="comment">// 技能3（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill3;</span><br><span class="line">  <span class="comment">// 技能4（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill4;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一种：折叠构造函数模式</strong><br>通过传参构造需要的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String code, String name, Integer age, String skillMain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String code, String name, Integer age, String skillMain, String skill1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">        <span class="keyword">this</span>.skill1 = skill1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String code, String name, Integer age, String skillMain, String skill1, String skill2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">        <span class="keyword">this</span>.skill1 = skill1;</span><br><span class="line">        <span class="keyword">this</span>.skill2 = skill2;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>第二种：JavaBean模式</strong><br>创建一个对象,对其中的成员属性依次set(),get()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> code;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.code = code;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>从上述两种方法可以看出，当一个类对象非常复杂时，以上方法都有缺点<br>第一种方式：代码阅读以及使用不方便,每次使用需要知道调用哪种构造方法，当参数很多时还需要注意参数顺序，易出错。<br>第二种方式：在构建的过程中对象的状态容易发生变化，造成错误。<br>针对以上问题，所以才有了Builder模式。<br><strong>当一个类对象非常复杂，构造的参数很多，并且这些参数是可选的，可以考虑使用构建者。</strong></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>1.在Hero类中创建一个静态内部类Builder，参数和Hero类一样。(必要的参数用final修饰)<br>2.将Hero的构造方法私有，且入参为Builder类，防止外部创建。只能由外部调用Builder类创建，<br>所以也要在Builder里提供一个方法，返回Hero对象。<br>3.Hero类的参数提供get()方法，Builder类的参数提供set()方法，返回值都为Builder对象，形成链式编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名(必须)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主技能(必须)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String skillMain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 技能1（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String skill1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 技能2（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String skill2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化Hero构造方法，外部只能通过Builder获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hero</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = builder.skillMain;</span><br><span class="line">        <span class="keyword">this</span>.skill1 = builder.skill1;</span><br><span class="line">        <span class="keyword">this</span>.skill2 = builder.skill2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供获取成员变量的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSkillMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skillMain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSkill1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skill1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSkill2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skill2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hero&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", skillMain='"</span> + skillMain + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", skill1='"</span> + skill1 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", skill2='"</span> + skill2 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 姓名(必须)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="comment">// 主技能(必须)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String skillMain;</span><br><span class="line">        <span class="comment">// 技能1（可选）</span></span><br><span class="line">        <span class="keyword">private</span> String skill1;</span><br><span class="line">        <span class="comment">// 技能2（可选）</span></span><br><span class="line">        <span class="keyword">private</span> String skill2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * final修饰的参数为必传</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String name, String skillMain)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置成员参数，返回builder对象，链式编程</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> skill1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSkill1</span><span class="params">(String skill1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.skill1 = skill1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSkill2</span><span class="params">(String skill2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.skill2 = skill2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供一个返回Hero的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Hero <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Hero(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero.Builder builder = <span class="keyword">new</span> Hero.Builder(<span class="string">"萧峰"</span>, <span class="string">"降龙十八掌"</span>);</span><br><span class="line">        Hero hero = builder.setSkill1(<span class="string">"打狗棒法"</span>).setSkill2(<span class="string">"少林武学"</span>).builder();</span><br><span class="line">        System.out.println(hero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">Hero&#123;name=<span class="string">'萧峰'</span>, skillMain=<span class="string">'降龙十八掌'</span>, skill1=<span class="string">'打狗棒法'</span>, skill2=<span class="string">'少林武学'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看出，本文只是用了传统构建者模式的变种。这也是平时项目开发中遇到常用的方式了，继续练习～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>类加载器和双亲委派机制</title>
    <link href="http://yoursite.com/2020/08/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/22/类加载器与双亲委派机制/</id>
    <published>2020-08-22T07:52:55.000Z</published>
    <updated>2020-08-23T02:43:17.972Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p><strong>加载</strong><br>在硬盘上查找通过I/O读取字节码文件,生成类的二进制数据（.class文件）</p><p><strong>验证</strong><br>校验生成的字节码文件的正确性</p><p><strong>准备</strong><br>给类的静态变量分配内存,并赋予默认值</p><p><strong>解析</strong><br>符号引用转化为直接引用</p><p><strong>初始化</strong><br>对类的静态变量初始化为指定的值,执行静态代码块</p><p><img src="https://github.com/geyou1995/picture/blob/master/jvm.png?raw=true" alt=""></p><p>注：类被加载到方法区中主要包含 <strong>运行时常量、类型信息、字段信息、方法信息、类加载器的引用（这个类到类加载器实例等引用）、对应classs实例的引用（类加载器在加载类信息放到方法区后，会创建一个对应的class类型的对象放到堆中）</strong>等信息.<br>还有主类运行过程中，如果使用到其他类，会逐步加载这些类。jar包和war包里的类都是懒加载。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><strong>引导类加载器(BootStrapClassLoader)</strong><br>负责加载支撑JVM运行的位于JRE的lib目录下的核心类库,比如rt.jar、charsets.jar等</p><p><strong>扩展类加载器(ExtClassLoader)</strong><br>负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的jar类包</p><p><strong>应用程序加载器(AppClassLoader)</strong><br>负载加载ClassPath路径下的类包,主要加载你自己写的那些类</p><p><strong>自定义类加载器</strong><br>负责加载用户自定义路径下的类包</p><p>如下代码分别输出BootStrapClassLoader、ExtClassLoader、AppClassLoader.<br>由于引导类加载器是C语言写的所以返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.class.getClassLoader());     System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</span><br><span class="line">System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure><p>类加载器之间关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"> ClassLoader extClassloader = appClassLoader.getParent();</span><br><span class="line"> ClassLoader bootstrapLoader = extClassloader.getParent();</span><br><span class="line">System.out.println(<span class="string">"the bootstrapLoader : "</span> + bootstrapLoader);</span><br><span class="line">System.out.println(<span class="string">"the extClassloader : "</span> + extClassloader);</span><br><span class="line">System.out.println(<span class="string">"the appClassLoader : "</span> + appClassLoader);</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line">the bootstrapLoader : <span class="keyword">null</span></span><br><span class="line">the extClassloader : sun.misc.Launcher$ExtClassLoader@<span class="number">776</span>ec8df</span><br><span class="line">the appClassLoader : sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure><p>如上代码可以看出JVM类加载器是有亲子层级结构的<br><strong>BootStrapClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader -&gt; 自定义类加载器</strong></p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p><img src="https://github.com/geyou1995/picture/blob/master/ljzq.png?raw=true" alt=""></p><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父类去完成，一次向上。只有当父类无法完成该加载时，子加载器才会尝试自己去加载该类。<br>这就是类加载的<strong>双亲委派机制</strong>：<strong>先找父亲加载，不行再由儿子自己加载</strong></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设现在要加载Math类，最先会找AppClassLoader加载，AppClassLoader会委托ExtClassLoader加载，ExtClassLoader则又会委托BootStrapClassLoader加载，BootStrapClassLoader是顶层引导类加载器，则会在自己的类加载路径里找Math类，没有则退回BootStrapClassLoader，BootStrapClassLoader则会在自己的类加载路径里找Math类，也没有则最后退回到AppClassLoader类加载，最终在AppClassLoader的加载路径里找到Math类，最后就自己加载了。</p><h3 id="为什么要设计双亲委派机制？"><a href="#为什么要设计双亲委派机制？" class="headerlink" title="为什么要设计双亲委派机制？"></a>为什么要设计双亲委派机制？</h3><p><strong>沙箱安全机制</strong><br>这样可以防止核心类被篡改,比如rt.jar里有一个常用的java.lang.String.class类，这样你自己写的相同路径的java.lang.String.class类就不会被加载。</p><p><strong>避免类的重复加载</strong><br>当父亲已经加载过的类路径，子类就没有必要再去加载一次,保证被加载类的唯一性。</p><h3 id="全盘委托机制"><a href="#全盘委托机制" class="headerlink" title="全盘委托机制"></a>全盘委托机制</h3><p>如果一个类加载，这个类依赖的其他类，也会一起加载。</p><h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>自定义类加载器需要继承 java.lang.ClassLoader 类,这个类有两个核心方法，<br>loadClass(String, boolean)，实现了<strong>双亲委派机制</strong>。<br>findClass，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写</strong>findClass<strong>方法</strong>。<br>自定义类加载器默认父加载器是AppClassLoader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">           <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">           <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">               SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">               <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">               Class var5 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">               <span class="keyword">if</span> (var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.resolveClass(var5);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> var5;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(var1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           result = AccessController.doPrivileged(</span><br><span class="line">               <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                       String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</span><br><span class="line">                       Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                       <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                               <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, acc);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">           <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Syncronized关键字</title>
    <link href="http://yoursite.com/2020/08/15/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/15/Synchronized关键字/</id>
    <published>2020-08-15T09:03:55.000Z</published>
    <updated>2020-08-15T08:15:13.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Syncronized是JVM自带的关键字，主要用来解决线程并的原子性问题。Syncronized保证多个线程并发，在同一时刻只能有一个线程访问临界资源。<br>在多线程可能出现同时访问一个共享、可变资源的情况，这个资源叫临界资源（对象、变量、文件等）。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p><strong>静态方法</strong>：类锁,锁得是当前类的class对象<br><strong>普通方法</strong>：对象锁,锁得是当前实例对象<br><strong>同步代码块</strong>：锁得是括号里的对象</p><p><strong>注：一个类只有一个class,可能有多个实例对象</strong>. 若一个类有多个静态方法，可能会造成性能影响。</p><h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a><strong>历史</strong></h4><p>Synchronized在JDK1.6之前性能非常的低，使用的时候需要用户态与内核态的切换。<br>所以Doug li 写了AQS框架，实现了ReentranLock(java语言写的)，性能远远高于JVM自带的Syncronized。<br>之后甲骨文收购了java,觉得Syncronized干不过ReentranLock，为了颜面，在JDK1.6之后对Syncronized进行了优化，即锁的升级，目前Syncronized和ReentranLock的性能五五开。</p><h4 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a><strong>升级过程</strong></h4><p>锁得状态一共四种：无锁状态、偏向锁、轻量级锁、重量级锁。<br><strong>无锁状态</strong><br>当没有线程访问被syncronized修饰得方法或代码块时，就是无锁状态.</p><p><strong>偏向锁</strong><br>当第一个线程访问syncronized修饰的方法或代码块时,锁就进入了偏向模式,此时JAVA对象头里的Mark Word的结构也变为偏向锁结构.当其他线程请求锁的时候，会CAS替换JAVA对象头里的Mark Word里偏向锁的信息，替换成功就获取到锁资源。记录在Mark Word的里的线程再次请求锁资源，不需要做任何同步操作，省去大量锁申请操作，也就提升了性能。</p><p><strong>轻量级锁</strong><br>对于锁竞争激烈的场景，偏向锁就失效了。但是JVM并不会立刻升级为重量级锁,会先将Mark Word的结构变为轻量级锁的结构。轻量级锁适应的场景是线程交替执行代码块的场合，如果存在同一时间访问同一锁的场景，就会升级为重量级锁。</p><p><strong>重量级锁</strong><br>在轻量级锁失败后，jvm会先进行自选锁的操作。会先让当前想获取锁的线程做空循环,经过一定次数的循环，如果还得不到锁，就只能升级为重量级锁。</p><p><strong>注：锁得升级是不可逆的～</strong></p><h1 id="加锁信息"><a href="#加锁信息" class="headerlink" title="加锁信息"></a>加锁信息</h1><p>锁信息展示（32位虚拟机）</p><p><img src="https://github.com/geyou1995/picture/blob/master/syncronized.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发编程" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2020/08/15/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/15/Volatile关键字/</id>
    <published>2020-08-15T07:03:55.000Z</published>
    <updated>2020-08-15T08:46:41.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>volatile是Java虚拟机提供的轻量级的同步机制。<br>volatile能保证并发编程的两个问题：可见性和有序性。</p><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p><img src="https://github.com/geyou1995/picture/blob/master/jmm.png?raw=true" alt=""></p><p><strong>问题：</strong><br>从JMM模型可以知道，线程都是从总内存中加载变量到自己的工作内存，所以在多线程情况下，线程A获取了主内存的共享变量X，线程B也获取了变量X，并且将它修改。这时线程A无法立刻知道自己工作内存里的变量X与主线内存的变量X已经不同。</p><p><strong>解决：</strong><br>使用volatile修饰共享变量.</p><p><strong>缓存一致性原则MESI</strong><br>M 已修改状态 （加锁成功）<br>E  独占状态 （一个cpu读到）<br>S  共享状态（多个cpu读到）<br>I  失效状态 （收到其他cpu的消息）<br>当其他线程把主内存的值修改后，工作内存的缓存就被消除掉了。底层就是volatile 调用一个lock指令，修改值经过总线的时候会触发缓存一致性协议，将其他工作内存对应的缓存值变为失效状态，其他线程需要读取值需要重新去主内存读取。</p><h1 id="防指令重排"><a href="#防指令重排" class="headerlink" title="防指令重排"></a>防指令重排</h1><p><code></code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public  LazySingleton getInstance3() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;</span><br><span class="line">                    instance = new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>问题:</strong><br>上图是单例模式double check，LazySingleton的实例化需要经过<br><strong>分配空间 -&gt; 初始化 -&gt; 引用赋值</strong>,但是JVM底层可能会对其指令重排为<br><strong>分配空间 -&gt; 引用赋值 -&gt; 初始化</strong>，这样返回的instance可能只是赋值而未初始化，可能有npe问题。</p><p><strong>解决：</strong><br>使用volatile修饰该实例对象.</p><p><strong>内存屏障</strong><br>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。 总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发编程" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JMM模型</title>
    <link href="http://yoursite.com/2020/08/08/JMM%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/08/JMM模型/</id>
    <published>2020-08-08T10:42:55.000Z</published>
    <updated>2020-08-08T12:07:35.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是JMM模型？"><a href="#什么是JMM模型？" class="headerlink" title="什么是JMM模型？"></a>什么是JMM模型？</h1><p>JMM模型就是Java内存模型，是一种抽象的概念,并不真实存在。它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（实例字段、静态字段、构成数组对象的元素）的访问方式。<br>JVM运行程序的实体是线程，每当创建线程时JVM都会为其创建一个工作内存,每个线程都有自己独有的工作内存存储私有数据，但是JMM规定所有的变量都存储在主内存，主内存是共享区域，所有线程都可以访问，但是对变量的操作需要在各自的工作内存中操作，操作完后写回主内存,不能直接操作主内存中的变量。<br><img src="https://github.com/geyou1995/picture/blob/master/jmm.png?raw=true" alt=""></p><h1 id="数据同步八大原子操作"><a href="#数据同步八大原子操作" class="headerlink" title="数据同步八大原子操作"></a>数据同步八大原子操作</h1><p>关于主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现,JMM定义了以下8种操作完成。<br><strong>lock(锁定)</strong><br>作用与主内存的变量，把一个变量标记为一条线程独占状态。<br><strong>unlock(解锁)</strong><br>作用与主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。<br><strong>read(读取)</strong><br>将主内存的数据拷贝一份，便于随后的load使用<br><strong>load(载入)</strong><br>将read拷贝的数据加载到工作内存中<br><strong>use(使用)</strong><br>将工作内存中的数据变量给执行引擎进行逻辑修改<br><strong>assign(赋值)</strong><br>将执行引擎修改的值写回线程的工作内存<br><strong>store(存储)</strong><br>将工作内存的值拷贝一份出来<br><strong>write(写入)</strong><br>将store出来的值写回主内存</p><p>举例：假设线程A要修改主内存中的变量a = 0 -&gt; a=1<br>首先<strong>read</strong>将主内存的变量a=0拷贝一份，通过<strong>load</strong>加载到线程A的工作内存,然后<strong>use</strong>将工作内存中a=0交给执行引擎，执行引擎将a=0修改为a=1，<strong>assign</strong>将a=1写回工作内存，<strong>store</strong>将工作内存中的a=1拷贝一份出来，<strong>write</strong>将a=1写回主内存。</p><h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><p><strong>原子性</strong><br>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>通常使用 synchronized、Lock （ volatile不保证原子性）</p><p><strong>可见性</strong><br>当一个线程修改了某个共享变量 的值，其他线程是否能够马上得知这个修改的值。<br>volatile可以解决可见性（保证能否及时看到）。</p><p><strong>有序性</strong></p><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。<br>volatile可以防止指令重排。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发编程" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>MVCC机制</title>
    <link href="http://yoursite.com/2020/08/01/MVCC%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/01/MVCC机制/</id>
    <published>2020-08-01T13:53:55.000Z</published>
    <updated>2020-08-01T13:54:55.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MVCC概述"><a href="#MVCC概述" class="headerlink" title="MVCC概述"></a>MVCC概述</h1><p>Mysql在可重复读隔离级别下，同样的sql查询语句在一个事务里多次执行查询结果是相同的，就算其他事物对数据有修改也不会影响当前事物sql语句的查询结果。<br>这个隔离性就是靠MVCC（多版本并发控制）机制保证的，对一行数据的读和写两个操作默认不会通过加锁互斥来保证隔离性，避免了 频繁加锁。</p><h1 id="MVCC机制的实现"><a href="#MVCC机制的实现" class="headerlink" title="MVCC机制的实现"></a>MVCC机制的实现</h1><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo日志版本链是指一行数据被多个事务依次修改后，在每个事务修改完后，mysql会保留修改之前的数据在undo日志，并且用两个隐藏字段<strong>trx_id(事务id)和rollpoint（指针</strong>）把这些日志记录连接起来，形成一个历史记录版本链。如下图</p><p><img src="https://github.com/geyou1995/picture/blob/master/undo-1.jpg?raw=true" alt=""></p><p><strong>红色代表id=1的这行历史修改记录，蓝色代表最新数据。</strong><br>undo日志只有一份。</p><h3 id="Read-view-一致性视图"><a href="#Read-view-一致性视图" class="headerlink" title="Read-view 一致性视图"></a>Read-view 一致性视图</h3><p>每个事务开启都会维护一份自己的一致性视图。<br><strong>视图组成</strong><br>执行查询时所有未提交事务的id数组 + 已创建的最大事务id组成</p><p><strong>视图生成时机</strong><br>可重复读隔离级别，在第一次查询就会生成Read view。<br>读已提交隔离级别， 每次读都会生成一份最新的Read view</p><p><strong>版本对比举例</strong><br>事务里的任何sql查询结果需要从对应的版本链的最新数据开始逐条做对比得到最终的结果。<br>拿上图数据举例：假设事务A的视图为[200] 300，去查询id=1的数据<br>                                首先找到蓝色最新的数据,事务id是200,200在事务A的一致性视图中是属于未提交的，所以数据                                不可见，再找下一条事务id也是200,还是不可见，逐一比对，到事务id=100时，100不在事务A<br>                                的一致性视图里，说明是已提交的事务，所以最终得到的值就是’lilei2’。</p><h3 id="版本链对比规则"><a href="#版本链对比规则" class="headerlink" title="版本链对比规则"></a>版本链对比规则</h3><p><img src="https://github.com/geyou1995/picture/blob/master/undo-2.jpg?raw=true" alt=""></p><p>如果undo日志里的数据行trx_id(事务id)落在绿色部分，说明这个版本是已提交的事务生成的，所以数据可见。<br>如果undo日志里的数据行trx_id(事务id)落在红色部分，说明这个版本是由将来启动的事务生成，肯定不可见。<br>如果undo日志里的数据行trx_id(事务id)落在黄色部分，就需要判断了<br>    a.trx_id在视图数组里，说明这个版本是由还没提交的事务生成的，数据不可见。<br>    b.trx_id不在视图数组里,说明这个版本是已经提交的事务生成的,数据可见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MVCC机制的实现就是通过<strong>read-view机制</strong>与<strong>undo版本链对比机制</strong>，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上不同版本的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql事务隔离级别与锁机制</title>
    <link href="http://yoursite.com/2020/08/01/Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/01/Mysql事务隔离级别与锁机制/</id>
    <published>2020-08-01T01:52:55.000Z</published>
    <updated>2020-08-01T04:26:07.902Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么要事务隔离与锁机制？"><a href="#为什么要事务隔离与锁机制？" class="headerlink" title="为什么要事务隔离与锁机制？"></a>为什么要事务隔离与锁机制？</h1><p>数据库一般都会并发执行多个事务，多个事务间可能会并发对相同的一批数据进行增删改查操作，就可能会造成一些事务隔离性问题，例如：脏写、脏读、不可重复读、幻读。</p><h1 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h1><p>事务是由一组SQL语句组成的逻辑处理单元,具有以下4个属性,简称事务的ACID属性。<br><strong><em>原子性</em></strong><br>执行事务操作，一系列对数据修改的操作，这些操作要么全部执行成功，要么全部失败。<br><strong><em>一致性</em></strong><br>事务开始到结束，数据必须保持一致性。<br>举例：银行转账操作，两个账户转钱。账户的总金额不会改变。<br><strong><em>隔离性</em></strong><br>多个事务之间相互隔离，互相不打扰。（这里可能有许多隔离性问题）<br><strong><em>永久性</em></strong><br>事务结束后，数据的修改会永久的保存在数据库里。</p><h1 id="事务隔离性问题"><a href="#事务隔离性问题" class="headerlink" title="事务隔离性问题"></a>事务隔离性问题</h1><p><strong><em>脏写</em></strong><br>假设同时开启事务A,B,选择数据表中同一行数据进行修改，A事务先完成了对数据的修改并提交了事务，之后B事务对同一数据也修改提交。最终数据库里的数据是事务B修改的数据。覆盖了A之前修改的数据。就造成了脏写。</p><p><strong><em>脏读</em></strong><br>两个事务A,B，事务B读到了事务A已经修改但是还没有提交的数据。<br>事务A对数据行进行了修改，但是还没有提交事务。这时事务B读到了A事务还没有提交的事务，还用这个数据去操作。如果A事务回滚了，那这个数据就是无效的。不符合一致性要求。</p><p><strong><em>不可重复读</em></strong><br>线程AB开启事务，A,B同时读到一行数据，A更新了这条数据，并提交了事务，B还未提交事务，重新去读这行数据，导致B一次事务里两次读到的数据不相同。</p><p><strong><em>幻读</em></strong><br>幻读类似不可重复读;不可重复读针对查询操作;幻读针对读是插入和删除操作。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>针对以上问题，Mysql数据库提供了一定的事务隔离级别机制来解决。</p><p><img src="https://github.com/geyou1995/picture/blob/master/shiwugeli.jpg?raw=true" alt=""></p><p>Mysql数据库默认的隔离级别是<strong>可重复读</strong>。</p><p><strong>查看当前数据库的事务隔离级别</strong>: show variables like ‘tx_isolation’;</p><p><strong>设置事务隔离级别</strong>：set tx_isolation=’REPEATABLE-READ’;</p><h1 id="MySql锁机制"><a href="#MySql锁机制" class="headerlink" title="MySql锁机制"></a>MySql锁机制</h1><h3 id="锁详解"><a href="#锁详解" class="headerlink" title="锁详解"></a>锁详解</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除了传统的计算资源（CPU、RAM、I/O等）竞争外，数据也是一种共享等资源。</p><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从性能上分</span><br><span class="line">乐观锁</span><br><span class="line">用版本号对比来实现，每次修改数据的时候会先比较读到数据的版本号和最新的版本号是否一致，一致就可以修改，否则不行。乐观锁实际上是不加锁的。</span><br><span class="line"></span><br><span class="line">悲观锁</span><br><span class="line">对数据进行加锁，访问资源需要竞争锁。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从对数据库操作的类型分</span><br><span class="line">分为读锁写锁，都是悲观锁。**读锁会阻塞写，写锁会阻塞读和写。</span><br><span class="line"></span><br><span class="line">读锁</span><br><span class="line">读锁也称共享锁，S锁（share），针对同一份数据，多个读操作可以进行而不会相互影响。</span><br><span class="line"></span><br><span class="line">写锁</span><br><span class="line">写锁也称排他锁，X锁（eXclusive），针对同一份数据，写操作没有完成，其他事物的读/写都会堵塞。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从对数据操作的粒度分</span><br><span class="line">MyISAM是表锁。InnoDB查询的时候有mvcc机制不会加锁，但是更新、插入、删除操作会加行锁。</span><br><span class="line"></span><br><span class="line">表锁</span><br><span class="line">每次操作都会锁住整张表。找到表就可以加锁，开销小，加锁快。锁的粒度大，不会出现死锁。发生锁冲突的概率最高，**一般用在整表数据的迁移**。</span><br><span class="line"></span><br><span class="line">行锁</span><br><span class="line">每次操作锁住操作涉及到的数据行。需要找到对应的数据行才能加锁，开销大，加锁慢。锁的粒度小，会出现死锁。</span><br></pre></td></tr></table></figure><h1 id="锁和事务隔离级别"><a href="#锁和事务隔离级别" class="headerlink" title="锁和事务隔离级别"></a>锁和事务隔离级别</h1><h3 id="隔离级别设置"><a href="#隔离级别设置" class="headerlink" title="隔离级别设置"></a>隔离级别设置</h3><p>​    <strong>读未提交</strong>  set tx_isolation=’read-uncommitted’;<br>​    <strong>读已提交</strong>  set tx_isolation=’read-committed’;<br>​    <strong>可重复读</strong>  set tx_isolation=’repeatable-read’;<br>​    <strong>串行化</strong>     set tx_isolation=’serializable’;</p><h3 id="锁和事务隔离级别-1"><a href="#锁和事务隔离级别-1" class="headerlink" title="锁和事务隔离级别"></a>锁和事务隔离级别</h3><p><strong><em>可重复读</em></strong><br>就是假设某一事务对数据行就行了<strong>更新操作</strong>就会对涉及到的数据行加行锁。<br><strong><em>序列化</em></strong><br>只要开启了事务，之后的操作，不管<strong>查询操作</strong>还是<strong>更新操作</strong>，对涉及到的数据行全部加行锁，所以性能差。<br><strong><em>间隙锁</em></strong><br>因为mysql的默认隔离级别是可重复读，会有幻读的问题。可以引入间隙锁在某些情况下可以解决该问题。</p><p><img src="https://github.com/geyou1995/picture/blob/master/jxs.jpg?raw=true" alt=""></p><p>如上表所示间隙就有id为 （3，10）、(10,20)、(20,正无穷)<br>防止幻读就是需要被涉及的数据行加锁<br>update account set name = ‘萧峰666’ where id &gt; 8 and id &lt;18;<br>上述sql会对id值有在（3，10）区间的，也有在（10，20）区间的，所以最终被锁定的区间是（3，20],其他事务没法在这区间插入或修改任何数据。<br><strong>间隙锁只在可重复读隔离级别下才生效。</strong></p><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><ul><li>尽可能让所有数据检索都通过索引完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，减小锁的范围。</li><li>尽可能减小检索条件范围，避免间隙锁。</li><li>尽量控制事务大小，减小锁定资源量和时间长度，涉及事务加锁的sql放在事务最后执行。</li><li>尽可能低级别事务隔离</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://yoursite.com/2020/07/20/SQL%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/07/20/SQL优化/</id>
    <published>2020-07-20T11:52:55.000Z</published>
    <updated>2020-07-20T11:52:09.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开发过程中,经常会碰到一些慢sql，性能低，执行时间太长、等待时间太长、sql语句欠佳、索引失效、服务器参数设置不合理需要我们对sql进行适当的优化，所以需要了解如何去优化哈.下面整理了一些mysql的sql结构以及该如何去优化sql。</p><h1 id="mysql的逻辑分层原理"><a href="#mysql的逻辑分层原理" class="headerlink" title="mysql的逻辑分层原理"></a>mysql的逻辑分层原理</h1><ul><li><p>连接层 </p><p>提供与客户端连接的服务</p></li><li><p>服务层 </p><p>提供各种用户使用的接口（增删改查）,提供sql优化器</p></li><li><p>引擎层</p><p>提供各种存储数据的方式，例如默认的InnoDB（事务优先，行锁）、MyISAM(效率优先，表锁)等</p></li><li><p>存储层</p><p>存储最终的数据</p><blockquote><p>sql 编写过程<br>select…from…join…on…where…group by…having…order by…limit..<br>sql 解析过程<br>from…on..join…where…group by…having..select…order by…limit..</p></blockquote></li></ul><h1 id="核心是优化索引"><a href="#核心是优化索引" class="headerlink" title="核心是优化索引"></a>核心是优化索引</h1><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>帮助mysql高效获取数据的数据结构，索引是数据结构.</p><h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><p>​     主键索引：与唯一基本相同（主键不能为null，唯一可以为null）<br>​     单值索引：单列（一个表可以有多个单值索引）<br>     唯一索引：不能重复（例如id）<br>     复合索引：多个列构成的索引s </p><h5 id="索引优势"><a href="#索引优势" class="headerlink" title="索引优势"></a>索引优势</h5><p>提高查询效率（降低IO的使用率)<br>降低CPU使用率（索引是排好序的结构，可以直接用）</p><h5 id="索引弊端"><a href="#索引弊端" class="headerlink" title="索引弊端"></a>索引弊端</h5><p>索引本身很大，可以存放在内存/硬盘<br>不是所有情况使用：a.少量数据 b.频繁更新的字段 c.很少使用的字段<br>索引会提高查的效率，会降低增删改的效率</p><h3 id="SQL性能问题"><a href="#SQL性能问题" class="headerlink" title="SQL性能问题"></a>SQL性能问题</h3><h5 id="分析SQL的执行计划：EXPLAIN-SQL"><a href="#分析SQL的执行计划：EXPLAIN-SQL" class="headerlink" title="分析SQL的执行计划：EXPLAIN+SQL"></a>分析SQL的执行计划：EXPLAIN+SQL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id: 编号</span><br><span class="line">id值相同，从上往下顺序执行(表的执行顺序会因为数量改变而改变，原因：笛卡尔积，数据小的表优先查询)，id值不同：越大越优先查询（在查询时先查内层再查外层）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select_type: 查询类型</span><br><span class="line">PRIMARY:主查询</span><br><span class="line">SUBQUERY:子查询</span><br><span class="line">SIMPLE:简单查询（不包含主、子查询）</span><br><span class="line">DERIVER：衍生查询（使用到临时表,From后面的查询）</span><br><span class="line">UNION：在from子查询中table1 union table2（指的table2）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table: 查询的表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type: 索引类型 system-&gt;const-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all（越往左效率越高）</span><br><span class="line">Null:MySql底层会对查询进行优化,直接查询常量</span><br><span class="line">system:查询得表里只有一条数据行</span><br><span class="line">const:结果集只有一条数据 （通过主键索引和唯一索引查询）</span><br><span class="line">eq_ref:表关联用主键或唯一键</span><br><span class="line">ref:表查询没有用到主键或唯一，但是用到了普通索引，可能返回匹配的多条数据或0条。（从索引的根节点开始找）</span><br><span class="line">range:检索指定范围的行，使用一个索引来选择行（between,&lt;,&gt;,=）</span><br><span class="line">index:扫描所有的索引（叶子结点全索引扫描），一般去扫二级索引，因为主键索引太大</span><br><span class="line">all:全表读取</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">possible_keys: 预测可能使用的索引</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key: 实际使用的索引</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">key_len:实际使用的索引的长度（作用：判断复合索引是否完全被使用）</span><br><span class="line">字符串</span><br><span class="line">char(n):3n字节长度</span><br><span class="line">varchar(n):若是utf-8，长度为3n+2 (加的2是存储字符串长度的)</span><br><span class="line">数值类型</span><br><span class="line">thinyint:1字节</span><br><span class="line">smallint:2字节</span><br><span class="line">int:4字节</span><br><span class="line">bigint:8字节</span><br><span class="line">时间类型：</span><br><span class="line">date:3字节</span><br><span class="line">timestamp:4字节</span><br><span class="line">datetime:8字节</span><br><span class="line">*如果字段允许为null，还需要加1个字节，记录是否为NULL。</span><br><span class="line">*例如：联合索引 name age address</span><br><span class="line">name varchar(20) 不为null</span><br><span class="line">age int  可为null</span><br><span class="line">address char(30) 可为null</span><br><span class="line">则key_len = （20*3+2） + （4+1）+（30*3+1） = 158</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: 联合索引关联的字段（可能是个常量值const）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const:常量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows:可能检测到的行数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Extra:展示额外信息 </span><br><span class="line">性能从好到坏:using index &gt; using where &gt; using temporary | using filesort</span><br><span class="line"></span><br><span class="line">using index: 索引覆盖，不读取原文件，只从索引文件中获取（不需要回表查询）</span><br><span class="line">（覆盖索引：使用联合索引查找没有回表查）</span><br><span class="line"></span><br><span class="line">using where: 需要回表查询(需要查询原文件)</span><br><span class="line"></span><br><span class="line">using filesort（性能损耗大）常见于order by，没有索引需要放在临时表里比较</span><br><span class="line"></span><br><span class="line">using temporary（性能损耗大，额外多使用临时表）常见于distinct 去重，没有索引需要放在临时表里比较</span><br></pre></td></tr></table></figure><h5 id="SQL优化器可能干扰我们的优化"><a href="#SQL优化器可能干扰我们的优化" class="headerlink" title="SQL优化器可能干扰我们的优化"></a>SQL优化器可能干扰我们的优化</h5><p>SQL的优化主要通过上述的属性去优化，但是SQL优化器可能会干扰我们的优化.</p><h3 id="常用SQL优化方法"><a href="#常用SQL优化方法" class="headerlink" title="常用SQL优化方法"></a>常用SQL优化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.加索引</span><br><span class="line">a.索引不能跨列，保持索引的定义和使用一致（根据sql实际解析的顺序，调整索引的顺序，从from开始节气解析）；</span><br><span class="line">b.索引要逐步优化</span><br><span class="line">c.范围查询in可能使索引失效，放到where条件最后面</span><br><span class="line"></span><br><span class="line">2. 多表</span><br><span class="line">   a.小表驱动大表</span><br><span class="line">   b.索引建立在经常查询的字段</span><br><span class="line">   </span><br><span class="line">3. 避免索引失效的一些原则</span><br><span class="line">   a.复合索引，不要跨列或无序使用（最佳左前缀）</span><br><span class="line">   b.复合索引，尽量使用全索引匹配</span><br><span class="line">   c.不要在索引上进行任何操作（计算，函数，类型转换），否则索引失效    </span><br><span class="line">   d.复合索引不能使用不等于（!=，&lt;&gt;）或is null，否则索引失效</span><br><span class="line">   e.尽量使用索引覆盖（using index）</span><br><span class="line">   f.like尽量已“常量”开头，不用以“%”开头，否则索引失效（如果必须使用，可以用索引覆盖补救一部分）</span><br><span class="line">   g.尽量不要使用类型转换（显式，隐式），否则索引失效</span><br><span class="line">   h.尽量不要使用or，否则索引失效</span><br><span class="line">   注：双层循环：（外层小内层大）性能比（外层大内层小）好</span><br></pre></td></tr></table></figure><h3 id="MySql锁机制"><a href="#MySql锁机制" class="headerlink" title="MySql锁机制"></a>MySql锁机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解决因资源共享而造成的并发问题</span><br><span class="line">- 操作类型分：</span><br><span class="line">1.读锁（共享锁）:对同一个数据，多个读操作可以同时进行（买衣服的看）</span><br><span class="line">2.写锁（互斥锁）:如果当前操作没有完毕，则无法进行读写操作（买衣服一系列操作）</span><br><span class="line">- 操作范围分：</span><br><span class="line">1.表锁：一次性对一张表整体加锁（myISAM存储引擎），开销小，加锁快，锁的范围大，无死锁，容易发生锁冲突</span><br><span class="line">2.行锁：一次性对一行数据加锁（innoDB存储引擎），开销大，加锁慢，容易出现死锁，不易发生锁冲突</span><br><span class="line">3.页锁</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql索引数据结构</title>
    <link href="http://yoursite.com/2020/07/18/Mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/07/18/Mysql索引数据结构/</id>
    <published>2020-07-18T06:33:55.000Z</published>
    <updated>2020-07-18T06:54:02.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h1><p>索引是帮助Mysql高效获取排好序的数据结构。</p><h1 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h1><p>数据库的数据都是存放在本地磁盘里的，每次查询数据都会进行磁盘IO读取数据，将读到的数据加载到内存中比较，Mysql InnoDB默认一次磁盘IO的大小是16K.</p><p>调用以下命令查询</p><p><code>SHOW GLOBAL STATUS like &#39;Innodb_page_size&#39;;</code></p><h1 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h1><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>首先看下图</p><p><img src="https://github.com/geyou1995/picture/blob/master/1.png?raw=true" alt=""></p><p>假设需要根据字段col2查询col2=22的数据，select * from table where col2 = 22。</p><h5 id="无索引"><a href="#无索引" class="headerlink" title="无索引"></a>无索引</h5><p>全表查，从上至下</p><p>34 -&gt;77 -&gt;55 -&gt;91 -&gt;<font color="#DC143C">22</font></p><p>每一次的查询都会进行一次磁盘IO，可以看出上述操作一共进行了5次磁盘IO才找到了col2=22的数据行。</p><h5 id="使用二叉树索引"><a href="#使用二叉树索引" class="headerlink" title="使用二叉树索引"></a>使用二叉树索引</h5><p>看上图右边的树，就是为上述col2字段建立的一个二叉树索引，我们都知道二叉树索引是大的元素放右边，小的元素放左边。</p><p>根据索引的查询22，首先会查询到34，判断22&lt;34就会去树的左边结点，再次查询就找到22了，所以上述查询采用索引只用了2次磁盘IO</p><h5 id="注：二叉树存储的-key是索引值，value是该索引值对应的数据行地址。"><a href="#注：二叉树存储的-key是索引值，value是该索引值对应的数据行地址。" class="headerlink" title="注：二叉树存储的 key是索引值，value是该索引值对应的数据行地址。"></a>注：二叉树存储的 key是索引值，value是该索引值对应的数据行地址。</h5><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>根据二叉树结点存放的特点，如果给Col1字段建立二叉树索引，就是如下图所示，形成一个单项的链表结构，这样的查询和全表查询没有什么区别。</p><p><img src="https://github.com/geyou1995/picture/blob/master/9.jpg?raw=true" alt=""></p><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p>为了避免上述二叉树的缺点，进而引入了一种新的数据结构那就是平衡二叉树。</p><p>它有一个非常严格的要求：必须保证左右子树高度差不超过1.</p><p><img src="https://github.com/geyou1995/picture/blob/master/10.jpg?raw=true" alt=""></p><p>它虽然避免了二叉树变成链表结构的尴尬，但是如果数据量非常非常大的情况下，树的层级就会非常的高，这样就会进行多次的磁盘IO,效率就会非常低下，所以AVL也不是Mysql InnoDB的索引结构。</p><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><p>BTree做了改进就是它每个结点不止一个元素,每个元素不重复，并且每个结点中的元素从左到右依次递增排序。每个结点都有索引和数据。</p><p><img src="https://github.com/geyou1995/picture/blob/master/2.png?raw=true" alt=""></p><p>还是回到原来的问题，当数据量很大的时候，树的层级还是会很深，又会进行多次磁盘IO，效率就低下了。而且查询不稳定，可能第一次IO就查到数据了，也可能在最后一层叶子结点查询到数据。所以它也不是Mysql InnoDB的索引结构。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://github.com/geyou1995/picture/blob/master/3.png?raw=true" alt=""></p><p>比较BTree 和B+Tree的结构图可以看出，B+Tree相较于BTree：</p><h5 id="数据全都存放在叶子结点。"><a href="#数据全都存放在叶子结点。" class="headerlink" title="数据全都存放在叶子结点。"></a>数据全都存放在叶子结点。</h5><p>这样可以保证每次磁盘IO读到的索引元素更多，降低树的高度，增加命中率。</p><p>还可以可以保证查询效率的稳定。</p><h5 id="叶子结点之间有结点指针"><a href="#叶子结点之间有结点指针" class="headerlink" title="叶子结点之间有结点指针"></a>叶子结点之间有结点指针</h5><p>因为索引都是排好序的，这样可以适用于范围查询，提高效率。</p><h5 id="假设下可以存储的索引数量"><a href="#假设下可以存储的索引数量" class="headerlink" title="假设下可以存储的索引数量"></a>假设下可以存储的索引数量</h5><p>一次IO是16K,假设索引是一个bigint(8B),上图空白格表示下一个磁盘地址（6B）</p><p>根节点第一次IO大概：16*1024/(8+6) = 1170</p><p>第二次IO:1170</p><p>叶子结点中有数据行：假设一行数据1KB，一次IO 16K所以可以放16</p><p>这棵树放满大约能放的索引是：1170 <em> 1170</em>  16 = 21902400（2千多万）</p><h5 id="综上：3层的B-Tree结构可以存放2千多万的索引数据-所以Mysql的InnoDB底层索引结构就是B-Tree-一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO"><a href="#综上：3层的B-Tree结构可以存放2千多万的索引数据-所以Mysql的InnoDB底层索引结构就是B-Tree-一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO" class="headerlink" title="综上：3层的B+Tree结构可以存放2千多万的索引数据;所以Mysql的InnoDB底层索引结构就是B+Tree. 一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO."></a>综上：3层的B+Tree结构可以存放2千多万的索引数据;所以Mysql的InnoDB底层索引结构就是B+Tree. 一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO.</h5><h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><p><img src="https://github.com/geyou1995/picture/blob/master/4.png?raw=true" alt=""></p><p>Hash结构底层是数组和链表</p><h5 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h5><p>将索引的值进行hash运算，算出该元素所在的桶的位置，然后判断该位置是否有元素，没有就直接塞进去，有的话说明hash冲突，用链表连接。</p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>查询数据的时候也先将值进行hash运算，找到具体的位置查找。类似于HashMap的底层原理吧。</p><h5 id="综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。"><a href="#综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。" class="headerlink" title="综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。"></a>综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。</h5><h1 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h1><p><img src="https://github.com/geyou1995/picture/blob/master/5.png?raw=true" alt=""></p><p>上述是一行一行的数据…</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p><img src="https://github.com/geyou1995/picture/blob/master/6.png?raw=true" alt=""></p><p>聚集索引：叶子结点包含数据的，索引和数据放在一起的。</p><p>聚集索引的确定（依次选择）：B+tree默认首先获取主键 -&gt; 不为null的唯一键列 -&gt; 默认生成一个id行</p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p><img src="https://github.com/geyou1995/picture/blob/master/7.png?raw=true" alt=""></p><p>非聚集索引：叶子结点不包含数据的，放的是主键的id。</p><p>这样做是为了节约存储空间；也保证一致性，数据行修改了不用两棵树都去修改。</p><h1 id="InnoDB-表建立主键，主键通常都用整型且自增的原因"><a href="#InnoDB-表建立主键，主键通常都用整型且自增的原因" class="headerlink" title="InnoDB 表建立主键，主键通常都用整型且自增的原因"></a>InnoDB 表建立主键，主键通常都用整型且自增的原因</h1><p>用整型的原因：索引用整型比较大小快。</p><p>自增的原因：因为叶子结点都是排好序的，如果不自增，可能会导致树结构的自平衡，影响效率。</p><h1 id="联合索引-复合索引为什么是最左前缀原理？"><a href="#联合索引-复合索引为什么是最左前缀原理？" class="headerlink" title="联合索引/复合索引为什么是最左前缀原理？"></a>联合索引/复合索引为什么是最左前缀原理？</h1><p>首先看下联合索引的索引结构图</p><p><img src="https://github.com/geyou1995/picture/blob/master/8.png?raw=true" alt=""></p><p>可以看到联合索引的顺序是：name、age、position</p><p>因为索引都是排好序的，按上面的结构，必须先找到name,</p><p>假设是Bill，在Bill的基础上，age是排好序的</p><p>不然人工直接找age，它就是没有顺序的</p><h5 id="综上：联合索引是一级一级查询的，所以按最左前缀原理。"><a href="#综上：联合索引是一级一级查询的，所以按最左前缀原理。" class="headerlink" title="综上：联合索引是一级一级查询的，所以按最左前缀原理。"></a>综上：联合索引是一级一级查询的，所以按最左前缀原理。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Idea 查看源码</title>
    <link href="http://yoursite.com/2020/07/15/Idea%E5%A6%82%E4%BD%95%E7%9C%8B%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2020/07/15/Idea如何看源码/</id>
    <published>2020-07-15T07:34:45.000Z</published>
    <updated>2020-07-15T07:45:59.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>平时开发代码，避开不了需要查看源码，例如JDK、spring的源码那都是精华，非常值我们去推敲学习的，但是在Idea直接点开下载源码是不能在上面做笔记的，所以希望看源码的时候可以把自己理解的内容写注释，方便下次观看立即能回忆起来。而且能够Debug调试。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>就拿JDK的源码为例。<br>1.找到JDK的zip包然后解压<br>2.打开Idea的SKDs,在sourcepath配置解压好的jdk包<br><img src="https://github.com/geyou1995/picture/blob/master/1594798922200.jpg?raw=true" alt=""><br>3.最后就能在源码写注释了(以HashMap源码为例)<br><img src="https://github.com/geyou1995/picture/blob/master/1594799091404.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://yoursite.com/2020/07/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/15/设计模式-单例模式/</id>
    <published>2020-07-15T07:30:55.000Z</published>
    <updated>2020-08-02T08:54:59.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单例模式：保证一个类仅有一个实例，并提供一个全局访问它的全局访问点。<br>应用场景:  线程池、数据库连接等。</p><h2 id="单例实现"><a href="#单例实现" class="headerlink" title="单例实现"></a>单例实现</h2><p>实例单例模式主要分为两种：懒汉式和饿汉式。<br>1.构造方法私有化。<br>2.提供一个全局访问点.</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 自行创建实例</span><br><span class="line">    private static HungrySingleton instance = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过该函数向整个系统提供获取方法</span><br><span class="line">    public HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用static修饰了成员变量instance,这样类初始化的过程中被收集进类构造器即“clinit”方法中，在多线程下JVM会保证只有一个线程会执行clinit方法，其他会阻塞等待。等到唯一的一次clinit方法执行完成，其他线程将不会再执行该方法，转而执行自己的代码。也就是说static修饰的成员变量instatnce只会被初始化一次。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以保证多线程情况下实例的唯一性，getInstatce方法直接返回实例，性能非常高。<br>缺点：在类成员变量比较多活比较大的情况下，可能在没有使用类的时候一直占用着堆内存，造成内存的浪费。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉模式就是为了避免直接加载类对象造成堆内存浪费的一种单例模式。</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1.原始方法</span><br><span class="line">    // 这样虽然避免了类加载提前创建实例，但是在多线程运行下，就会出现多个实例创建的情况。</span><br><span class="line">    public LazySingleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象 -- 多个线程会创建多个对象</span><br><span class="line">            instance = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    // 2.饿汉式 + synchronized</span><br><span class="line">    // 这样虽然可以避免多线程问题，但是同步锁会增加锁竞争，每次获取实例对象都会通过getInstance方法，带来系统性能开销，导致系统性能下降。</span><br><span class="line">    public synchronized LazySingleton getInstance1() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象</span><br><span class="line">            instance = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 3.饿汉式 + synchronized 减小锁的粒度</span><br><span class="line">    // 在创建实例对象的时候加同步锁，但是依然存在可能创建多个实例，因为在进入null判断的时候可能有多个线程</span><br><span class="line">    public  LazySingleton getInstance2() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁  -- 这里可能多个线程等待，最终也会导致多个对象创建</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                instance = new LazySingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private volatile LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    // 4.饿汉式 + synchronized double check</span><br><span class="line">    // 当线程拿到锁准备创建对象时，再判断一次实例是否已经创建。这种方法被称为Double-Check,它可以大大提高懒汉模式性能。</span><br><span class="line">    // 但是也不能保证万无一失。以防万一变量添加volatile 防止指令重排序。</span><br><span class="line">    // 创建一个对象底层字节码的执行顺序是1.分配空间 2.初始化 3. 引用赋值 </span><br><span class="line">     -&gt; 指令重排后可能变为1.分配空间 2.引用赋值  3.初始化 </span><br><span class="line">     当第一个线程引用赋值后，第二个线程进来发现instance不为null,就直接返回使用，但是这时instance可能还 没有初始化，所以可能会npe;</span><br><span class="line">    public  LazySingleton getInstance3() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;</span><br><span class="line">                    instance = new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过内部类实现</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 4.通过内部类实现</span><br><span class="line">    // 通过饿汉式可以知道通关键字static修饰变量，在类初始化加载的时候只有一个线程可以执行clinit方法，其他会阻塞等待。</span><br><span class="line">    // 所以可以利用这个特性在Singleton类中创建一个内部类来实现。内部类的静态成员变量是懒加载，并且内部类可以调外部类的私有构造方法。</span><br><span class="line">    public static class InnerSingleton &#123;</span><br><span class="line">        private static LazySingleton instance = new LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public LazySingleton getInstance4() &#123;</span><br><span class="line">        return InnerSingleton.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.枚举类(核心就是内部类)</span><br></pre></td></tr></table></figure><h3 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private volatile LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.通过内部类实现</span><br><span class="line">    // 通过饿汉式可以知道通关键字static修饰变量，在类初始化加载的时候只有一个线程可以执行clinit方法，其他会阻塞等待。</span><br><span class="line">    // 所以可以利用这个特性在Singleton类中创建一个内部类来实现。内部类的静态成员变量是懒加载，并且内部类可以调外部类的私有构造方法。</span><br><span class="line">    public static class InnerSingleton &#123;</span><br><span class="line">        private static LazySingleton instance = new LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public LazySingleton getInstance4() &#123;</span><br><span class="line">        return InnerSingleton.instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h3><p>枚举类(核心就是内部类)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实单例模式的本质就是控制对象实例的个数。懒汉式和饿汉式各有各的优缺点，可以适当根据应用场景使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Idea永久破解</title>
    <link href="http://yoursite.com/2020/07/15/Idea%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/15/Idea永久破解/</id>
    <published>2020-07-15T07:00:45.000Z</published>
    <updated>2020-07-15T07:32:16.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>最近刚好换了工作，要换台电脑工作了，安装了Idea,忘记了原来Idea破解的方法，于是网上查找，果然好记性不如烂笔头，决定总结一下，记录下来。就是把idea激活，不需要使用有期限的激活码.</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.首先下载jetbrains-agent.jar<br>2.在Idea里创建idea.vmoptions<br><img src="https://github.com/geyou1995/picture/blob/master/idea%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB.jpg?raw=true" alt=""><br>3.在idea.vmoptions 填写jetbrains-agent.jar的文件路径<br><img src="https://github.com/geyou1995/picture/blob/master/1594798247034.jpg?raw=true" alt=""><br>4.填写 <a href="http://fls.jetbrains-agent.com" target="_blank" rel="noopener">http://fls.jetbrains-agent.com</a> 最后激活<br><img src="https://github.com/geyou1995/picture/blob/master/1594797538198.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>springBoot入门</title>
    <link href="http://yoursite.com/2019/05/27/springBoot%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/05/27/springBoot入门/</id>
    <published>2019-05-27T12:46:55.000Z</published>
    <updated>2020-07-15T06:31:45.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>为基于spring开发提供更快的入门体检.</li><li>开箱即用.</li><li>springBoot不是对spring的增强，而是提供了更快的使用方式</li><li>嵌入式服务器，健康检测，安全、外部配置等非功能性特性.</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>起步依赖<br>将具备某一功能的坐标打包到一起，提供默认的功能</li><li>自动配置<br>自动帮你配置某个对象需要的配置,例如tomcat的端口号默认8080等</li></ol><h2 id="必须引用的坐标"><a href="#必须引用的坐标" class="headerlink" title="必须引用的坐标"></a>必须引用的坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">父级依赖</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支持web的模块</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>springBoot是基于约定的所有很多配置都有默认值，若想使用自己的配置，可以使用配置文件（properties,yml).</p><h4 id="1-properties"><a href="#1-properties" class="headerlink" title="1. properties"></a>1. properties</h4><p>key = value </p><h4 id="2-yml（yaml）"><a href="#2-yml（yaml）" class="headerlink" title="2. yml（yaml）"></a>2. yml（yaml）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.普通数据的配置（冒号后需要空格）</span><br><span class="line">name: zhangsan </span><br><span class="line">2. 对象的配置(同一级别的缩进保持一致)</span><br><span class="line">person:</span><br><span class="line">name: zhangsan</span><br><span class="line">age: 18</span><br><span class="line">address: hangzhou</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">port: 8088</span><br><span class="line">3. 行内对象配置(不常用)</span><br><span class="line">person： &#123;name: zhangsan,age: 18, address: hangzhou&#125;</span><br><span class="line"></span><br><span class="line">4.配置数据集合</span><br><span class="line">city:</span><br><span class="line">- beijing</span><br><span class="line">- hangzhou</span><br><span class="line">- taizhou</span><br><span class="line">- zhoushan</span><br><span class="line">city：[beijing,hangzhou,taizhou]</span><br><span class="line"></span><br><span class="line">5. 配置对象集合数据</span><br><span class="line">student:</span><br><span class="line">-name: zhangsan</span><br><span class="line">age: 18</span><br><span class="line">address: hangzhou</span><br><span class="line">-name: lisi</span><br><span class="line">age: 16</span><br><span class="line">address: taizhou</span><br><span class="line">6. map配置</span><br><span class="line">map:</span><br><span class="line">key1: value1</span><br><span class="line">key2: value2</span><br></pre></td></tr></table></figure></code></pre><h2 id="加载配置文件的顺序"><a href="#加载配置文件的顺序" class="headerlink" title="加载配置文件的顺序"></a>加载配置文件的顺序</h2><p>springBoot一些数据会有默认值，如果你想更改则可以使用配置来覆盖，配置文件后加载的也会覆盖之前加载的.它会先加载yml，最后加载properties.<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（spring-boot-starter-parent）</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">&lt;excludes&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.yml&lt;/exclude&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.yaml&lt;/exclude&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.properties&lt;/exclude&gt;</span><br><span class="line">&lt;/excludes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure></p><h2 id="在业务代码中获取配置信息"><a href="#在业务代码中获取配置信息" class="headerlink" title="在业务代码中获取配置信息"></a>在业务代码中获取配置信息</h2><p>有如下两种方式：</p><ol><li><p>@value(“${name}”)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;oss.endPoint&#125;&quot;)</span><br><span class="line">private String endPoint;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oss:</span><br><span class="line">endPoint: oss-cn-hangzhou-internal.aliyuncs.com</span><br><span class="line">accessKeyId: ALIYUN_ACCESS_KEY</span><br><span class="line">accessKeySecret: ALIYUN_SECRET_KEY</span><br><span class="line">defaultBucket: salary-prod</span><br></pre></td></tr></table></figure></code></pre></li><li><p>@ConfigurationProperties(prefix =”person”)<br> 需要set,get方法</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">private String clusterNodes;</span><br><span class="line"></span><br><span class="line">private String redisHost;</span><br><span class="line"></span><br><span class="line">private int redisPort;</span><br><span class="line"></span><br><span class="line">private String redisPasswd;</span><br><span class="line"></span><br><span class="line">set()..</span><br><span class="line">get()..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">clusterNodes:</span><br><span class="line">redisHost: r-bp1d75e29eop202ee4.redis.rds.aliyuncs.com</span><br><span class="line">redisPort: 6377</span><br><span class="line">redisPasswd: REDIS_PASSWORD</span><br><span class="line">timeout: 3000</span><br><span class="line">database: 0</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>excel读写及Zip打包下载</title>
    <link href="http://yoursite.com/2019/01/02/excel%E8%AF%BB%E5%86%99%E5%8F%8AZIp%E6%89%93%E5%8C%85%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/01/02/excel读写及ZIp打包下载/</id>
    <published>2019-01-02T09:41:55.000Z</published>
    <updated>2020-07-15T06:38:34.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>针对2019个税专项附加扣除做的需求：帮助Hr快速收集员工申报信息，及处理信息，由员工填写表单提交信息，对信息进行处理写入到个税局提供的个税专项附加扣除信息excel模版，最后ZIP打包导出.</p><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>首先需要收集处理员工数据，将excel模版放在服务器上，导出时在服务器上创建一个临时文件夹，读取模版excel文件,将数据循环写入excel模版中(一个员工对应一张excel),将写好数据的excel文件流依次写入该文件夹中，接着打包下载该文件夹，最后删除这个临时文件夹.</p><ul><li>将excel模版放在服务器上<br>将个税局提供的模版放到服务器上，用于读取</li><li>收集处理导出的数据<br>数据是map形式，userId-data,一个员工对应自己的数据</li><li>在服务器上创建一个临时文件夹<br>打包时需要一个文件夹存放一个个excel文件</li><li>将数据写入<br>循环数据，获取excel模版，创建WorkBook写入数据</li><li>处理excel<br>将写好的excel文件命名并写到临时文件夹去</li><li>zip打包下载<br>写完所有数据后，对该临时文件夹打包导出</li><li>删除文件<br>导出后删除临时文件夹</li></ul><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><h5 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static void writeDataToModelExcel(HttpServletRequest request, HttpServletResponse response, Map&lt;String, SalaryTaxExportVO&gt; dataMap, String corpId, String opUserId) throws Exception &#123;</span><br><span class="line">final String folderPath = PATH + FILE_NAME_SPECIAL + LINE + corpId + LINE + opUserId + LINE + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">//创建唯一临时文件夹路径</span><br><span class="line">//创建扣件单位文件路径集合</span><br><span class="line">List&lt;String&gt; companyPathList = Lists.newArrayList();</span><br><span class="line">//遍历数据写入excel</span><br><span class="line">for (Map.Entry&lt;String, SalaryTaxExportVO&gt; entry : dataMap.entrySet()) &#123;</span><br><span class="line">//获取模版文件excel</span><br><span class="line">ClassPathResource classPathResource = new ClassPathResource(&quot;xls/latestSalaryTaxDeductTemplate.xls&quot;);</span><br><span class="line">//LOGGER.warn(&quot;qqqqq&quot; + Cipher.getMaxAllowedKeyLength(&quot;AES&quot;));</span><br><span class="line">Workbook wb = WorkbookFactory.create(classPathResource.getInputStream());</span><br><span class="line">//3.获取数据</span><br><span class="line">SalaryTaxExportVO salaryTaxExportVO = entry.getValue();</span><br><span class="line">String userId = salaryTaxExportVO.getUserId();</span><br><span class="line">//将数据写到excel模版中</span><br><span class="line">writeDataToTemplate(salaryTaxExportVO, wb);</span><br><span class="line">//将文件写入服务器(创建临时文件夹)</span><br><span class="line">File newFile = new File(folderPath);</span><br><span class="line">if (!newFile.exists()) &#123;</span><br><span class="line">boolean mkdirs = newFile.mkdirs();</span><br><span class="line">if (!mkdirs) &#123;</span><br><span class="line">throw new ExcelException(&quot;文件路径生成失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取扣缴单位名称 地区 身份证</span><br><span class="line">String companyName = salaryTaxExportVO.getCompanyName();</span><br><span class="line">if(StringUtils.isBlank(companyName))&#123;</span><br><span class="line">companyName = &quot;无扣缴单位&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String area = salaryTaxExportVO.getArea();</span><br><span class="line">String certNo = salaryTaxExportVO.getCertNo();</span><br><span class="line">//创建扣缴单位文件路径</span><br><span class="line">String companyPath = folderPath + SYMBOL + companyName + SYMBOL;</span><br><span class="line">if (!companyPathList.contains(companyPath)) &#123;</span><br><span class="line">File file = new File(companyPath);</span><br><span class="line">if (!file.exists()) &#123;</span><br><span class="line">file.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">companyPathList.add(companyPath);</span><br><span class="line">&#125;</span><br><span class="line">// 向扣缴单位文件夹写文件 地区+扣缴单位名称+个人身份号码</span><br><span class="line">List&lt;String&gt; names = Lists.newArrayList();</span><br><span class="line">names.add(area);</span><br><span class="line">names.add(companyName);</span><br><span class="line">names.add(certNo);</span><br><span class="line">names.add(&quot;.xls&quot;);</span><br><span class="line">String fileName = StringUtils.join(names.stream().filter(Objects::nonNull).collect(Collectors.toList()), &quot;&quot;);</span><br><span class="line">FileOutputStream out = new FileOutputStream(companyPath + fileName);</span><br><span class="line">wb.write(out);</span><br><span class="line">wb.close();</span><br><span class="line">&#125;</span><br><span class="line">// 获取zip文件名称 （余杭、建德）+扣缴单位名称</span><br><span class="line">String folderName = &quot;个人所得税专项附加扣除申报文件.zip&quot;;</span><br><span class="line">//打包下载文件</span><br><span class="line">packToDownload(request, response, folderName, folderPath);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;writeDataToModelExcel error, corpId=&#123;&#125;, userId=&#123;&#125;.&quot;, corpId, opUserId,e);</span><br><span class="line">throw e;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// 删除文件</span><br><span class="line">delFolder(folderPath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建zip包"><a href="#创建zip包" class="headerlink" title="创建zip包"></a>创建zip包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 创建ZIP文件</span><br><span class="line">*</span><br><span class="line">* @param folderPath 文件或文件夹路径</span><br><span class="line">*/</span><br><span class="line">private static void packToDownload(HttpServletRequest request, HttpServletResponse response, String folderName, String folderPath) &#123;</span><br><span class="line">try (</span><br><span class="line">ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(outputStream)) &#123;</span><br><span class="line">//设置响应头,必须在写文件前</span><br><span class="line">DownloadUtil.setFileDownloadHeader(request, response, folderName);</span><br><span class="line">writeZip(new File(folderPath), &quot;&quot;, zos);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*</span><br><span class="line">*写文件</span><br><span class="line">*/</span><br><span class="line">private static void writeZip(File file, String parentPath, ZipOutputStream zos) &#123;</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">if (file.isDirectory()) &#123;</span><br><span class="line">//处理文件夹</span><br><span class="line">String filename = file.getName();</span><br><span class="line">if (filename.contains(FILE_NAME_SPECIAL))&#123;</span><br><span class="line">filename = &quot;个人所得税专项附加扣除申报文件&quot;;</span><br><span class="line">&#125;</span><br><span class="line">parentPath += filename + File.separator;</span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line">if (files.length != 0) &#123;</span><br><span class="line">for (File f : files) &#123;</span><br><span class="line">writeZip(f, parentPath, zos);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;       //空目录则创建当前目录</span><br><span class="line">try &#123;</span><br><span class="line">zos.putNextEntry(new ZipEntry(parentPath));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">FileInputStream fis = null;</span><br><span class="line">try &#123;</span><br><span class="line">fis = new FileInputStream(file);</span><br><span class="line">ZipEntry ze = new ZipEntry(parentPath + file.getName());</span><br><span class="line">zos.putNextEntry(ze);</span><br><span class="line">byte[] content = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = fis.read(content)) != -1) &#123;</span><br><span class="line">zos.write(content, 0, len);</span><br><span class="line">zos.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (fis != null) &#123;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*</span><br><span class="line">*设置响应头</span><br><span class="line">*/</span><br><span class="line">public static void setFileDownloadHeader(HttpServletRequest request, HttpServletResponse response, String fileName) &#123;</span><br><span class="line">final String userAgent = request.getHeader(&quot;User-Agent&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">String finalFileName = getEncodeFileName(userAgent, fileName);</span><br><span class="line">response.setContentType(&quot;application/octet-stream&quot;);</span><br><span class="line">response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; &quot; + finalFileName);</span><br><span class="line">&#125; catch (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 删除文件</span><br><span class="line">*</span><br><span class="line">* @param folderPath</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">private static void delFolder(String folderPath) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//删除完里面所有内容</span><br><span class="line">delAllFile(folderPath);</span><br><span class="line">java.io.File myFilePath = new java.io.File(folderPath);</span><br><span class="line">//删除空文件夹</span><br><span class="line">myFilePath.delete();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil delFolder 删除文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean delAllFile(String path) &#123;</span><br><span class="line">boolean flag = false;</span><br><span class="line">File file = new File(path);</span><br><span class="line">if (!file.exists()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (!file.isDirectory()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">String[] tempList = file.list();</span><br><span class="line">if (ArrayUtils.isEmpty(tempList)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">for (String aTempList : tempList) &#123;</span><br><span class="line">File temp;</span><br><span class="line">if (path.endsWith(File.separator)) &#123;</span><br><span class="line">temp = new File(path + aTempList);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">temp = new File(path + File.separator + aTempList);</span><br><span class="line">&#125;</span><br><span class="line">if (temp.isFile()) &#123;</span><br><span class="line">temp.delete();</span><br><span class="line">&#125;</span><br><span class="line">if (temp.isDirectory()) &#123;</span><br><span class="line">//先删除文件夹里面的文件</span><br><span class="line">delAllFile(path + &quot;/&quot; + aTempList);</span><br><span class="line">//再删除空文件夹</span><br><span class="line">delFolder(path + &quot;/&quot; + aTempList);</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li>创建临时文件时，一定要保证文件名唯一（防止同一时间并发，导出串数据），这里采用了corpId-userId-UUID</li><li>后缀.xls表示07之前的版本 使用HSSFWookBook，.xlsx是07之后的版本XSSFWookBook，这里使用POI兼容的方式，自动帮你识别：Workbook wb = WorkbookFactory.create(classPathResource.getInputStream())；</li><li>在循环中每写完一个excel都要关流 wb.close() — 因为是多个excel</li><li>最后一定要删除服务器上的文件（防止文件堆积占用内存）</li><li>HSSF对excel函数方法较多不支持导致导出的文件一些版本的excel内容不可读，不过用WPS可以正常打开</li><li>设置响应头,必须在写文件前</li><li>JCE策略文件-读取excel加密文件时，jdk版本需要在”1.8.0_161以上，否则需要安装第三方jar包（US_export_policy.jar , local_policy.jar　）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>maven基本知识</title>
    <link href="http://yoursite.com/2018/12/23/maven%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/23/maven基础知识/</id>
    <published>2018-12-22T23:49:55.000Z</published>
    <updated>2020-07-15T06:39:22.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>maven是项目管理工具，主要有两个特性: 依赖管理和一键构建.</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h5 id="依赖管理就是对jar包的管理过程"><a href="#依赖管理就是对jar包的管理过程" class="headerlink" title="依赖管理就是对jar包的管理过程."></a>依赖管理就是对jar包的管理过程.</h5><p>传统的工程项目是直接放置jar包，maven工程真正的jar包在仓库中放置，项目中只放置jar包的坐标(pom.xml). </p><h5 id="仓库分三类-："><a href="#仓库分三类-：" class="headerlink" title="仓库分三类 ："></a>仓库分三类 ：</h5><p>本地仓库,远程仓库【私服】,中央仓库.<br>本地仓库是我们运行项目第一步必须本地仓库有对应的坐标，如果没有默认自动去中央仓库下载，在公司中会先从远程仓库下载，远程仓库没有，会从中央仓库下载或本地上传.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ….&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.dintalent.salary&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; </span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt; </span><br><span class="line">&lt;name&gt;mavenDemo&lt;/name&gt;  </span><br><span class="line">&lt;url&gt;http://maven.apache.org&lt;/url&gt;  </span><br><span class="line">&lt;dependencies&gt;  </span><br><span class="line">&lt;dependency&gt;   </span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;   </span><br><span class="line">&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><ul><li>groupId : 标识公司,组织,团体(taobao.com对应com.taobao,apche.org对应org.apache)</li><li>artifactId ：工程名</li><li>version :版本号 （SNAPSHOT表示测试版本）</li><li>packaging ： 打成什么包(jar,war,pom)</li><li>scope : 依赖范围（例如test 表示对测试代码classpath有效）</li></ul><h2 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h2><p>一键构建就是我们使用maven集成的tomcat插件对项目进行编译，测试，打包，安装等操作.</p><ul><li>清理生命周期：clean</li><li>默认生命周期：compile(编译),test(测试),package(打包),install(安装).</li></ul><h2 id="jar包冲突问题"><a href="#jar包冲突问题" class="headerlink" title="jar包冲突问题"></a>jar包冲突问题</h2><p>简单理解就是应用程序依赖的同一个jar包出现了多个不同的版本，选择了错误的版本导致JVM加载不到类或加载了错误版本的类.</p><ul><li>直接依赖： A项目导入了B包，A直接依赖B包</li><li>传递依赖： A项目导入了B包，B包直接依赖C包，最终A可以使用C</li></ul><h5 id="解决jar冲突的三个原则"><a href="#解决jar冲突的三个原则" class="headerlink" title="解决jar冲突的三个原则"></a>解决jar冲突的三个原则</h5><ol><li>第一声明原则：哪个jar包的坐标靠上，这个jar包就是第一声明的包，最终进入项目的就是它.</li><li>路径近者优先原则：直接依赖路径比传递依赖近，进入项目的就是路径近的.</li><li>直接排除法： 使用<exlusions></exlusions>标签直接排除某个包的依赖包.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义注解简单使用</title>
    <link href="http://yoursite.com/2018/10/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/21/自定义注解使用/</id>
    <published>2018-10-20T23:03:55.000Z</published>
    <updated>2020-07-15T06:38:53.017Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>需要对一些用户行为的接口进行日志埋点统计,如果在业务代码写的话代码比较杂乱,而且之后改动也不方便,于是便决定使用自定义注解，使用spring的切面注解@Aspect.</p><h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>Java文件叫做Annotation，用@interface表示。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>@interface上面按需要注解上一些东西，包括@Retention、@Target、@Document、@Inherited四种.</p><ul><li>@Target 表示该注解可以用于什么地方</li><li>@Retention 注解的声明周期，用于定义注解的存活阶段，可以存活在源码级别、编译级别(字节码级别)、运行时级别</li><li>@Document 将注解包含在Javadoc中</li><li>@Inherited 允许子类继承父类中的注解</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p> 基于注解的知识，自己创建一个注解</p><ul><li>实现过程<br>首先创建一个自定义注解 -&gt; 采用spring的@Aspect创建一个切面类,在这个切中获取信息并且打印日志 -&gt; 在记录的接口上写上注解</li><li>简单示例代码<br><img src="https://github.com/geyou1995/picture/blob/master/Annotations1.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations2.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations3.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations4.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations5.png?raw=true" alt=""><blockquote><p>参考：项目中的操作日志的方法</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8新特性Lambda和Stream</title>
    <link href="http://yoursite.com/2018/09/18/Java8%E6%96%B0%E7%89%B9%E6%80%A7Lambda%E5%92%8CStream/"/>
    <id>http://yoursite.com/2018/09/18/Java8新特性Lambda和Stream/</id>
    <published>2018-09-18T01:10:55.000Z</published>
    <updated>2020-07-15T06:39:04.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目前项目应用的是Java 1.8版本,在项目中看到其他小伙伴使用了奇特的编码方式，许多行代码简化成了一行，原来是Java8的特性Lambda和Stream,结合代码和网上查资料学习了一下，并将相关的的知识做了下总结.</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda简单的理解就是一个匿名方法，一段带有输入参数的可执行语句块.</p><ul><li>语法：（）-&gt; {}   (小括号里是参数，大括号里是方法体)</li><li>特点：<pre><code>1.参数类型可以省略，编译器可以从上下文环境中推断出来2.当lambda表达式的参数个数只有一个的时候，小括号可以省略3.当lambda表达式只包含一条语句时，可以省略大括号，return，语句结尾的分号4.lambda表达式可以访问外部变量，但是要求这个变量不可变（final修饰）</code></pre></li><li>方法引用：<pre><code>1.类实例引用：   Person::getName2.类静态方法引用：Max::max </code></pre></li><li>构造器引用：<pre><code>Person::new（等同于 x-&gt;new Person(x)）</code></pre></li></ul><hr><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作。数据源一般是数组或集合等，进行聚合操作可以获取想要的结果。</p><ul><li>基本步骤：获取一个数据源（source）-&gt; 数据转化 -&gt; 执行操作获取想要的结果.(简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果)</li><li>创建Stream<pre><code>1.Stream静态方法：Stream.of();2.Collection子类获取Stream（最常用）：list.Stream();</code></pre></li><li>Stream流操作<br>  *Intermediate（中间）: 一个流可以跟多个中间操作，主要是打开流对数据进行某种映射或过滤.<pre><code>常见操作:    map() - 对stream里的元素进行映射转化    filter() - 对Stream包含对元素按给定的条件过滤    distinct() - 对stream包含对元素进行去重    sorted() - 对stream包含对元素排序    peek() -  生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数        limit() - 对Stream里的元素取前n个    skip(n) - 对stream里的元素丢弃前n个，获取之后的元素    parallel() - 将一个顺序执行的流转变成一个并发的流（还有一种Collection.parallelStream()）    sequential() - 一个并行流转换成一个顺序流        unordered() - 实现无序流</code></pre></li><li>Terminal(终端): 一个流只能有一个终端操作，这是流对最后一个操作，用来处理结果数据。<pre><code>常见操作:     forEach() - 遍历结果数据（并行处理）    forEachOrdered - 遍历结果数据（顺序处理）    toArray（） - 将数据输入到数组中    reduce（） - 把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合    collect（） - 实现了很多归约操作，例如将流转换成集合和聚合元素    count() - 获取stream里的元素个数    min() - 最小值    max() - 最大值    anyMatch() - Stream中是否存在任何一个元素满足匹配条件    allMatch() - 是不是Stream中的所有元素都满足给定的匹配条件    noneMatch() - 是不是Stream中的所有元素都不满足给定的匹配条件    findFirst() - 返回Stream中的第一个元素，如果Stream为空，返回空Optional    findAny() - 返回这个Stream中，取到的任何一个对象</code></pre></li><li>简单示例代码</li><li>七牛云大坑逼！！！！！<br><img src="https://github.com/geyou1995/geyou1995.github.io/blob/master/wallhave.n-664820.jpg?raw=true" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test1.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test2.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test3.1.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test3.2.png" alt=""><blockquote><p>参考：<a href="https://yuque.antfin-inc.com/mdc/doc/rhihn7" target="_blank" rel="noopener">https://yuque.antfin-inc.com/mdc/doc/rhihn7</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac系统Idea常用快捷键</title>
    <link href="http://yoursite.com/2018/09/09/Mac%E7%B3%BB%E7%BB%9F%E4%B8%8BIdea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/09/09/Mac系统下Idea快捷键/</id>
    <published>2018-09-09T02:24:45.000Z</published>
    <updated>2020-07-15T06:42:32.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直使用的Java编译工具是eclipse,进新公司之后,公司配了一台Mac并且后端都用IntelliJ IDEA开发,不能脱离团队呀,果断入手了IDEA,不得不说比eclipse更加的智能好用,为了提高开发效率，所以决定整理一下IDEA的常用快捷键,不想每次都配,所以就决定用IDEA默认的快捷键,用的是Mac OS X 10.5+ 但是Mac系统中与IDEA的快捷键有些冲突,可以把Mac相关冲突的快捷键更改或取消掉.下面整理了平常开发中常用的快捷键，以便于更好的记忆和熟练使用.</p><h2 id="Mac键盘符号和修饰健说明"><a href="#Mac键盘符号和修饰健说明" class="headerlink" title="Mac键盘符号和修饰健说明"></a>Mac键盘符号和修饰健说明</h2><p>⌘ Command<br>⇧ Shift<br>⌥ Option<br>⌃ Control<br>↩︎ Return/Enter<br>⌫ Delete<br>⌦ 向前删除键（Fn+Delete）<br>↑ 上箭头<br>↓ 下箭头<br>← 左箭头<br>→ 右箭头<br>⇞ Page Up（Fn+↑）<br>⇟ Page Down（Fn+↓）<br>Home Fn + ←<br>End Fn + →<br>⇥ 右制表符（Tab键）<br>⇤ 左制表符（Shift+Tab）<br>⎋ Escape (Esc)</p><h2 id="Editing编辑"><a href="#Editing编辑" class="headerlink" title="Editing编辑"></a>Editing编辑</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Control+Space 基本的代码补全(补全任何类,方法,变量) 注意这里与Mac系统的输入法快捷键冲突</span><br><span class="line">Control+Shift+Space 智能代码补全 (过滤器方法列表和变量的预期类型）</span><br><span class="line">Command+Shift+Enter 自动结束代码,行末添加分号</span><br><span class="line">Command+P  显示方法的参数</span><br><span class="line">Control+J  快速显示文档</span><br><span class="line">Command+鼠标放在代码上  显示代码简要信息</span><br><span class="line">Command+N  生成代码（getter、setter、构造函数、hashCode/equals,toString,实现接口方法）这个还有其他快捷键我只记这一种了</span><br><span class="line">Control+O  覆盖方法(重写父类方法)</span><br><span class="line">Control+I  实现接口方法(我直接记Command+N,也能实现接口方法)</span><br><span class="line">Command+Option+T 包围代码(try catch,if else,do while等)</span><br><span class="line">Command+/ 行注释代码(再按一次就是取消注释)</span><br><span class="line">Command+Option+/ 块注释</span><br><span class="line">Option+方向上  连续选中代码块</span><br><span class="line">Option+方向下  减少选中的代码块</span><br><span class="line">Control+Shift+Q 显示上下文信息</span><br><span class="line">Option+Enter  显示意向动作和快速修复代码</span><br><span class="line">Command+Option+L 格式化代码</span><br><span class="line">Control+Option+O 优化import</span><br><span class="line">Tab  缩进代码</span><br><span class="line">Command+C 复制</span><br><span class="line">Command+V 粘贴</span><br><span class="line">Command+X 剪切</span><br><span class="line">Command+D 复制当前行或选定的块</span><br><span class="line">Command+Delete 删除当前行或选定的行的块</span><br><span class="line">Control+Shift+J 智能的将代码拼接成一行</span><br><span class="line">Command+Enter 智能的拆分拼接的行</span><br><span class="line">Command+加号/减号 展开/折叠代码块</span><br><span class="line">Command+Shift+加号/减号 展开/折叠所有代码块</span><br><span class="line">Command+W 关闭活动的编辑器选项</span><br><span class="line">Command+Shift+上下  上下移动代码</span><br></pre></td></tr></table></figure><h2 id="Search-Replace（查询-替换"><a href="#Search-Replace（查询-替换" class="headerlink" title="Search/Replace（查询/替换)"></a>Search/Replace（查询/替换)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command+F 文件内查找</span><br><span class="line">Command+Shift+F 全局查找</span><br><span class="line">Command+G 查找模式下向下查找</span><br><span class="line">Command+Shift+G 查找模式下向上查找</span><br></pre></td></tr></table></figure><h2 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Option+F7 在文件中查找用到的地方</span><br><span class="line">Command+F7 在类中查找用到的地方</span><br><span class="line">Command+Shift+F7 在类中显示(颜色标记)用到的地方</span><br><span class="line">Command+Option+F7 显示用法</span><br></pre></td></tr></table></figure><h2 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Command+F9 编译Project</span><br><span class="line">Command+Shift+F9 编译选择的文件,包或模块</span><br><span class="line">Control+Option+R 弹出Run的可选菜单</span><br><span class="line">Control+Option+R 弹出Debug的可选菜单</span><br><span class="line">Control+D 调试</span><br></pre></td></tr></table></figure><h2 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F8 进入下一步,不进入当前方法内</span><br><span class="line">F7 进入下一步,如果当前断点式方法,则进入方法内</span><br><span class="line">Shift+F8 跳出</span><br><span class="line">Option+F9 运行到光标停留处</span><br><span class="line">F9 放开debug </span><br><span class="line">Command+Shift+F8 查看断点信息</span><br></pre></td></tr></table></figure><h2 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shift+Shift 查找文件</span><br><span class="line">Command+L 跳转行</span><br><span class="line">Command+E 显示最近打开的文件记录列表</span><br><span class="line">Command+Option+方向键左/右  退回/前进到上一个操作的地方</span><br><span class="line">Command+B 或Command+鼠标左键  进入方法或变量的接口或是定义处</span><br><span class="line">Command+Option+B 越过接口,直接跳掉实现处</span><br></pre></td></tr></table></figure><h2 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F5 复制文件到指定目录</span><br><span class="line">Command+delete 在文件上安全删除文件,弹出确认框</span><br><span class="line">Shift+F6 重命名文件</span><br><span class="line">Command+Option+M 将选中的代码提取为方法</span><br></pre></td></tr></table></figure><h2 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+, 打开idea系统设置</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
