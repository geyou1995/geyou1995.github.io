<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我就是胖着玩玩的</title>
  
  <subtitle>坚持产生意外✊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-25T08:38:55.472Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Youga</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="http://yoursite.com/2021/01/25/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2021/01/25/JVM内存模型/</id>
    <published>2021-01-25T05:45:58.000Z</published>
    <updated>2021-02-25T08:38:55.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JVM模型由多个部分组成,总是零零散散的知道某部分一点知识,本章来总结一下JVM内存模型的各个部分.</p><h1 id="JVM内存模型图"><a href="#JVM内存模型图" class="headerlink" title="JVM内存模型图"></a>JVM内存模型图</h1><p><img src="https://github.com/geyou1995/picture/blob/master/jvm2.png?raw=true" alt=""></p><p>由上图可知组成部分为堆、栈、本地方法栈、元空间、程序计数器。</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>注：栈、本地方法栈、程序计数器每个线程独有，方法区、堆共有.先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.Math.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.使用javap -c Math.class 编译这段代码</span></span><br><span class="line">Compiled from <span class="string">"Math.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myself</span>.<span class="title">jvm</span>.<span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> myself.jvm.User user;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> myself.jvm.Math();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      <span class="number">12</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class myself/jvm/Math</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       9: invokevirtual #4                  // Method compute:()I</span><br><span class="line">      <span class="number">12</span>: pop</span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #5                  // class myself/jvm/User</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #6                  // Method myself/jvm/User."&lt;init&gt;":()V</span><br><span class="line">       7: putstatic     #7                  // Field user:Lmyself/jvm/User;</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.拿compute()方法举例解释各行代表的意思 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1 <span class="comment">// 将int类型常量1压入操作数栈</span></span><br><span class="line">       <span class="number">1</span>: istore_1 <span class="comment">// 将int类型值存入局部变量1</span></span><br><span class="line">       <span class="number">2</span>: iconst_2 <span class="comment">// 将int类型常量2压入栈</span></span><br><span class="line">       <span class="number">3</span>: istore_2 <span class="comment">// 将int类型值存入局部变量2</span></span><br><span class="line">       <span class="number">4</span>: iload_1 <span class="comment">// 从局部变量1中装载int类型值</span></span><br><span class="line">       <span class="number">5</span>: iload_2 <span class="comment">// 从局部变量2中装载int类型值</span></span><br><span class="line">       <span class="number">6</span>: iadd <span class="comment">// 执行int类型的加法</span></span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span> <span class="comment">// 将一个8位带符号整数压入栈，这里是10</span></span><br><span class="line">       <span class="number">9</span>: imul <span class="comment">//  执行int类型的乘法</span></span><br><span class="line">      <span class="number">10</span>: istore_3 <span class="comment">// 将int类型值存入局部变量3</span></span><br><span class="line">      <span class="number">11</span>: iload_3 <span class="comment">// 从局部变量3中装载int类型值</span></span><br><span class="line">      <span class="number">12</span>: ireturn <span class="comment">// 从方法中返回int类型的数据</span></span><br></pre></td></tr></table></figure><h3 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a><strong>程序计数器（PC寄存器）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用</span></span><br><span class="line">存储每行代码执行的位置,即上处代码的行号.</span><br><span class="line"><span class="comment">// 原因    </span></span><br><span class="line">由于多线程,CPU资源争夺,当线程A执行一段代码后,CPU资源被线程B占有,当B执行完，A重新获取CPU后，会根据程序计数器记录的代码行号继续执行之后的代码.</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h3><p><img src="https://github.com/geyou1995/picture/blob/master/jvm4.png?raw=true" alt=""></p><p><img src="https://github.com/geyou1995/picture/blob/master/jvm3.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程栈,存放局部变量</span></span><br><span class="line"><span class="comment">// 上图结合Math.class查看，可以获知</span></span><br><span class="line"><span class="number">1</span>.每当线程执行一个方法，虚拟机就会在栈里给该线程分配内存空间.FIFO(先进后出,和程序调用顺序吻合).</span><br><span class="line"><span class="number">2</span>.一个方法对应一个栈帧,上图（main()、compute（）分别分配了一块栈帧空间）</span><br><span class="line"><span class="number">3</span>.栈帧组成（结合compute()方法javac编译结果理解）</span><br><span class="line">  局部变量表：方法局部变量a;如果局部变量是对象，存的是对象在堆的内存地址.</span><br><span class="line">  操作数栈:程序在运行时,临时存放数值的中转空间.</span><br><span class="line">  动态链接：在程序运行时,把符合引用转化为符号的直接引用代码。例如math.compute(); -&gt; 对应的.CLASS里的代码</span><br><span class="line">  方法出口:方法执行完后，返回指定的代码位置.</span><br></pre></td></tr></table></figure><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分配给本地方法的栈内存空间。本地方法 <span class="keyword">native</span>,java语言调用C语言.</span><br></pre></td></tr></table></figure><h3 id="方法区（元空间）"><a href="#方法区（元空间）" class="headerlink" title="方法区（元空间）"></a><strong>方法区</strong>（元空间）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量+静态变量（也有对象的内存地址）+类元信息（代码.CLASS）</span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h3><p><img src="https://github.com/geyou1995/picture/blob/master/jvm6.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用</span></span><br><span class="line">存储对象的内存空间</span><br><span class="line"><span class="comment">// 组成</span></span><br><span class="line">年轻代：Eden区 + s0 + s1,默认占<span class="number">1</span>/<span class="number">3</span></span><br><span class="line">老年代:默认占<span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="comment">// 当空间垃圾对象增多时,会触发gc</span></span><br><span class="line">在年轻代的是yong gc,老年代也满的时候会触发full gc,Fullgc时可能导致stw(stop the world),即停止用户的所有线程.</span><br><span class="line"><span class="comment">// 具体的细节，之后会结合垃圾收集器一起总结.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis之性能优化</title>
    <link href="http://yoursite.com/2021/01/12/Redis%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/01/12/Redis之性能优化/</id>
    <published>2021-01-12T11:49:58.000Z</published>
    <updated>2021-01-12T13:19:17.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h1><p><img src="https://github.com/geyou1995/picture/blob/master/redis-13.png?raw=true" alt=""></p><h1 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h1><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>说明</strong><br>缓存穿透是指查询一个根本不存在的数据,缓存和数据库都不会命中,如果数据库查不到则不写入缓存.这样将导致不存在的数据的每次请求都要查询数据库,失去了缓存保护后端数据库的意义.</p><p><strong>造成原因</strong><br>1.自身业务代码或数据出现问题.<br>2.一些恶意攻击、爬虫等造成大量空命中.</p><p><strong>解决方案</strong><br>1.缓存空对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去数据库获取数据等时候,如果为null,就塞一个空对象到缓存,防止连续访问,还得设置时间,如果这个key有了真实的值后再去获取</span></span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">   <span class="comment">// 从缓存中获取数据 </span></span><br><span class="line">   String cacheValue = cache.get(key); </span><br><span class="line">   <span class="comment">// 缓存为空</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123; </span><br><span class="line">     <span class="comment">// 从存储中获取 </span></span><br><span class="line">     String storageValue = storage.get(key); </span><br><span class="line">     cache.set(key, storageValue);</span><br><span class="line">     <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span></span><br><span class="line">      <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123; </span><br><span class="line">        cache.expire(key, <span class="number">60</span> * <span class="number">5</span>); </span><br><span class="line">      &#125; </span><br><span class="line">     <span class="keyword">return</span> storageValue; </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 缓存非空 </span></span><br><span class="line">     <span class="keyword">return</span> cacheValue; </span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2.布隆过滤器<br><img src="https://github.com/geyou1995/picture/blob/master/redis-17.png?raw=true" alt=""></p><p>对于恶意攻击,向服务器请求大量不存在的数据导致缓存击穿,还可以使用布隆过滤器先做一次过滤,不让请求再往后端发送.核心:<strong>当布隆过滤器说某个值存在时，不一定存在;当它说这个值不存在时一定不存在.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单总结</span></span><br><span class="line"><span class="number">1</span>.首先会将缓存中的key通过一系列的hash算法，找到布隆过滤器对应数组的索引,标记<span class="string">'1'</span>.</span><br><span class="line"><span class="number">2</span>.get()数据时，也会将key进行一系列的hash算法,如果算出来的值，都是<span class="string">'1'</span>，说明这个值可能存在.如果有不为<span class="string">'1'</span>的那就一定不存在.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同担心hash冲突,布隆过滤器的数组会非常大,通常是百亿</span></span><br><span class="line"><span class="comment">// 相较于第一种往缓存中放空对象的方式,布隆过滤器更加的节省空间.</span></span><br></pre></td></tr></table></figure><h3 id="缓存击穿（失效）"><a href="#缓存击穿（失效）" class="headerlink" title="缓存击穿（失效）"></a>缓存击穿（失效）</h3><p><strong>说明</strong><br>指缓存中没有数据，数据库中有数据。一般是并发用户多，缓存时间刚好到期，缓存中读不到数据，直接去数据库读取，造成数据库压力大。</p><p><strong>解决方案</strong></p><p>1.设置热点数据永远不过期。<br>2.代码里加互斥锁，缓存中没数据，第一个进入的线程获取锁从数据库读取数据，读到后再放入缓存，其他线程等待，再重新去缓存中获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码 -- 热点缓存key重建优化</span></span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 从缓存中获取数据 </span></span><br><span class="line">  String cacheValue = cache.get(key); </span><br><span class="line">  <span class="comment">// 缓存为空 </span></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123; </span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">       <span class="comment">// 从存储中获取</span></span><br><span class="line">    String storageValue = storage.get(key); </span><br><span class="line">    cache.set(key, storageValue); </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 释放锁</span></span><br><span class="line">   unlock();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">// 睡眠1秒，再去缓存获取</span></span><br><span class="line">   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">   get(key);</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>说明</strong><br>指缓存中大批数据过期，而查询数量巨大，导致数据库压力大，甚至宕机。和缓存击穿不同的是，缓存击穿是并发查同一数据。缓存雪崩时不同数据都过期了。</p><p><strong>解决方案</strong><br>1.设置热点数据永不过期。<br>2.缓存数据的过期时间随机，防止同一时间出现大量数据过期。</p><h3 id="缓存数据库双写不一致问题"><a href="#缓存数据库双写不一致问题" class="headerlink" title="缓存数据库双写不一致问题"></a>缓存数据库双写不一致问题</h3><p><strong>说明</strong><br>在大并发下,同时操作数据库和缓存会存在数据不一致性.</p><p><strong>1.双写不一致</strong><br><img src="https://github.com/geyou1995/picture/blob/master/redis-14.png?raw=true" alt=""></p><p><strong>2.读写不一致</strong><br><img src="https://github.com/geyou1995/picture/blob/master/redis-15.png?raw=true" alt=""></p><p><strong>解决方案</strong><br>1如果业务上能容忍,就加上缓存过期时间，可以解决大部分业务对于缓存的需求。<br>2.如果无法容忍数据不一致,可以加读写锁保证并发读写或写写的时候按顺序排好队,读读相当无锁。<br>3.使用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存,但是引入中间件增加系统复杂性.<br><img src="https://github.com/geyou1995/picture/blob/master/redis-16.png?raw=true" alt=""></p><h1 id="Redis淘汰策略"><a href="#Redis淘汰策略" class="headerlink" title="Redis淘汰策略"></a>Redis淘汰策略</h1><p><strong>a.被动删除</strong><br>当读写一个已经过期的key时,会触发惰性删除策略,直接删除掉这个过期key.</p><p><strong>b.主动删除</strong><br>由于惰性删除策略无法保证冷数据被及时删除.所以redis会定期主动淘汰一批已经过期的key.</p><p><strong>c.内存超过maxmemory限定时,触发清理策略</strong><br>4.0之前一共6种，4.0之后一共8种.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对设置了过期时间的key做处理</span></span><br><span class="line"><span class="number">1</span>.<span class="keyword">volatile</span>-ttl</span><br><span class="line">在筛选时,会针对设置了过期时间的健值对,根据过期时间的先后进行删除,越早过期的越先被删除.</span><br><span class="line"><span class="number">2</span>.<span class="keyword">volatile</span>-random</span><br><span class="line">针对设置了过期时间的健值对随机删除.</span><br><span class="line"><span class="number">3</span>.<span class="keyword">volatile</span>-lru</span><br><span class="line">默认机制，针对设置了时间的健值对,会优先删除最近最少使用的key.（以最近时间为参考）</span><br><span class="line"><span class="number">4</span>.<span class="keyword">volatile</span>-lfu</span><br><span class="line">针对设置了时间的健值对,会优先删除最近访问次数最少的key.（以次数为参考）</span><br><span class="line"><span class="comment">// 针对所有的key做处理</span></span><br><span class="line"><span class="number">5</span>.allkeys-random</span><br><span class="line">从所有键值对中随机选择并删除数据</span><br><span class="line"><span class="number">6</span>.allkeys-lru</span><br><span class="line">所有健值对中,会优先删除最近最少使用的key.（以最近时间为参考）</span><br><span class="line"><span class="number">7</span>.allkeys-lfu</span><br><span class="line">所有健值对中，会优先删除最近访问次数最少的key.（以次数为参考）</span><br><span class="line"><span class="comment">// 不处理</span></span><br><span class="line"><span class="number">8</span>.noeviction</span><br><span class="line">不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息,这时只能读数据,不能写.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis之常用架构</title>
    <link href="http://yoursite.com/2021/01/07/Redis%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2021/01/07/Redis之常用架构/</id>
    <published>2021-01-07T06:49:58.000Z</published>
    <updated>2021-01-12T13:19:07.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h1><p>1.sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。<br>2.一个sentinel哨兵也是一个redis实例.<br>3.哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</p><p><img src="https://github.com/geyou1995/picture/blob/master/redis-11.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redir哨兵架构搭建步骤</span></span><br><span class="line"><span class="number">1</span>.复制一份sentinel.conf文件</span><br><span class="line"><span class="number">2</span>.将相关配置修改为如下值</span><br><span class="line">  port <span class="number">26379</span></span><br><span class="line">  daemonize yes</span><br><span class="line">  pidfile <span class="string">"/var/run/redis‐sentinel‐26379.pid"</span></span><br><span class="line">  logfile <span class="string">"26379.log"</span></span><br><span class="line">  dir <span class="string">"/usr/local/redis‐5.0.3/data"</span></span><br><span class="line">  sentinel monitor mymaster <span class="number">127.0</span>.0.1 <span class="number">6379</span> <span class="number">2</span> --指定主节点ip,端口 <span class="number">2</span>-代表指明当有多少个sentinel认为一个master失效时才失效</span><br><span class="line"> <span class="number">3</span>.启动sentinel哨兵实例</span><br><span class="line">  src/redis‐sentinel sentinel‐<span class="number">26379</span>.conf</span><br><span class="line"> <span class="number">4</span>.查看sentinel的info信息,可以看到Sentinel的info里已经识别出了redis的主从信息</span><br><span class="line">  ...</span><br><span class="line">  # Sentinel</span><br><span class="line">sentinel_masters:<span class="number">1</span></span><br><span class="line">sentinel_tilt:<span class="number">0</span></span><br><span class="line">sentinel_running_scripts:<span class="number">0</span></span><br><span class="line">sentinel_scripts_queue_length:<span class="number">0</span></span><br><span class="line">sentinel_simulate_failure_flags:<span class="number">0</span></span><br><span class="line">master0:name=mymaster,status=ok,address=<span class="number">127.0</span>.0.1:<span class="number">6379</span>,slaves=<span class="number">2</span>,sentinels=<span class="number">3</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 类似的可以多配几个哨兵</span></span><br></pre></td></tr></table></figure><p><strong>哨兵选举流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当一个master服务器被sentinel看作下线状态后,该sentinel会与其他哨兵协商选出烧饼的leader进行故障转移工作.</span><br><span class="line"><span class="number">1</span>.每个发现master下线的哨兵都可以要求其他哨兵选自己为哨兵的leader,选举先到先得.</span><br><span class="line"><span class="number">2</span>.同时每个哨兵每次选举都会自增配置纪元（选举周期）,每个纪元只会选择一个sentine的leader.</span><br><span class="line"><span class="number">3</span>.如果超过一半的哨兵选举某个哨兵为leader，这个哨兵就会进行故障转移操作,从存活的slave中选举新的master.整个过程类似集群选举.</span><br><span class="line"><span class="comment">// 如果哨兵集群只有一个哨兵,如果master挂了，这个哨兵自动成为leader，已可以正常选举。</span></span><br><span class="line">但是为了高可用,一半推荐至少部署三个哨兵节点</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哨兵模式的缺陷</span></span><br><span class="line"><span class="number">1</span>.如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般.</span><br><span class="line"><span class="number">2</span>.在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发.</span><br><span class="line"><span class="number">3</span>.单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率.</span><br></pre></td></tr></table></figure><h1 id="Redis高可用集群架构"><a href="#Redis高可用集群架构" class="headerlink" title="Redis高可用集群架构"></a>Redis高可用集群架构</h1><p>Redis3.0以后的版本虽然有了集群功能，提供了比以前版本的哨兵模式更高的性能和可用性，但是集群的水平扩展却比较麻烦，这里来搭建Redis集群,6个节点，采用三主三从的模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集群模式的数据是分片存放的，各个节点的数据都不同.水平扩展可以10000个，官方推荐不要超过1000.</span></span><br><span class="line"><span class="comment">// 至少三个主节点,从节点不支持读写，从节点的功能就是数据备份.</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/geyou1995/picture/blob/master/redis-12.png?raw=true" alt=""></p><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><p><strong>准备配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是单机启动多个节点</span></span><br><span class="line"><span class="number">1</span>.创建三个目录,每个目录下配置两个节点,<span class="number">8001</span>，<span class="number">8002</span>;<span class="number">8003</span>，<span class="number">8006</span>；<span class="number">8007</span>，<span class="number">8008</span>分别三组<span class="number">6</span>个实例.</span><br><span class="line"><span class="number">2</span>.修改对应的配置文件，以<span class="number">8001</span>为例</span><br><span class="line">daemonize yes -- 是否用守护线程启动</span><br><span class="line">port <span class="number">8001</span> -- 对应端口号</span><br><span class="line">dir ./ --指定数据存放位置</span><br><span class="line">  cluster-enabled yes --启动集群模式</span><br><span class="line">  cluster-config-file nodes-<span class="number">8001</span>.conf --集群节点信息，这里<span class="number">800</span>x与port对应上</span><br><span class="line">  cluster-node-timeout <span class="number">5000</span> --超时时间</span><br><span class="line">  <span class="keyword">protected</span>-node no -- 关闭保护模式</span><br><span class="line">  appendonly yes </span><br><span class="line">  </span><br><span class="line">  requirepass gy -- 设置redis访问密码</span><br><span class="line">  masterauth gy -- 设置集群节点间访问密码</span><br></pre></td></tr></table></figure><p><strong>启动集群</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">guMacBook-Pro:redis geyou$ src/redis-server redis-cluster1/<span class="number">8007</span>/redis.conf </span><br><span class="line">guMacBook-Pro:redis geyou$ src/redis-server redis-cluster1/<span class="number">8008</span>/redis.conf </span><br><span class="line">guMacBook-Pro:redis geyou$ src/redis-server redis-cluster2/<span class="number">8001</span>/redis.conf </span><br><span class="line">guMacBook-Pro:redis geyou$ src/redis-server redis-cluster2/<span class="number">8002</span>/redis.conf </span><br><span class="line">guMacBook-Pro:redis geyou$ src/redis-server redis-cluster3/<span class="number">8003</span>/redis.conf </span><br><span class="line">guMacBook-Pro:redis geyou$ src/redis-server redis-cluster3/<span class="number">8006</span>/redis.conf </span><br><span class="line">-----</span><br><span class="line">  <span class="number">501</span> <span class="number">49031</span>     <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>:<span class="number">54</span>下午 ??         <span class="number">0</span>:<span class="number">00.16</span> src/redis-server <span class="number">127.0</span>.0.1:<span class="number">8007</span> [cluster] </span><br><span class="line">  <span class="number">501</span> <span class="number">49035</span>     <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>:<span class="number">55</span>下午 ??         <span class="number">0</span>:<span class="number">00.11</span> src/redis-server <span class="number">127.0</span>.0.1:<span class="number">8008</span> [cluster] </span><br><span class="line">  <span class="number">501</span> <span class="number">49037</span>     <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>:<span class="number">55</span>下午 ??         <span class="number">0</span>:<span class="number">00.08</span> src/redis-server <span class="number">127.0</span>.0.1:<span class="number">8001</span> [cluster] </span><br><span class="line">  <span class="number">501</span> <span class="number">49039</span>     <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>:<span class="number">55</span>下午 ??         <span class="number">0</span>:<span class="number">00.07</span> src/redis-server <span class="number">127.0</span>.0.1:<span class="number">8002</span> [cluster] </span><br><span class="line">  <span class="number">501</span> <span class="number">49042</span>     <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>:<span class="number">55</span>下午 ??         <span class="number">0</span>:<span class="number">00.03</span> src/redis-server <span class="number">127.0</span>.0.1:<span class="number">8003</span> [cluster] </span><br><span class="line">  <span class="number">501</span> <span class="number">49044</span>     <span class="number">1</span>   <span class="number">0</span>  <span class="number">1</span>:<span class="number">55</span>下午 ??         <span class="number">0</span>:<span class="number">00.02</span> src/redis-server <span class="number">127.0</span>.0.1:<span class="number">8006</span> [cluster]</span><br></pre></td></tr></table></figure><p><strong>组成集群</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述还只是6个游离的实例，还未组成集群</span></span><br><span class="line"><span class="comment">// 查看帮助文档</span></span><br><span class="line">src/redis-cli --cluster help</span><br><span class="line">----</span><br><span class="line">create：创建一个集群环境host1:port1 ... hostN:portN </span><br><span class="line">call：可以执行redis命令</span><br><span class="line">add-node：将一个节点添加到集群里，第一个参数为新节点的ip:port，第二个参数为集群中任意一个已经存在的节点的ip:port</span><br><span class="line">el-node：移除一个节点</span><br><span class="line">reshard：重新分片</span><br><span class="line">check：检查集群状态</span><br><span class="line"><span class="comment">// 创建集群命令</span></span><br><span class="line">redis-cli -a gy --cluster create --cluster-replicas <span class="number">1</span> <span class="number">127.0</span>.0.1:<span class="number">8001</span> <span class="number">127.0</span>.0.1:<span class="number">8002</span> <span class="number">127.0</span>.0.1:<span class="number">8003</span> <span class="number">127.0</span>.0.1:<span class="number">8004</span> <span class="number">127.0</span>.0.1:<span class="number">8005</span> <span class="number">127.0</span>.0.1:<span class="number">8006</span></span><br><span class="line"><span class="comment">// 成功配置信息</span></span><br><span class="line">&gt;&gt;&gt; <span class="function">Performing Cluster <span class="title">Check</span> <span class="params">(using node <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8001</span>)</span></span></span><br><span class="line"><span class="function">M: a8fa9d463a15a5ccb373486409305f5256b2fe0c 127.0.0.1:8001</span></span><br><span class="line"><span class="function">   slots:[0-5460] <span class="params">(<span class="number">5461</span> slots)</span> master</span></span><br><span class="line"><span class="function">   1 additional <span class="title">replica</span><span class="params">(s)</span></span></span><br><span class="line"><span class="function">M: 11ba9f200e7f329df31d2eda0091385a98a5686d 127.0.0.1:8002</span></span><br><span class="line"><span class="function">   slots:[5461-10922] <span class="params">(<span class="number">5462</span> slots)</span> master</span></span><br><span class="line"><span class="function">   1 additional <span class="title">replica</span><span class="params">(s)</span></span></span><br><span class="line"><span class="function">S: 7cd6975e6296a1d5d4bcdea32a4622e4680975b0 127.0.0.1:8005</span></span><br><span class="line"><span class="function">   slots: <span class="params">(<span class="number">0</span> slots)</span> slave</span></span><br><span class="line"><span class="function">   replicates 11ba9f200e7f329df31d2eda0091385a98a5686d</span></span><br><span class="line"><span class="function">M: 5ed4654c5ea47c965930df7700374780450f33e4 127.0.0.1:8003</span></span><br><span class="line"><span class="function">   slots:[10923-16383] <span class="params">(<span class="number">5461</span> slots)</span> master</span></span><br><span class="line"><span class="function">   1 additional <span class="title">replica</span><span class="params">(s)</span></span></span><br><span class="line"><span class="function">S: 875204f61ecf81f12d11e1d5884f7bce51165d53 127.0.0.1:8006</span></span><br><span class="line"><span class="function">   slots: <span class="params">(<span class="number">0</span> slots)</span> slave</span></span><br><span class="line"><span class="function">   replicates 5ed4654c5ea47c965930df7700374780450f33e4</span></span><br><span class="line"><span class="function">S: ba204ce87c14334bdc06629320eda3eddc40cd78 127.0.0.1:8004</span></span><br><span class="line"><span class="function">   slots: <span class="params">(<span class="number">0</span> slots)</span> slave</span></span><br><span class="line"><span class="function">   replicates a8fa9d463a15a5ccb373486409305f5256b2fe0c</span></span><br><span class="line"><span class="function">[OK] All nodes agree about slots configuration.</span></span><br><span class="line"><span class="function">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="function">&gt;&gt;&gt; Check slots coverage...</span></span><br><span class="line"><span class="function">[OK] All 16384 slots covered.</span></span><br></pre></td></tr></table></figure><p><strong>查看集群信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入一台redis客户端:src/redis-cli -a gy -c -h 127.0.0.1 -p 8001</span></span><br><span class="line"><span class="number">11</span>ba9f200e7f329df31d2eda0091385a98a5686d <span class="number">127.0</span>.0.1:<span class="number">8002</span>@<span class="number">18002</span> master - <span class="number">0</span> <span class="number">1609571581446</span> <span class="number">2</span> connected <span class="number">5461</span>-<span class="number">10922</span></span><br><span class="line">a8fa9d463a15a5ccb373486409305f5256b2fe0c <span class="number">127.0</span>.0.1:<span class="number">8001</span>@<span class="number">18001</span> myself,master - <span class="number">0</span> <span class="number">1609571579000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="number">7</span>cd6975e6296a1d5d4bcdea32a4622e4680975b0 <span class="number">127.0</span>.0.1:<span class="number">8005</span>@<span class="number">18005</span> slave <span class="number">11</span>ba9f200e7f329df31d2eda0091385a98a5686d <span class="number">0</span> <span class="number">1609571580540</span> <span class="number">2</span> connected</span><br><span class="line"><span class="number">5</span>ed4654c5ea47c965930df7700374780450f33e4 <span class="number">127.0</span>.0.1:<span class="number">8003</span>@<span class="number">18003</span> master - <span class="number">0</span> <span class="number">1609571580000</span> <span class="number">3</span> connected <span class="number">10923</span>-<span class="number">16383</span></span><br><span class="line"><span class="number">875204f</span>61ecf81f12d11e1d5884f7bce51165d53 <span class="number">127.0</span>.0.1:<span class="number">8006</span>@<span class="number">18006</span> slave <span class="number">5</span>ed4654c5ea47c965930df7700374780450f33e4 <span class="number">0</span> <span class="number">1609571581000</span> <span class="number">3</span> connected</span><br><span class="line">ba204ce87c14334bdc06629320eda3eddc40cd78 <span class="number">127.0</span>.0.1:<span class="number">8004</span>@<span class="number">18004</span> slave a8fa9d463a15a5ccb373486409305f5256b2fe0c <span class="number">0</span> <span class="number">1609571581546</span> <span class="number">1</span> connected</span><br></pre></td></tr></table></figure><p><strong>关闭集群</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭需要逐个进行关闭，使用命令</span></span><br><span class="line">src/redis-cli -a gy -c -h <span class="number">127.0</span>.0.1 -p <span class="number">800</span>* shutdown</span><br></pre></td></tr></table></figure><h2 id="Redis集群原理分析"><a href="#Redis集群原理分析" class="headerlink" title="Redis集群原理分析"></a>Redis集群原理分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.RedisCluster将所有数据划分为<span class="number">16384</span>个slots（槽位）,每个节点负责其中一部分槽位.槽位的信息存储于每个节点中.</span><br><span class="line"><span class="number">2</span>.当Redis Cluster的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地.</span><br><span class="line"><span class="number">3</span>.这样当客户端要查找某个key时,可以直接定位到目标节点.同时因为槽位的信息可能会存在客户端与服务器不一致的情况,还需要纠正机制来实现槽位信息的校验调整.</span><br></pre></td></tr></table></figure><p><strong>槽位定位算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cluster默认会对key值使用<span class="string">'crc16'</span>算法进行hash得到一个整数值，然后用这个整数值对<span class="number">16384</span>进行取模来得到具体槽位.</span><br><span class="line">HASH_SLOT = CRC16(key) mod <span class="number">16384</span></span><br></pre></td></tr></table></figure><p><strong>跳转重定位</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.当客户端向一个错误的节点发出了指令,该节点会发现指令的key所在的槽位并不归自己管理,这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址,告诉客户端去连这个节点去获取数据。</span><br><span class="line"><span class="number">2</span>.客户端收到指令后除了跳转到正确的节点上去操作,还会同步更新纠正本地的槽位映射表缓存，后续所有key将使用新的槽位映射表。</span><br></pre></td></tr></table></figure><p><strong>Redis集群节点间的通信机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis cluster节点间采取gossip协议进行通信</span><br></pre></td></tr></table></figure><p><strong>网络抖动</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：</span></span><br><span class="line">  现实情况下网络可能发生抖动,突然之间部分连接不可访问,然后很快又恢复正常.这种网络抖动可能导致主从频繁切换,从而导致数据的重新复制.</span><br><span class="line"><span class="comment">// 解决：</span></span><br><span class="line">  Redis Cluster 提供了一种选项cluster-node-timeout,表示当某个节点持续timeout的时间失联时，才认定该节点故障，需要进行主从切换.</span><br></pre></td></tr></table></figure><p><strong>Redis集群选举原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简述</span></span><br><span class="line">当slave发现自己的master变为FAIL状态时,便尝试进行Failover(故障转移),期望成为新的matser.由于挂掉的master可能存在多个slave,所以存在多个slave竞争成为matser节点的过程.</span><br><span class="line"><span class="comment">// 大致流程</span></span><br><span class="line"><span class="number">1</span>.slave发现自己的master变为FAIL状态</span><br><span class="line"><span class="number">2</span>.将自己记录的集群currentEpoch加<span class="number">1</span>,并广播FAILOVER_AUTH_REQUEST 信息</span><br><span class="line"><span class="number">3</span>.其他节点收到该信息,只有master响应,判断请求者的合法性,并发送送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack.</span><br><span class="line"><span class="number">4</span>.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK</span><br><span class="line"><span class="number">5</span>.slave收到超过半数matser的Ack后就变成新的master -- <span class="string">'所以集群的节点需要至少3个,如果只有两个,一个挂了就不能选举成功'</span></span><br><span class="line"><span class="number">6</span>.slave广播Pong消息通知其他集群节点，它是新的matser了.</span><br><span class="line"><span class="comment">// 补充说明</span></span><br><span class="line">从节点并不是在主节点一进入FAIL状态就马上尝试发起选举,而是有一定的延迟,一定的延迟确保我们等待FAIl状态在集群中传播,slave如果立即尝试选举,其他的matser可能还没有意识到FAIL状态，可能会拒绝投票.</span><br><span class="line">延迟计算公式：</span><br><span class="line">DELAY = <span class="number">500</span>ms + random(<span class="number">0</span> ~ <span class="number">500</span>ms) + SLAVE_RANK * <span class="number">1000</span>ms</span><br><span class="line"><span class="comment">// SLAVE_RANK说明</span></span><br><span class="line">SLAVE_RANK表示slave已经从matser复制数据的总量的排名.RANk越小代表已复制的数据越新,理论上持有最新数据的slave会最先发起选举.</span><br></pre></td></tr></table></figure><p><strong>推荐节点数为奇数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">奇数个master节点可以在满足选举该条件的基础上节省一个节点.</span><br><span class="line">例如：<span class="number">3</span>个节点和<span class="number">4</span>个节点</span><br><span class="line">挂了<span class="number">1</span>个节点，都能选举新节点.</span><br><span class="line">挂了两个<span class="number">2</span>个，就都没法选举了.</span><br><span class="line">所以奇数的master节点更多的是从<span class="string">'节省机器资源角度出发说的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis之主从架构</title>
    <link href="http://yoursite.com/2020/12/24/Redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/12/24/Redis之主从架构/</id>
    <published>2020-12-24T01:54:55.000Z</published>
    <updated>2021-01-07T05:53:53.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在实际生产开发环境中,我们企业不会只部署一台Redis服务器，一方面是避免Redis单点故障,还有就是构建读写分离架构，满足读多写少的应用场景，减少Redis的服务器压力.所以来分析下Redis的主从架构.</p><h1 id="Redis主从架构"><a href="#Redis主从架构" class="headerlink" title="Redis主从架构"></a>Redis主从架构</h1><p><img src="https://github.com/geyou1995/picture/blob/master/redis-07.png?raw=true" alt=""></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.复制一份redis.conf文件</span><br><span class="line"><span class="number">2</span>.将相关配置修改为如下值：</span><br><span class="line">port <span class="number">6380</span></span><br><span class="line">pidfile /var/run/redis_6380.pid # 把pid进程号写入pidfile配置的文件</span><br><span class="line">  logfile "6380.log" # 日志文件</span><br><span class="line">dir /usr/local/redis‐5.0.3/data/6380 # 指定数据存放目录</span><br><span class="line"><span class="number">3</span>.配置主从复制</span><br><span class="line">replicaof 127.0.0.1 6379 # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span><br><span class="line">replica-read-only yes # 配置从节点只读</span><br><span class="line"><span class="number">4</span>.启动从节点</span><br><span class="line">  redis‐server redis.conf</span><br><span class="line"><span class="number">5</span>.连接从节点</span><br><span class="line">  redis‐cli ‐p <span class="number">6380</span></span><br><span class="line"><span class="number">6</span>.测试在<span class="number">6379</span>实例上写数据，查看<span class="number">6380</span>是否同步过来</span><br><span class="line"><span class="number">7</span>.可以继续配置<span class="number">6381</span>端口的从节点</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照上述，启动了6379与6380两台，6379为master,6380是slave</span></span><br><span class="line"><span class="comment">// 先启动好6379,然后设置一些值.当启动好6380后发现，6380中已有6379的数据</span></span><br><span class="line"><span class="comment">// 之后往6379里继续写入数据，6380这里也能接收到.</span></span><br></pre></td></tr></table></figure><h2 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h2><p><strong>全量复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要流程</span></span><br><span class="line"><span class="number">1</span>.当slave连接上Master，它都会发送一个PSYNC命令给matser请求复制数据.</span><br><span class="line"><span class="number">2</span>.master收到PSYNC命令后,会在后台进行数据持久化通过bgsave生成最新的rdb快照文件,持久化期间,会有新的数据写进来，master会把这些修改数据的请求缓存在内存里（repl buffer）。当持久化完毕后，matser会把rdb文件发送给slave.</span><br><span class="line"><span class="number">3</span>.slave会把接收到的数据持久化成rdb然后加载到内存.</span><br><span class="line"><span class="number">4</span>.master再将之前缓存在内存中的命令发送给slave</span><br><span class="line"><span class="comment">// 注：</span></span><br><span class="line">当master与slave之间的连接由于某些原因断开,slave能够自动重连mater，如果master收到了多个slave并发请求</span><br><span class="line">master只会进行一次持久化，然后把一份持久化数据发送给多个并发连接的slave</span><br></pre></td></tr></table></figure><p><img src="https://github.com/geyou1995/picture/blob/master/redis-08.png?raw=true" alt=""></p><p><strong>部分复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要流程</span></span><br><span class="line">当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，redis改用可以支持部分数据复制的命令PSYNC去master同步数据，slave与master能够在网络连接断开重连后只进行部分数据复制(断点续传).</span><br><span class="line"><span class="number">1</span>.master会在自己内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据.</span><br><span class="line"><span class="number">2</span>.master和它所有的slave都维护了复制的数据下标的offset和master，当网络断开后，slave会请求master继续完成未完成的复制,从所记录的数据下标开始.</span><br><span class="line"><span class="number">3</span>.但是如果断开链接的时间太长了，在master的缓存区里已经找不到下标了，那就会走全量复制了.</span><br></pre></td></tr></table></figure><p><img src="https://github.com/geyou1995/picture/blob/master/redis-09.png?raw=true" alt=""></p><p><strong>主从复制风暴</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果master有很多的节点，多个节点同时复制主节点可能导致主节点压力过大</span></span><br><span class="line"><span class="comment">// 缓解主从复制，可以使用如下结构：让部分从节点与从节点（和主节点同步的）同步数据.</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/geyou1995/picture/blob/master/redis-10.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis之持久化</title>
    <link href="http://yoursite.com/2020/12/21/Redis%E4%B9%8B%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2020/12/21/Redis之持久化/</id>
    <published>2020-12-21T11:32:55.000Z</published>
    <updated>2020-12-21T13:32:57.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本章来了解下Redis的持久化，虽然Redis是基于内存操作的，但是防止机器宕机，所有请求打到数据库，所以需要将Redis数据持久化.</p><h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><p>在默认情况下,Redis将内存数据库快照保存在名字为dump.rdb的二进制文件中.可以对Redis进行设置,比如”N秒内数据集有M个改动”满足这个条件就自动保存一次数据集.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RDB文件</span></span><br><span class="line">~vim dump.rdb :</span><br><span class="line">REDIS0009ú      redis-ver^K255.255.255ú</span><br><span class="line">redis-bitsÀ@ú^EctimeÂ;ºÝ_ú^Hused-memÂ`^X^P^@ú^Laof-preambleÀ^@ÿÿÕR`^QËëá</span><br><span class="line"><span class="comment">// 可以看到是一堆二进制乱码,可以简单理解，恢复的时候直接把数据拉到内存，速度非常快.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behavior will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all "save" lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save ""</span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span>  --<span class="number">900</span>秒内有<span class="number">1</span>次操作，就保存一次rdb</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> --<span class="number">300</span>秒内有<span class="number">10</span>次操作，就保存一次rdb</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> --<span class="number">60</span>秒内有<span class="number">10000</span>次操作，就保存一次rdb</span><br></pre></td></tr></table></figure><p>出了配置上述自动保存策略,还可以手动进行rdb文件的保存.客户端执行save或bgsave可以生成dump.rdb文件，每次命令执行都会讲redis内存快照到一个新的rdb文件里，并覆盖原来的rdb快照文件.</p><p><img src="https://github.com/geyou1995/picture/blob/master/redis-04.png?raw=true" alt=""></p><h1 id="AOF重写-append-only-file"><a href="#AOF重写-append-only-file" class="headerlink" title="AOF重写(append-only file)"></a>AOF重写(append-only file)</h1><p>RDB快照不是非常耐久,如果redis因为一些原因宕机了,那么服务器将丢失最近写入并且没有被保存到快照中的那些数据.所以引入另一种AOF持久化方式:将<strong>修改</strong>的每一条指令记录进appendonly.aof文件中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改配置文件打开AOF功能</span></span><br><span class="line"># appendonly yes</span><br><span class="line"># appendfsync always -- 每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全</span><br><span class="line"># appendfsync everysec -- 每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。(默认推荐)</span><br><span class="line"># appendfsync no -- 从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择</span><br><span class="line"><span class="comment">// 重启redis服务器</span></span><br><span class="line">可以看到appendonly.aof</span><br><span class="line"><span class="comment">//进入客户端，执行几条命令，再打开appendonly.aof查看内容</span></span><br><span class="line">*<span class="number">2</span>  </span><br><span class="line">$<span class="number">6</span></span><br><span class="line">SELECT</span><br><span class="line">$<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">*<span class="number">3</span> -- *代表命令开始,<span class="number">3</span>代表<span class="number">3</span>个参数：set geyou111 <span class="number">888</span></span><br><span class="line">$<span class="number">3</span> -- <span class="string">'set'</span> 长度为<span class="number">3</span></span><br><span class="line">set</span><br><span class="line">$<span class="number">8</span> -- <span class="string">'geyou111'</span> 长度为<span class="number">8</span></span><br><span class="line">geyou111</span><br><span class="line">$<span class="number">3</span> -- <span class="string">'888'</span>长度为<span class="number">3</span></span><br><span class="line"><span class="number">888</span></span><br></pre></td></tr></table></figure><p>AOF也有重写的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如执行5次</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; incr readcount</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; incr readcount</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; incr readcount</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; incr readcount</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; incr readcount</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="comment">// 看aof文件里的内容,合成一条语句了</span></span><br><span class="line">  *<span class="number">3</span> </span><br><span class="line">  $<span class="number">3</span> </span><br><span class="line">  SET </span><br><span class="line">  $<span class="number">2</span> </span><br><span class="line">  readcount </span><br><span class="line">  $<span class="number">1</span> </span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下两个配置可以控制AOF自动重写频率</span></span><br><span class="line"># auto‐aof‐rewrite‐min‐size 64mb //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就 很快，重写的意义不大 </span><br><span class="line"># auto‐aof‐rewrite‐percentage 100 //aof文件自上一次重写后文件大小增长了100%则再次触发重写</span><br><span class="line"><span class="comment">// 还可以手动重写</span></span><br><span class="line"> 客户端执行bgrewriteaof</span><br></pre></td></tr></table></figure><h1 id="RDB与AOF比较"><a href="#RDB与AOF比较" class="headerlink" title="RDB与AOF比较"></a>RDB与AOF比较</h1><p><img src="https://github.com/geyou1995/picture/blob/master/redis-06.png?raw=true" alt=""></p><h1 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h1><p>由于RDB方式容易丢数据，而AOF方式恢复数据比较慢。所以在Redis4.0之后提供了混合持久化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="line"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="line"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="line">#</span><br><span class="line">#   [RDB file][AOF tail]</span><br><span class="line">#</span><br><span class="line"># When loading, Redis recognizes that the AOF file starts with the "REDIS"</span><br><span class="line"># string and loads the prefixed RDB file, then continues loading the AOF</span><br><span class="line"># tail.</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p><img src="https://github.com/geyou1995/picture/blob/master/redis-05.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理是基于AOF的方式，必须先开启aof</span></span><br><span class="line">在AOF重写的时候，先将内存里的数据快照处理,也就是将原先RDB文件里的内容写到AOF里，这之后增量的方式还是按照AOF的方式将命令写入.</span><br><span class="line">这样宕机的话，大部分数据可以按照RDB的方式恢复，速度很快.剩余的一部分数据按照AOF执行原先的命令恢复.</span><br><span class="line">这样既兼顾了数据恢复速度也保证了数据的完整性.</span><br></pre></td></tr></table></figure><h1 id="Redis数据备份策略"><a href="#Redis数据备份策略" class="headerlink" title="Redis数据备份策略"></a>Redis数据备份策略</h1><p>1.写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48 小时的备份<br>2.每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份<br>3.每次copy备份的时候，都把太旧的备份给删了<br>4.每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis之五种数据结构</title>
    <link href="http://yoursite.com/2020/12/19/Redis%E4%B9%8B%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/12/19/Redis之五种数据结构/</id>
    <published>2020-12-19T06:37:55.000Z</published>
    <updated>2020-12-20T07:40:58.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载地址</span></span><br><span class="line">http:<span class="comment">//redis.io/download</span></span><br><span class="line"><span class="comment">// 启动并指定配置文件</span></span><br><span class="line">src/redis‐server redis.conf</span><br><span class="line"><span class="comment">// 验证是否启动成功</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="comment">// 进入redis客户端</span></span><br><span class="line">src/redis-cli</span><br><span class="line"><span class="comment">// 退出客户端</span></span><br><span class="line">quit</span><br><span class="line"><span class="comment">// 退出redis服务</span></span><br><span class="line">src/redis-cli shutdown 或者 kill 进程号</span><br></pre></td></tr></table></figure><h1 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h1><p><img src="https://github.com/geyou1995/picture/blob/master/redis-01.jpeg?raw=true" alt=""></p><h2 id="String结构"><a href="#String结构" class="headerlink" title="String结构"></a>String结构</h2><p>String结构是我们平常运用的最多的结构了.<br><strong>Key-String, value-String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用场景</span></span><br><span class="line"><span class="number">1</span>.单值缓存</span><br><span class="line">SET key value</span><br><span class="line">GET key</span><br><span class="line">  </span><br><span class="line"><span class="number">2</span>.对象缓存</span><br><span class="line"><span class="function">SET key <span class="title">value</span><span class="params">(json格式数据)</span></span></span><br><span class="line"><span class="function">GET key</span></span><br><span class="line"><span class="function">这种情况需要注意Big key（大key的情况）</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">3.分布式锁</span></span><br><span class="line"><span class="function">SETNX key <span class="keyword">true</span></span></span><br><span class="line"><span class="function">...执行业务操作</span></span><br><span class="line"><span class="function">DEL key</span></span><br><span class="line"><span class="function">SETNX key <span class="keyword">true</span> ex 10 <span class="title">nx</span> <span class="params">(防止死锁)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4.计数器</span></span><br><span class="line"><span class="function">比如文章点击率，key代表特定的文章唯一标识.比如key </span>= article:readcount:&#123;文章id&#125;</span><br><span class="line">INCR key -- 点击加<span class="number">1</span></span><br><span class="line">GET key -- 获取总数</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.Web集群session共享</span><br><span class="line">spring session + redis实现session共享</span><br><span class="line">  </span><br><span class="line"><span class="number">6</span>.分布式系统全局序列号</span><br><span class="line">INCRBY orderId <span class="number">1000</span> -- redis批量生成序列号提升性能</span><br></pre></td></tr></table></figure><h2 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h2><p>Key-String,value-(field-value) –外层key，内存key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用场景</span></span><br><span class="line"><span class="number">1</span>.对象缓存</span><br><span class="line">HMSET user &#123;userid&#125;:name zhuge &#123;userid&#125;:balance <span class="number">1888</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.电商购物车</span><br><span class="line">以用户id为key,商品id为field,商品数量为value.</span><br><span class="line">例如购物车操作：</span><br><span class="line">a.添加商品-&gt;hset cart:userid-<span class="number">1001</span> goods-<span class="number">10088</span> <span class="number">1</span></span><br><span class="line">b.增加数量-hincrby cart:userid-<span class="number">1001</span> goods-<span class="number">10088</span> <span class="number">1</span></span><br><span class="line">c.商品总数-&gt;hlen cart:userid-<span class="number">1001</span></span><br><span class="line">d.删除商品-&gt;hdel cart:userid-<span class="number">1001</span> goods-<span class="number">10088</span></span><br><span class="line">e.获取购物车所有商品-&gt;hgetall cart:userid-<span class="number">1001</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/geyou1995/picture/blob/master/redis-02.jpeg?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash结构优缺点</span></span><br><span class="line">优点：</span><br><span class="line"><span class="number">1</span>.同类数据归类整合存储，方便数据管理</span><br><span class="line"><span class="number">2</span>.相比String操作消耗内存与cpu更小</span><br><span class="line"><span class="number">3</span>.相比string存储更节省空间</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>.过期功能 不能使用在field上，只能用在外层key上</span><br><span class="line"><span class="number">2</span>.Redis集群架构下不适合大规模使用</span><br></pre></td></tr></table></figure><h2 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h2><p><img src="https://github.com/geyou1995/picture/blob/master/redis-03.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用数据结构</span></span><br><span class="line">Stack(栈) = LPUSH + LPOP --先进后出</span><br><span class="line">Queue(队列) = LPUSH + RPOP --先进先出</span><br><span class="line"><span class="function">Blocking <span class="title">MQ</span><span class="params">(阻塞队列)</span> </span>= LPUSH + BRPOP</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用场景</span></span><br><span class="line">微博和微信公众号消息流</span><br><span class="line">例如:我关注了MacTalk,备胎说车等大V</span><br><span class="line">a.MacTalk发微博，消息id为<span class="number">10018</span> -- LPUSH msg:&#123;my-id&#125; <span class="number">10018</span></span><br><span class="line">b.备胎说车发微博，消息id为<span class="number">10086</span> -- LPUSH msg:&#123;my-id&#125; <span class="number">10086</span></span><br><span class="line">c.查看最新消息（按照时间顺序） -- LRANGE msg:&#123;my-id&#125; <span class="number">0</span> <span class="number">4</span></span><br><span class="line">这里可能有一些策略：</span><br><span class="line">  <span class="number">1</span>.每当大V发了微博,就给关注了他的粉丝推送消息.(优化可以分批发，先给在线的发送，再依次给未在线的发送)</span><br><span class="line"><span class="number">2</span>.大V发的微博，就统一放到一个队列去，粉丝上线后去这个队列自己拉取消息.(这种方式，如果关注了很多大V，那么已上线就需要拉取很多大消息，还要排序,也会麻烦.)</span><br></pre></td></tr></table></figure><h2 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用场景</span></span><br><span class="line"><span class="number">1</span>.微信小程序中奖</span><br><span class="line">a.点击参与抽奖加入集合</span><br><span class="line">SADD key &#123;userid&#125;</span><br><span class="line">b.查看参与抽奖所有用户</span><br><span class="line">SMEMBERS key</span><br><span class="line">c.抽取count名中奖者</span><br><span class="line">SRANDMEMBER key [count] --不从集合删除筛选过的元素</span><br><span class="line">SPOP key [count] -- 从集合中删除筛选过的元素</span><br><span class="line">  </span><br><span class="line"><span class="number">2</span>.微信微博点赞，收藏，标签</span><br><span class="line">a.点赞 - SADD like:&#123;消息id&#125; &#123;userId&#125;</span><br><span class="line">b.取消点赞 - SREM like:&#123;消息id&#125; &#123;userId&#125;</span><br><span class="line">c.检查用户是否点过赞 - SISMEMBER like:&#123;消息id&#125; &#123;userId&#125;</span><br><span class="line">d.获取点赞的用户列表 - SMEMBERS like:&#123;消息id&#125;</span><br><span class="line">e.获取点赞用户数 - SCADD like:&#123;消息id&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.集合操作实现微博微信<span class="string">'关注模型'</span></span><br><span class="line">set1&#123;a,b,c&#125;; set2&#123;b,c,d&#125;; set3&#123;c,d,e&#125;</span><br><span class="line">SINTER set1 set2 set3 -&gt;&#123;c&#125; --交集</span><br><span class="line">SUNION set1 set2 set3 -&gt;&#123;a,b,c,d,e&#125;--并集</span><br><span class="line">SDIFF  set1 set2 set3 -&gt;&#123;a&#125; -- 差集（以第一个集合为准）</span><br><span class="line">a.A关注的人:&#123;B,C&#125;</span><br><span class="line">b.B关注的人:&#123;A,C,D,E&#125;</span><br><span class="line">c.C关注的人：&#123;D,E,F,G&#125;</span><br><span class="line">则：</span><br><span class="line">- A和B共同关注的人：</span><br><span class="line">SINTER setA setB -&gt;&#123;C&#125;</span><br><span class="line">- A关注的人也关注：</span><br><span class="line">SISMEMBER Bset E</span><br><span class="line">SISMEMBER Cset E</span><br><span class="line">- A可能认识的人：</span><br><span class="line">SDIFF Bset Cset-&gt;&#123;A,E,F,G&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.集合操作实现电商商品筛选</span><br></pre></td></tr></table></figure><h2 id="ZSet结构"><a href="#ZSet结构" class="headerlink" title="ZSet结构"></a>ZSet结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用场景</span></span><br><span class="line">Zes集合实现排行榜</span><br><span class="line">a.点击新闻</span><br><span class="line">ZINCRBY hotNews:<span class="number">20190819</span> <span class="number">1</span> 守护香港</span><br><span class="line">b.展示当日排行前十</span><br><span class="line">ZREVRANGE hotNews:<span class="number">20190819</span> <span class="number">0</span> <span class="number">9</span> WITHSCORES</span><br><span class="line">c.七日搜索榜单计算</span><br><span class="line">ZUNIONSTORE hotnews:<span class="number">20190813</span>-<span class="number">20190819</span> <span class="number">7</span></span><br><span class="line">d.展示七日排行前十</span><br><span class="line">ZREVRANGE hotNews:<span class="number">20190813</span>-<span class="number">20190819</span>  <span class="number">0</span>  <span class="number">9</span>  WITHSCORES</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ</title>
    <link href="http://yoursite.com/2020/12/14/RocketMQ/"/>
    <id>http://yoursite.com/2020/12/14/RocketMQ/</id>
    <published>2020-12-14T06:51:55.000Z</published>
    <updated>2020-12-20T06:12:20.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>消息生产者（Producer）</strong><br>负责生产消息,一般由业务系统负责生产消息.一个消息生产者会把业务应用系统里产生的消息发送到Broker服务器.RocketMQ提供多种发送方式：同步发送、异步发送、顺序发送、单向发送（不需要Broker返回确认消息）.</p><p><strong>消息消费者（Consumer）</strong><br>负责消费消息,一般是后台系统负责异步消费.一个消息消费者会从Broker服务器拉去消息、并将其提供给应用程序.有两种消费形式：<br>        拉取式消费（应用主动调用Consumer从Broker拉取消息）<br>        推动式消费(Broker收到消息主动推送给消费端).<br>RocketMQ支持两种消费模式：<br>        集群消费（相同Consumer Group的每个Consumer实例平均分摊消息）<br>        广播消费（相同Consumer Group的每个Consumer实例都接收全量的消息）</p><p><strong>主题（Topic）</strong><br>表示一类消息的集合,每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位. 同一个Topic下的数据,会分片保存到不同的Broker上,而每一个分片单位就MessageQueue,MessageQueue是生产者发送消息与消费者消费消息的最小单位.</p><p><strong>代理服务器（Broker Server）</strong><br>消息中转角色，负责存储消息、转发消息.Broker Server是RocketMQ真正的业务核心，包含了多个重要的子模块.<br>    Remoting Module:整个Broker的实体,负责处理来自clients端端请求.<br>    Client Manager:负责管理客户端（Producer/Consumer）和维护Consumer端Topic订阅消息<br>    Store Service：提供方便简单的ApI接口处理消息存储到物理硬盘和查询功能.<br>    HA Service:高可用服务,提供Master Broker和Slave Broker之间的数据同步功能.<br>    Index Service:根据特定的Message Key对投递到Broker的消息进行索引服务，以提供消息的快速查询.</p><p><strong>名字服务（Name Server）</strong><br>名称服务充当路由消息的提供者.Broker Server会在启动时向所有的Name Server注册自己的服务信息.并且后续通过心跳请求的方式保证这个服务信息的实时性.生产者或消费者能够通过名字服务查找各个主题相应的Broker IP列表. 多个Name Server实例组成集群，相互独立，没有信息交换.</p><p><strong>消息（Message）</strong><br>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题Topic。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key.系统通过Message ID和Key查询消息的功能。</p><h1 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h1><p><strong>什么时候存储消息</strong><br>分布式队列因为有高可靠性的要求,所以数据需要进行持久化存储.<br>1.MQ收到一条消息后,需要向生产者返回一个ACK响应,并将消息存储起来.<br>2.MQ Push一条消息给消费者后,等待消费者的ACK响应,需要将消息标记为已消费.如果没有标记为已消费，MQ会不断尝试往消费者推送消息.<br>3.MQ需要定期删除一些过期的消息,这样才能保证服务一直可用.</p><p><strong>消息存储介质</strong><br>RocketMQ采用直接用磁盘文件来保存消息.磁盘随机写速度大概100KB/s,磁盘顺序写可以达到600MB/s,性能差6000倍.RocketMQ采用的顺序写,保证了消息存储的速度.</p><p><strong>消息存储结构</strong></p><p><img src="https://github.com/geyou1995/picture/blob/master/mq-1.png?raw=true" alt=""></p><p><strong>刷盘机制</strong><br>RocketMQ需要将消息存储到磁盘上,这样才能保证断电后消息不回丢失.同时这样才能让存储到消息超过内存限制.消息在写入磁盘时,有两种写磁盘的方式：<br><img src="https://github.com/geyou1995/picture/blob/master/mq-2.png?raw=true" alt=""></p><p>同步刷盘:<br>    在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程    刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p><p>异步刷盘:<br>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大;当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p><p>注配置方式：<br>刷盘方式是通过Broker配置文件里的flflushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</p><p><strong>主从复制</strong><br>同步复制：<br>同步复制是等Master和Slave都写入消息成功后才反馈给客户端写入成功的状态.在同步复制下，如果Master节点故障，Slave上有全部的数据备份，这样容易恢复数据。但是同步复制会增大数据写入的延迟，降低系统的吞量。</p><p>异步复制：<br>异步复制是只要master写入消息成功，就反馈给客户端写入成功的状态。然后再异步的将消息复制给Slave节点.在异步复制下，系统拥有较低的延迟和较高的吞吐量。但是如果master节点故障，而有些数据没有完成复制，就会造成数据丢失。</p><h1 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h1><p>对于普通的消息，当消费者消费消息失败后，你可以通过设置返回状态达到消息重试的结果.<br><strong>如何让消息重试</strong><br>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置。可以有三种配置方式：返回Action.ReconsumeLater(推荐)、返回null、抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//处理消息 </span></span><br><span class="line">    doConsumeMessage(message); </span><br><span class="line">    <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试 </span></span><br><span class="line">    <span class="keyword">return</span> Action.ReconsumeLater; </span><br><span class="line">    <span class="comment">//方式2：返回 null，消息将重试 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">//方式3：直接抛出异常， 消息将重试 </span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Consumer Message exceotion"</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><p>也可以不重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doConsumeMessage(message); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; </span><br><span class="line">      <span class="comment">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">      <span class="keyword">return</span> Action.CommitMessage; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息处理正常，直接返回 Action.CommitMessage; </span></span><br><span class="line">    <span class="keyword">return</span> Action.CommitMessage; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><p>当一条消息消费失败，RocketMQ就会自动进行消息重试。而如果消息超过最大重试次数，RocketMQ就会认为这个消息有问题。但是此时，RocketMQ不会立刻将这个有问题的消息丢弃，而会将其发送到这个消费者组对应的一种特殊队列：死信队列. 通常进入死信队列，意味着消息在消费处理的过程中出现比较严重的错误，无法自行恢复需要人工查看.</p><h1 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h1><p>消息队列 RocketMQ 的消息有可能会出现重复,例如发消息是重复、投递时重复等,需要在业务消费端自行保证幂等行.</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>MQ基本介绍</title>
    <link href="http://yoursite.com/2020/12/09/MQ%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2020/12/09/MQ基本介绍/</id>
    <published>2020-12-09T07:09:55.000Z</published>
    <updated>2020-12-09T08:03:21.465Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是MQ？"><a href="#什么是MQ？" class="headerlink" title="什么是MQ？"></a>什么是MQ？</h1><p>MQ全称MessageQueue,即消息队列。队列是一种FIFO先进先出的数据结构。消息由生产者发送到MQ进行排列，然后按照原来的顺序交由消息的消费者进行处理。典型的MQ比如QQ和微信.</p><h1 id="MQ的作用"><a href="#MQ的作用" class="headerlink" title="MQ的作用"></a>MQ的作用</h1><p>MQ的作用主要有以下三个方面：<br><strong>异步</strong><br>能够提高系统的响应速度、吞吐量.<br>例子:比如快递员送快递,如果快递员每一件货物都要送到客户家里，效率就会很低。所以有快递驿站，快递员只要把货物都送到驿站，由客户自己来驿站获取，这样效率就会非常高。</p><p><strong>解耦</strong><br>1.服务之间进行解耦，可以减少服务之间的影响.提高系统整体的稳定性以及可扩展性.<br>2.解耦后可以实现数据分发.生产者发送一个消息后,可以由一个或者多个消费者解进行消费，并且消费者的增加或减少对生产者没有影响.<br>例子:电商例子,用户界面购买了某一商品，需要发送一个消息给支付系统、库存系统，他们各自去消费，不会影响主系统.</p><p><strong>削峰</strong><br>提高系统的稳定性.<br>例子：假设一个业务能成熟的最大流量请求是每秒2000，这时就可以使用MQ，每次只拉取1600的请求，剩下的放在broker慢慢消费就好，分批去消费，这样能保证系统的稳定性.</p><h1 id="MQ的缺点"><a href="#MQ的缺点" class="headerlink" title="MQ的缺点"></a>MQ的缺点</h1><p>MQ有它的优点，当然也有它的缺点.<br><strong>系统可用性降低</strong><br>系统引入外部的依赖增多,系统的稳定性就会变差.一旦MQ宕机,对业务会产生影响.这就需要考虑MQ的高可用.</p><p><strong>系统复杂度提高</strong><br>引入MQ后系统的复杂度会大大提高.以前服务之间可以进行同步的服务调用，引入MQ后，会变成异步调用，数据的链路就会变得更复杂.并且还会带来其他一些问题.比如：如何保证消费不会丢失？不会被重复调用？怎么保证消息的顺序性等问题。</p><p><strong>消息一致性问题</strong><br>A系统处理完业务,通过MQ发送消息给B、C系统进行后续的业务处理.如果B系统处理成功,C系统处理失败怎么办？这就是需要考虑的如何保证消息数据处理的一致性.</p><h1 id="MQ产品特点比较"><a href="#MQ产品特点比较" class="headerlink" title="MQ产品特点比较"></a>MQ产品特点比较</h1><p><img src="https://github.com/geyou1995/picture/blob/master/mq.jpeg?raw=true" alt=""></p><p>总结<br>RabbitMQ使用于小规模场景.<br>ActiveMQ老产品，几乎不用了.<br>RockectMQ,几乎全场景,阿里自主研发,送给Apache。目前有开源版和商业版，商业版部分功能优于开源版.<br>Kafka适用于日志分析,大数据采集.</p><p>由于RockectMQ功能比较完备，适用于大部分点企业，之后会专门钻研学习RockectMQ.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring之IOC源码解析</title>
    <link href="http://yoursite.com/2020/11/19/Spring%E4%B9%8BIOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/11/19/Spring之IOC源码解析/</id>
    <published>2020-11-19T07:41:58.000Z</published>
    <updated>2020-11-21T09:05:59.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上文主要概述了Spring IOC的加载流程，这片主要结合源码来分析.主要是针对注解的方式,会阐述Sping IOC涉及的核心代码代码,主要用于记录,方便之后查看能更快的回忆起来哈～</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.youga.beans"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>com.youga.beans目录下Bean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name = <span class="string">"宝马"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Car&#123;"</span> +</span><br><span class="line"><span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line"><span class="string">'&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IOC容器加载</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">    <span class="comment">// 从上下文中获取Bean对象</span></span><br><span class="line">Car car = context.getBean(<span class="string">"car"</span>, Car.class);</span><br><span class="line">System.out.println(car.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IOC容器的加载过程"><a href="#IOC容器的加载过程" class="headerlink" title="IOC容器的加载过程"></a>IOC容器的加载过程</h1><h3 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a>实例化容器</h3><p>加载上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context=<span class="keyword">new</span> AnnotationConfigApplicationContext（x.class）;</span><br></pre></td></tr></table></figure><p>AnnotationConfigApplicationContext的结构：<br><img src="https://github.com/geyou1995/picture/blob/master/ioc0.png?raw=true" alt=""></p><p>进来构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 里面就3个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line">register(componentClasses);</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来讲述</p><h4 id="this"><a href="#this" class="headerlink" title="this()"></a><strong>this()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里隐式调用父类的构造方法，初始化DefaultListableBeanFactory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个Bean读取器-&gt; 1.注册内置的BeanPostProcessor 2.注册相关的BeanDefinition</span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 初始化一个扫描器</span></span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">  <span class="comment">// 1.进来以后是一个无参构造方法,所以它会隐式的调用父类的无参构造方法，初始化DefaultListableBeanFactory</span></span><br><span class="line">  <span class="comment">// AnnotationConfigApplicationContext继承了GenericApplicationContext</span></span><br><span class="line">  <span class="comment">// 所以这里就构造了beanFactory-&gt;是DefaultListableBeanFactory</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultListableBeanFactory的结构<br><img src="https://github.com/geyou1995/picture/blob/master/ioc1.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.初始化一个Bean读取器</span></span><br><span class="line"><span class="comment">// 主要做了两件事:</span></span><br><span class="line"><span class="comment">// a.注册内置的BeanPostProcessor </span></span><br><span class="line"><span class="comment">// b.注册相关的BeanDefinition</span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 直接进入核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line">DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// a</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册spring内置的多个bean</span></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">def.setSource(source);</span><br><span class="line">      <span class="comment">// b</span></span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里总共6个内置的Bean,以下省略</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RootBeanDefinition的结构</p><p><img src="https://github.com/geyou1995/picture/blob/master/ioc2.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinition主要是用来描述bean的，里面有bean的一系列信息，例如创建bean的class,作用域、是否懒加载等</span></span><br><span class="line"><span class="comment">// registerPostProcessor就是在注册内置的Bean</span></span><br><span class="line">registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line"> <span class="comment">// 点进去</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title">registerPostProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 为BeanDefinition设置一个Role,ROLE_INFRASTRUCTURE代表是spring内部的，不是用户定义的</span></span><br><span class="line">definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">registry.registerBeanDefinition(beanName, definition);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法是关键</span></span><br><span class="line">registry.registerBeanDefinition(beanName, definition);</span><br><span class="line"><span class="comment">// 点进去,来到DefaultListableBeanFactory类看关键代码</span></span><br><span class="line"><span class="comment">// beanDefinitionMap是Map&lt;String, BeanDefinition&gt;</span></span><br><span class="line"><span class="comment">// 这里把beanName作为key, ScopedProxyMode作为value，推到map里面</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="comment">// beanDefinitionNames就是一个List&lt;String&gt;,这里就是把BeanName放到List中去</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line"><span class="comment">// 从这里可以看出springIOC的容器就是DefaultListableBeanFactory，生成的beanDefinition信息都存储在这</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 走完 </span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 看下图DefaultListableBeanFactory已经储存了内置的beanDefinition信息</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/geyou1995/picture/blob/master/ioc3.jpeg?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.初始化一个扫描器</span></span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 这个方法就是初始化scanner</span></span><br><span class="line"><span class="comment">// todo 暂时不细看...</span></span><br></pre></td></tr></table></figure><p>以上差不多就跟完了this()方法，下面来看<strong>register(componentClasses)</strong></p><h4 id="register-componentClasses"><a href="#register-componentClasses" class="headerlink" title="register(componentClasses)"></a>register(componentClasses)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的是一般是配置类,这里是对配置类的解析,xxxConfig.xml</span></span><br><span class="line">register(componentClasses);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入一下层,可以看到是通过this()方法构造好的读取器reader进行注册配置类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(componentClasses, <span class="string">"At least one component class must be specified"</span>);</span><br><span class="line"><span class="keyword">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续进入下一层,循环对配置类进行注册Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">registerBean(componentClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续进入registerBean()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">doRegisterBean(beanClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入doRegisterBean()，真正开始做事情了～</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的</span></span><br><span class="line"><span class="comment">// 这里的作用就是把传入的标记了注解的类，转为AnnotatedGenericBeanDefinition数据结构，里面有一个getmetadata方法，可以拿到类上的注解</span></span><br><span class="line">AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个Bean就不会被解析</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line"><span class="comment">// 解析Bean的作用域，如果没有设置的话，默认为单例</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">// 获取Bean的名称</span></span><br><span class="line">String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定符处理，不是特指@Qualifier注解，也有可能是Primary,或者是Lazy，或者是其他</span></span><br><span class="line"><span class="comment">// qualifiers永远都是空的，包括上面的name和instanceSupplier都一样，但是spring提供了其他方法去注册bean，就可能会传入了</span></span><br><span class="line"><span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 可以传入qualifiers数组，所以循环处理</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line"><span class="comment">// primary注解优先</span></span><br><span class="line"><span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Lazy注解</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他AnnotatedGenericBeanDefinition有个Map&lt;String,AutowireCandidateQualifier&gt;属性，直接push进去</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法用处不大，就是把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中</span></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册Bean</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="comment">// this.registry是BeanDefinitionRegistry接口，DefaultListableBeanFactory实现了它</span></span><br><span class="line"><span class="comment">// 注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册</span></span><br><span class="line"><span class="comment">// 可以看到最终又回到了那些行代码</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br></pre></td></tr></table></figure><p>走完register(componentClasses)，可以看到beanDefinitionMap多了配置类的Bean定义<br><img src="https://github.com/geyou1995/picture/blob/master/ioc4.jpeg?raw=true" alt=""></p><p>上面2个步骤主要是注册了spring内置的Bean定义以及我们自己配置类的bean定义 ,接下来我们来看最核心的方法</p><h4 id="refresh-–这个方法很深，还没有全部看完-todo"><a href="#refresh-–这个方法很深，还没有全部看完-todo" class="headerlink" title="refresh() –这个方法很深，还没有全部看完 todo"></a><strong>refresh()</strong> –这个方法很深，还没有全部看完 todo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里主要先来讲述 invokeBeanFactoryPostProcessors(beanFactory);--调用Bean工厂的后置处理器</span></span><br><span class="line"><span class="comment">// 点进来</span></span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"><span class="comment">// 继续点下去</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"><span class="comment">// 用来存放BeanFactoryPostProcessor</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 用来存放BeanDefinitionRegistryPostProcessor，扩展了BeanFactoryPostProcessor</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环传进来的beanFactoryPostProcessors，正常情况下，beanFactoryPostProcessors肯定没有数据</span></span><br><span class="line"><span class="comment">// 因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的</span></span><br><span class="line"><span class="comment">// 只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(XXX)才会有数据，所以这块正常情况不会走</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//不是的话，就装到regularPostProcessors</span></span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个临时变量，用来装载BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得实现BeanDefinitionRegistryPostProcessor接口的类的BeanName:org.springframework.context.annotatio n.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">// 并且装入数组postProcessorNames，我理解一般情况下，只会找到一个</span></span><br><span class="line"><span class="comment">// 这里又有一个坑，为什么我自己创建了一个实现BeanDefinitionRegistryPostProcessor接口的类，也打上了@Component注解，配置类也加上了@Component注解，但是这里却没有拿到</span></span><br><span class="line"><span class="comment">// 因为直到这一步，Spring还没有去扫描，扫描是在ConfigurationClassPostProcessor类中完成的，也就是下面的第一个invokeBeanDefinitionRegistryPostProcessors方法</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line"><span class="comment">// 获得ConfigurationClassPostProcessor类，并且放到currentRegistryProcessors</span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor是很重要的一个类，它实现了BeanDefinitionRegistryPostProcessor接口</span></span><br><span class="line"><span class="comment">// BeanDefinitionRegistryPostProcessor接口又实现了BeanFactoryPostProcessor接口</span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor是极其重要的类</span></span><br><span class="line"><span class="comment">// 里面执行了扫描Bean，Import，ImportResouce等各种操作</span></span><br><span class="line"><span class="comment">// 用来处理配置类（有两种情况 一种是传统意义上的配置类，一种是普通的bean）的各种逻辑</span></span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line"><span class="comment">// 把name放到processedBeans，后续会根据这个集合来判断处理器是否已经被执行过了</span></span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理排序</span></span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 合并Processors，为什么要合并，因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的</span></span><br><span class="line"><span class="comment">// 一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法</span></span><br><span class="line"><span class="comment">// 而不会执行BeanDefinitionRegistryPostProcessor父类的方法，即BeanFactoryProcessor的方法</span></span><br><span class="line"><span class="comment">// 所以这里需要把处理器放入一个集合中，后续统一执行父类的方法</span></span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 可以理解为执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line"><span class="comment">// Spring热插播的体现，像ConfigurationClassPostProcessor就相当于一个组件，Spring很多事情就是交给组件去管理，如果不想用这个组件，直接把注册组件的那一步去掉就可以</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"><span class="comment">// 因为currentRegistryProcessors是一个临时变量，所以需要清除</span></span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次根据BeanDefinitionRegistryPostProcessor获得BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口</span></span><br><span class="line"><span class="comment">// 如果没有被执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans</span></span><br><span class="line"><span class="comment">// 如果没有实现Ordered接口的话，这里不把数据加到currentRegistryProcessors，processedBeans中，后续再做处理</span></span><br><span class="line"><span class="comment">// 这里才可以获得我们定义的实现了BeanDefinitionRegistryPostProcessor的Bean</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理排序</span></span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 合并Processors</span></span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 执行我们自定义的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"><span class="comment">// 清空临时变量</span></span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，</span></span><br><span class="line"><span class="comment">// 下面的代码就是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// regularPostProcessors装载BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法</span></span><br><span class="line"><span class="comment">// 但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会 有数据</span></span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到BeanFactoryPostProcessor实现类的BeanName数组</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 循环BeanName数组</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">// 如果这个Bean被执行过了，跳过</span></span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<span class="comment">// 如果实现了PriorityOrdered接口，加入到priorityOrderedPostProcessors</span></span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<span class="comment">// 如果实现了Ordered接口，加入到orderedPostProcessorNames</span></span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName); <span class="comment">// 如果既没有实现PriorityOrdered，也没有实现Ordered。加入到nonOrderedPostProcessorNames</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 排序处理priorityOrderedPostProcessors，即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 执行priorityOrderedPostProcessors</span></span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 执行实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line"><span class="comment">// 执行既没有实现PriorityOrdered接口，也没有实现Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来看下这个方法 </span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是循环后置处理器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入postProcessor.postProcessBeanDefinitionRegistry(registry)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 直接看这个方法</span></span><br><span class="line">processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进入processConfigBeanDefinitions(registry) 这个方法很重要～</span></span><br></pre></td></tr></table></figure><p>1.获得所有的BeanName，放入candidateNames数组.<br>2.循环candidateNames数组，根据beanName获得BeanDefinition，判断此BeanDefinition是否已经被处理过了 3.判断是否是配置类，如果是的话.加入到configCandidates数组，在判断的时候，还会标记配置类属于Full配置类，还是Lite配置类，这里会引发一连串的知识盲点：<br>    3.1  当我们注册配置类的时候，可以不加@Configuration注解，直接使用@Component @ComponentScan @Import  @ImportResource等注解，Spring把这种配置类称之为Lite配置类， 如果加了@Configuration注解，就称之为Full配置类.<br>    3.2 如果我们注册了Lite配置类，我们getBean这个配置类，会发现它就是原本的那个配置类，如果我们注册了Full配置类，我们getBean这个配置类，会发现它已经不是原本那个配置类了，而是已经被cgilb代理的类了.<br>    3.3 写一个A类，其中有一个构造方法，打印出“你好”，再写一个配置类，里面有两个被@bean注解的方法，其中一个方法new了A类,并且返回A的对象，把此方法称之为getA，第二个方法又调用了getA方法，如果配置类是Lite配置类，会发现打印了两次“你好”，也就是说A类被new了两次，如果配置类是Full配置类，会发现只打印了一次“你好”，也就是说A类只被new了一次，因为这个类被cgilb代理了，方法已经被改写.</p><p>4.如果没有配置类直接返回.<br>5.处理排序<br>6.解析配置类，可能是Full配置类，也有可能是Lite配置类，这个小方法是此方法的核心<br>7.在第6步的时候，只是注册了部分Bean，像 @Import @Bean等，是没有被注册的，这里统一对这些进行注册。 下面是解析配置类的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 获得所有的BeanDefinition的Name,放入candidateNames</span></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"><span class="comment">// 循环candidateNames数组</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line"><span class="comment">// 根据名称获取对应的Bean定义</span></span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 内部有两个标记位来标记是否已经处理过了</span></span><br><span class="line"><span class="comment">// 当我们注册配置类当时候，可以不加Configuration注解,直接使用Component ComponentScan Import ImportResou rce注解，称之为Lite配置类</span></span><br><span class="line"><span class="comment">// 如果加了Configuration注解，就称为Full配置类</span></span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否为配置类，内部判断是Full配置类，还是Lite配置类，并且做上标记</span></span><br><span class="line"><span class="comment">// 满足条件就加入configCandidates</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line"><span class="comment">// 如果没有配置类就返回</span></span><br><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line"><span class="comment">// 排序处理</span></span><br><span class="line">configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line"><span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line"><span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口，所以可以进入到这个if</span></span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">sbr = (SingletonBeanRegistry) registry;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line"><span class="comment">// spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean命名方式，虽然一般没有人会这么做</span></span><br><span class="line">BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line"><span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse each @Configuration class</span></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line"><span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//解析配置类（传统意义上的配置类或者是普通bean，核心来了）</span></span><br><span class="line">parser.parse(candidates);</span><br><span class="line">parser.validate();</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直到这一步才把Import的类，@Bean @ImportRosource 转换成BeanDefinition</span></span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">candidates.clear();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看一下 parser.parse(candidates)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">          <span class="comment">// 看这个方法</span></span><br><span class="line">parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 进入该方法</span></span><br><span class="line">sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line"><span class="comment">// 获得ComponentScan注解具体的内容，ComponentScan注解除了最常用的basePackage之外，还有includeFilters，excludeFilters等</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="comment">// 如果没有打上ComponentScan，或者被@Condition条件跳过，就不再进入这个if</span></span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"><span class="comment">// 循环处理componentScans</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// componentScan就是@ComponentScan上的具体内容，sourceClass.getMetadata().getClassName()就是配置类的名称</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line"><span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">bdCand = holder.getBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="comment">// 递归调用，因为可能组件类有被@Bean标记的方法，或者组件类本身也有ComponentScan等注解</span></span><br><span class="line">parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看下这句解析</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br></pre></td></tr></table></figure><p>1.定义了一个扫描器scanner.<br>2.处理includeFilters，就是把规则添加到scanner.<br>3.处理excludeFilters，就是把规则添加到scanner.<br>4.解析basePackages，获得需要扫描哪些包.<br>5.添加一个默认的排除规则：排除自身.<br>6.执行扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">parse</span><span class="params">(AnnotationAttributes componentScan, <span class="keyword">final</span> String declaringClass)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 扫描器，还记不记在new AnnotationConfigApplicationContext的时候，会调用AnnotationConfigApplicationContext的构造方法</span></span><br><span class="line"><span class="comment">// 构造方法里面有一句 this.scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">// 当时说这个对象不重要，这里就是证明了。常规用法中，实际上执行扫描的只会是这里的scanner对象</span></span><br><span class="line">ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>.registry,</span><br><span class="line">componentScan.getBoolean(<span class="string">"useDefaultFilters"</span>), <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否重写了默认的命名规则</span></span><br><span class="line">Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line"><span class="keyword">boolean</span> useInheritedGenerator = (BeanNameGenerator.class == generatorClass);</span><br><span class="line">scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="keyword">this</span>.beanNameGenerator :</span><br><span class="line">BeanUtils.instantiateClass(generatorClass));</span><br><span class="line"></span><br><span class="line">ScopedProxyMode scopedProxyMode = componentScan.getEnum(<span class="string">"scopedProxy"</span>);</span><br><span class="line"><span class="keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(<span class="string">"scopeResolver"</span>);</span><br><span class="line">scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scanner.setResourcePattern(componentScan.getString(<span class="string">"resourcePattern"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  addIncludeFilter addExcludeFilter,最终是往List&lt;TypeFilter&gt;里面填充数据</span></span><br><span class="line"><span class="comment">// TypeFilter是一个函数式接口，函数式接口在java8的时候大放异彩，只定义了一个虚方法的接口被称为函数式接口</span></span><br><span class="line"><span class="comment">// 当调用scanner.addIncludeFilter scanner.addExcludeFilter 仅仅把定义的规则塞进去，并没有真正去执行匹配过程</span></span><br><span class="line"><span class="comment">// 处理includeFilters</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">"includeFilters"</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">scanner.addIncludeFilter(typeFilter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理excludeFilters</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">"excludeFilters"</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">scanner.addExcludeFilter(typeFilter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> lazyInit = componentScan.getBoolean(<span class="string">"lazyInit"</span>);</span><br><span class="line"><span class="keyword">if</span> (lazyInit) &#123;</span><br><span class="line">scanner.getBeanDefinitionDefaults().setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; basePackages = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">String[] basePackagesArray = componentScan.getStringArray(<span class="string">"basePackages"</span>);</span><br><span class="line"><span class="keyword">for</span> (String pkg : basePackagesArray) &#123;</span><br><span class="line">String[] tokenized = StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">Collections.addAll(basePackages, tokenized);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从下面的代码可以看出ComponentScans指定扫描目标，除了最常用的basePackages，还有两种方式</span></span><br><span class="line"><span class="comment">// 指定basePackageClasses，就是指定多个类，只要是与这几个类同级的，或者在这几个类下级的都可以被扫描到，这种方式其实是spring比较推荐的， 因为指定basePackages没有IDE的检查，容易出错，但是指定一个类，就有IDE的检查了，不容易出错，经常会用一个空的类来作为basePackageClasses</span></span><br><span class="line"><span class="comment">// 直接不指定，默认会把与配置类同级，或者在配置类下级的作为扫描目标</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">"basePackageClasses"</span>)) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把规则填充到排除规则：List&lt;TypeFilter&gt;，这里就把 注册类自身当作排除规则，真正执行匹配的时候，会把自身给排除</span></span><br><span class="line">scanner.addExcludeFilter(<span class="keyword">new</span> AbstractTypeHierarchyTraversingFilter(<span class="keyword">false</span>, <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// basePackages是一个LinkedHashSet&lt;String&gt;，这里就是把basePackages转为字符串数组的形式</span></span><br><span class="line"><span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来看scanner.doScan(StringUtils.toStringArray(basePackages));</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// 循环处理basePackages</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="comment">// 由findCandidateComponents内部可知，这里的candidate是ScannedGenericBeanDefinition</span></span><br><span class="line"><span class="comment">// 而ScannedGenericBeanDefinition是AbstractBeanDefinition和AnnotatedBeanDefinition的之类</span></span><br><span class="line"><span class="comment">// 所以下面的两个if都会进入</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 内部会设置默认值</span></span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 如果是AnnotatedBeanDefinition，还会再设置一次值</span></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring之IOC加载过程</title>
    <link href="http://yoursite.com/2020/11/17/Spring%E4%B9%8BIOC%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/11/17/Spring之IOC加载过程/</id>
    <published>2020-11-17T11:55:58.000Z</published>
    <updated>2020-11-20T03:32:12.810Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring框架的两大核心就是IOC(控制反转)和AOP（切面).本文主要来讲述IOC,注解的方式.<br>首先明白IOC就是用来<strong>解决层与层之间的耦合的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单理解</span></span><br><span class="line"><span class="comment">// 通常使用某个类需要如下创建</span></span><br><span class="line">Object A =  <span class="keyword">new</span> A();</span><br><span class="line">... <span class="comment">// 如果使用到的类特别多的时候，代码就会非常的冗余</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用IOC的方式，注解为例</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Object A;</span><br></pre></td></tr></table></figure><h1 id="IOC的加载过程"><a href="#IOC的加载过程" class="headerlink" title="IOC的加载过程"></a>IOC的加载过程</h1><p>流程图</p><p><img src="https://github.com/geyou1995/picture/blob/master/ioc-01.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">总体过程为：</span><br><span class="line">配置类xml方式或者注解方式 -&gt; 加载spring上下文（交个BeanFactory的统一信息） -&gt; 获取Bean,getBean()</span><br><span class="line"><span class="comment">// 过程，主要以注解方式为例</span></span><br><span class="line"><span class="number">1</span>.配置类，如下两种方式</span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"xxx.xml"</span>);-- xml方式</span><br><span class="line"><span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);--注解方式</span><br><span class="line"><span class="number">2</span>.先通过BeanDefintionReader读取<span class="meta">@Configuration</span>修饰的注解类，注解类上有需要扫描的类范围</span><br><span class="line"><span class="number">3</span>.再通过BeanDefintionScanner扫描需要有效的类，被注解<span class="meta">@Controller</span>、<span class="meta">@Service</span>、<span class="meta">@Component</span>等修饰的类</span><br><span class="line"><span class="number">4</span>.将这些有效类生成Beandefinition，通过BeanDefinitionRegistry将Bean定义注册到BeanDefinitionMap</span><br><span class="line"><span class="number">5</span>.BeanFactory就是从BeanDefinitionMap获取Bean的信息，然后获取/生产Bean</span><br><span class="line"><span class="number">6</span>.接着便是Bean的生命周期：实例化-&gt;属性赋值-&gt;初始化</span><br><span class="line">实例化:通过BeanDefintion里的类信息反射生成Bean，不过这时候的Bean只是个空壳.</span><br><span class="line">属性赋值：给Bean里的带有<span class="meta">@Autowired</span> <span class="meta">@Value</span>的属性赋值（这个过程可能发生循环依赖）.</span><br><span class="line">初始化：调用Bean的一些initMethode destory方法，该过程中会调用很多的Aware.</span><br><span class="line"><span class="number">7</span>.将Bean put到单例池，也就是一级缓存（key-Bean的名字，value-Bean）.</span><br><span class="line"><span class="number">8</span>.getBean就是从一级缓存中获取. getBean(<span class="string">"user"</span>) -&gt; Map.get()</span><br><span class="line"><span class="number">9</span>.在这过程中还有许多的后置处理器执行</span><br><span class="line">BeanFactorypostProcess </span><br><span class="line">BeanDefinitionRegistryPostProcess</span><br><span class="line">BeanPostProcess</span><br></pre></td></tr></table></figure><h1 id="各个对象说明"><a href="#各个对象说明" class="headerlink" title="各个对象说明"></a>各个对象说明</h1><p>BeanFactory：Spring顶层核心接口，使用了简单工厂，负责生产Bean.<br>Beandefinition：Spring顶层核心接口，Bean定义，Bean的生产方式都存储在里面<br>BeandefinitionReader：Beandefinition的读取器,主要读取配置类（@Configuration修饰的类）<br>BeanDefinitionSacnner：Beandefinition的扫描器，扫描有效的Bean定义（被@Controller、@Service、@Component等修饰的类）<br>BeanDefinitionRegistry：注册Bean定义<br>BeanFactorypostProcess：Bean工厂的后置处理器,可以用来修改Bean定义<br>BeanDefinitionRegistryPostProcess：注册Bean定义后置处理器<br>BeanPostProcess：Bean的后置处理器（实例化前后、填充属性前后、初始化前后）</p><h1 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h1><p><strong>1.描述BeanFactory</strong><br>Spring顶层核心接口，使用了简单工厂，负责生产Bean.</p><p><strong>2.BeanFactory和ApplicationContext的区别？</strong><br>ApplicationContext可以指定配置类,可以定义更多属性，有扩展节点BeanFactorypostProcess、    BeanDefinitionRegistryPostProcess<br>BeanFactory就是生产Bean</p><p><strong>3.简述SpringIOC的加载过程</strong><br>见上文IOC加载过程</p><p><strong>4.简述SpringBean的生命周期</strong><br>见上文IOC加载过程第6点</p><p><strong>5.Spring中有哪些扩展接口及调用时机</strong><br>BeanFactorypostProcess –生成Beandefition后修改Bean定义<br>BeanDefinitionRegistryPostProcess–修改注册Bean定义<br>BeanPostProcess – 修改Bean（实例化前后、填充属性前后、初始化前后）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>后端必备linuk操作命令</title>
    <link href="http://yoursite.com/2020/11/06/%E5%90%8E%E7%AB%AF%E5%BF%85%E5%A4%87linuk%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/11/06/后端必备linuk操作命令/</id>
    <published>2020-11-06T13:01:55.000Z</published>
    <updated>2020-11-08T06:33:05.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>后端开发也避免不了使用linux命令，比如上服务器查看日志文件，查看服务器状态等，所以打算总结一下linux相关的命令，毕竟不是运维，无法话太多时间去深入了解学习，所以总结的都是一些基础的，也是后端程序猿必备的常用命令。<br>Linux命令用法一般用man命令可以查看帮助信息。这里也提供了Linux中文帮助大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a><br>下面来看一些常用的命令吧～</p><h1 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h1><p>cd usr ： 切换到usr目录下<br>cd .. (或者cd ../)  ： 切换到上一层目录<br>cd /  ：切换到根目录<br>cd~ ：切换到用户主目录<br>cd- ：切换到上一个目录</p><h1 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h1><p>mkdir 目录名称：创建目录<br>ls ：查看目录信息<br>find 目录 参数：寻找目录（查） 例: find /home -name “*.txt”<br>mv 目录名称 新目录名称：修改目录名称（压缩包名也可以）<br>mv 目录名称 目录新位置：移到目录的位置（相当于剪切，文件数量没有增加）<br>cp -r 目录名称  目录拷贝的目录位置：拷贝目录，-r代表递归拷贝<br>rm -f 目录名称：删除目录（还可以删除文件或压缩包）</p><h1 id="文件操作命令（增删改查）"><a href="#文件操作命令（增删改查）" class="headerlink" title="文件操作命令（增删改查）"></a>文件操作命令（增删改查）</h1><p>touch 文件名称:文件的创建<br>cat/more/less/tail 文件名称：文件的查看<br>        cat:只能显示最后一屏内容<br>        more:可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看<br>        less:可以使用键盘上的pgup和pgDn向上或向下翻页，q结束查看<br>        head -10:查看文件前10行，Ctrl+c结束<br>        tail -10:查看文件的后10行 ，Ctrl+c结束<br>vim 文件名：修改文件的内容（改）<br>        一般步骤：vim文件 -&gt;进入文件-&gt;命令模式-&gt;按i进入编辑模式-&gt;编辑文件-&gt;按Esc进入底行模式-&gt;输入:wq 保                           存并退出（输入q!代表强制退出不保存）</p><p>​        vim常用命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动光标</span></span><br><span class="line"><span class="number">1</span>. vim 可以使用小写英文字母 h j k l 分别控制光标左 下 上 右移</span><br><span class="line"> <span class="number">2</span>.Ctrl+b 屏幕往后移动一页</span><br><span class="line"><span class="number">3</span>.Ctrl+f 屏幕往前移动一页</span><br><span class="line"> <span class="number">4</span>.Ctrl+u 屏幕往后移动半页</span><br><span class="line"><span class="number">5</span>.Ctrl+d 屏幕往前移动半页</span><br><span class="line"> <span class="number">6</span>.shift+g == G 移动到文章的最后</span><br><span class="line"> <span class="number">7</span>.shift+<span class="number">4</span> == $ 移动到光标所在的行尾</span><br><span class="line"> <span class="number">8</span>.shift+<span class="number">6</span> == ^ 移动光标所在行的行首</span><br><span class="line"> <span class="number">9</span>.w 光标跳到下个字的开头</span><br><span class="line"> <span class="number">10</span>.e 光标跳到下个字的字尾</span><br><span class="line"> <span class="number">11</span>.b 光标回到上个字的开头</span><br><span class="line"> 12.#l 光标移动到改行到第‘#’个位置</span><br><span class="line"> <span class="number">13</span>.gg 进入到文本的开始</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 删除文字</span></span><br><span class="line"> <span class="number">1</span>.x 每按一次删除光标所在位置的一个字符</span><br><span class="line"> 2.#x 例子：6x 删除光标所在位置的"后面"(包含自己在内)6个字符</span><br><span class="line"> <span class="number">3</span>.shift+x == X 每按一次，删除光标所在位置的前一个字符</span><br><span class="line"> 4.Shift+#x == #X 栗子 20X 删除光标所在位置的前面20个字符</span><br><span class="line"> <span class="number">5</span>.dd 删除光标所在行</span><br><span class="line"> 6.#dd 例子：6dd 从光标所在行开始删除6行</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 复制</span></span><br><span class="line"> <span class="number">1</span>.yw 将光标所在之处到字尾的字符复制到缓冲区</span><br><span class="line"> 2.#yw 复制#个字符到缓冲区</span><br><span class="line"> <span class="number">3</span>.yy 复制光标所在行到缓冲区</span><br><span class="line">4.#yy 拷贝从光标所在的改行‘往下数’#行文字</span><br><span class="line"><span class="number">5</span>.p 将缓冲区内的字符贴到光标所在位置</span><br><span class="line"> 注：所有与y有关的复制命令都必须与p配合才能完成复制粘贴功能</span><br><span class="line">  <span class="comment">// 替换</span></span><br><span class="line"> <span class="number">1</span>.r 替换光标所在处的字符</span><br><span class="line"> <span class="number">2</span>.R 替换光标所到之处的字符，直到按下Esc健为止</span><br><span class="line">   <span class="comment">// 撤销上一次操作</span></span><br><span class="line"> <span class="number">1</span>.u 回到上一个操作，按动多次‘u’可以执行多次恢复.</span><br><span class="line">   <span class="comment">// 更改</span></span><br><span class="line"> <span class="number">1</span>.cw 更改光标所在处的字到字尾处</span><br><span class="line"> 2.c#W 表示更改#个字</span><br><span class="line">   <span class="comment">// 跳转指定行</span></span><br><span class="line"> <span class="number">1</span>.ctrl+g 列出光标所在行到行号</span><br><span class="line"> 2.#G 表示移动光标到文章的第#行行首</span><br></pre></td></tr></table></figure><p>rm -rf 文件: 删除文件</p><h1 id="压缩文件操作命令"><a href="#压缩文件操作命令" class="headerlink" title="压缩文件操作命令"></a>压缩文件操作命令</h1><p><strong>打包并压缩文件</strong><br>Linux中的打包文件一般是以.tar结尾的，压缩的文件一般是以.gz结尾的.<br>tar -zcvf 打包压缩后的文件名 要打包的文件名<br>z:调用gzip压缩命令进行压缩<br>c:打包文件<br>v:显示运行过程<br>f:指定文件名</p><p><strong>解压压缩包</strong><br>tar [-xvf] 压缩文件<br>其中x代表解压</p><h1 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h1><p>通过ls -l 命令我们可以查看某个目录下的文件或目录的权限.<br><img src="https://github.com/geyou1995/picture/blob/master/linux1.png?raw=true" alt=""></p><p>第一列的内容信息<br><img src="https://github.com/geyou1995/picture/blob/master/linux3.png?raw=true" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件类型</span><br><span class="line">d:代表目录</span><br><span class="line">  -:代表文件</span><br><span class="line">  l:代表链接</span><br><span class="line">    </span><br><span class="line">linux中的权限</span><br><span class="line">  r:代表权限是可读，对应数字<span class="number">4</span></span><br><span class="line">w:代表权限是可写，对应数字<span class="number">2</span></span><br><span class="line">x:代表权限是可执行，对应数字<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>文件和目录权限区别</strong><br>对于文件：<br><img src="https://github.com/geyou1995/picture/blob/master/linux2.png?raw=true" alt=""></p><p><strong>在linux中每个用户必须属于一个组.不能独立于组外.在linux中每个文件有所有者、所在组、其他组的概念.</strong><br><strong>所有者</strong><br>一般指文件的创建者，谁创建了该文件，就天然的成为该文件的所有者.用 ls -l 命令可以看到文件的所有者，也可以使用 <strong>chown 用户名 文件名</strong> 来修改文件的所有者.<br><strong>所在组</strong><br>当某个用户创建了一个文件后,这个文件的所在组就是该用户所在的组 用 ls -l 命令可以看到文件的所在组，也可以使用 <strong>chgrp 组名 文件名</strong> 来修改文件所在的组.<br><strong>其他组</strong><br>除开文件的所有者和所在组的用户外,系统的其他用户都是文件的其他组.</p><p>修改文件/目录的权限的命令：chmod<br>例子：代表aaa.txt的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限<br>chmod u=rwx,g=rw,o=r aaa.txt</p><h1 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h1><p>pwd：显示当前所在位置<br>grep 要搜索的字符串 要搜索的文件 – color : 搜索命令，– color代表高亮<br>ps -ef/ps aux:这两个命令都是查看当前系统正在运行进程,两者的区别是展示格式不同.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis (表示查看包括redis字符串的进程)</span><br><span class="line">如果直接使用ps(process Status)命令，回显示所有进程的状态，通常结合grep命令查看某个进程的状态</span><br></pre></td></tr></table></figure><p>kill -9 进程的pid :杀死进程（-9 表示强制终止），先用ps 查找进程，然后kill掉<br>shutdown -h now： 指定现在立即关机<br>reboot：重开机</p><p><strong>网络通信命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o查看当前系统的网卡信息：ifconfig</span><br><span class="line">o查看与某台机器的连接情况：ping</span><br><span class="line">o查看当前系统的端口：netstat</span><br><span class="line">an 所有的连接和端口</span><br><span class="line">tuln 查看正在监听TCP（t）和UDP（u）的端口 ，例如：netstat -tuln | grep LISTEN</span><br><span class="line">rn 查看网关 route -n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之装饰者模式</title>
    <link href="http://yoursite.com/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/10/24/设计模式-装饰者模式/</id>
    <published>2020-10-24T05:46:55.000Z</published>
    <updated>2020-10-24T06:49:48.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更加灵活.本质是动态组合.</p><h1 id="结构与说明"><a href="#结构与说明" class="headerlink" title="结构与说明"></a>结构与说明</h1><p><img src="https://github.com/geyou1995/picture/blob/master/zsz.png?raw=true" alt=""></p><p>Component:组件对象的接口，就是被装饰者的基类,也就是抽象组件.<br>ConcreteComponent:具体的组件对象，实现组件对象接口，就是具体的被装饰者.<br>Decorator:装饰者的父类，一个抽象类。持有Component的对象实例<br>ConcreteDecorator：具体的装饰者，继承Decorator。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>这里就以照相为例吧，假设刚开始相机只有一个照相功能，现在需要在照相的基础上，分别添加美颜、滤镜 功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">photo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本组件(被装饰者)，只有照相功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">photo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"照相～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象装设者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体装饰者类</span></span><br><span class="line"><span class="comment">// 美颜</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeautyDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeautyDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">photo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增加美颜～"</span>);</span><br><span class="line">        component.photo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滤镜</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">photo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增加滤镜～"</span>);</span><br><span class="line">        component.photo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CameraComponent cameraComponent = <span class="keyword">new</span> CameraComponent();</span><br><span class="line">        <span class="comment">// 加美颜</span></span><br><span class="line">        BeautyDecorator beautyDecorator = <span class="keyword">new</span> BeautyDecorator(cameraComponent);</span><br><span class="line">        <span class="comment">// 加滤镜</span></span><br><span class="line">        FilterDecorator filterDecorator = <span class="keyword">new</span> FilterDecorator(beautyDecorator);</span><br><span class="line">        filterDecorator.photo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">增加滤镜～</span><br><span class="line">增加美颜～</span><br><span class="line">照相～</span><br></pre></td></tr></table></figure><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p><strong>优点</strong>:比继承灵活,更容易复用功能.<br><strong>缺点</strong>:会产生很多细粒度对象.</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>JDK里的IO流就是典型的装饰者模式.<br>Mybatis里Excutor也应用了装饰者模式等等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>spring解决循环依赖</title>
    <link href="http://yoursite.com/2020/10/08/spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://yoursite.com/2020/10/08/spring解决循环依赖/</id>
    <published>2020-10-08T11:55:55.000Z</published>
    <updated>2020-10-09T06:33:39.274Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h1><p>循环依赖指，A依赖B，B又依赖A,它们之间形成循环依赖。或者A依赖B，B依赖C，C又依赖A.<br><img src="https://github.com/geyou1995/picture/blob/master/xhyl.png?raw=true" alt=""></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在有两个实例A,B,互相依赖</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceA</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> InstanceB instanceB;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceB</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> InstanceA instanceA;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">()</span></span>&#123;</span><br><span class="line">RootBeanDefinition aRootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(InstanceA.class);</span><br><span class="line">RootBeanDefinition bRootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(InstanceB.class);</span><br><span class="line">beanDefinitionMap.put(<span class="string">"instanceA"</span>,aRootBeanDefinition);</span><br><span class="line">beanDefinitionMap.put(<span class="string">"instanceB"</span>,bRootBeanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">// 加载bean定义</span></span><br><span class="line">loadBeanDefinition();</span><br><span class="line"><span class="keyword">for</span> (String key : beanDefinitionMap.keySet()) &#123;</span><br><span class="line"><span class="comment">// 先创建A</span></span><br><span class="line">getBean(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取bean,bean的生命周期:实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 存到一级缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.实例化</span></span><br><span class="line">  <span class="comment">// 从bean定义中获取class信息，反射获取实例</span></span><br><span class="line">RootBeanDefinition beanDefinition = (RootBeanDefinition)beanDefinitionMap.get(beanName);</span><br><span class="line">Class&lt;?&gt; beanClass = beanDefinition.getBeanClass();</span><br><span class="line"><span class="comment">// A的Bean</span></span><br><span class="line">Object instance = beanClass.newInstance();</span><br><span class="line"><span class="comment">// 2.属性赋值</span></span><br><span class="line"><span class="comment">// 拿到所有属性,对有Autowired注解的成员变量也调用getBean（）,递归获取</span></span><br><span class="line">Field[] declaredFields = beanClass.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">Autowired annotation = declaredField.getAnnotation(Autowired.class);</span><br><span class="line"><span class="comment">// 说明属性上有Autowired注解</span></span><br><span class="line"><span class="keyword">if</span>(annotation != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">// 权限设置</span></span><br><span class="line">declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取成员变量名</span></span><br><span class="line">String fieldName = declaredField.getName();</span><br><span class="line"><span class="comment">// 获取B的bean对象</span></span><br><span class="line">Object fieldObject = getBean(fieldName);</span><br><span class="line"><span class="comment">// 放入对象属性</span></span><br><span class="line">declaredField.set(instance,fieldObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.初始化</span></span><br><span class="line">    todo ...  </span><br><span class="line"><span class="comment">// 4.存到一级缓存</span></span><br><span class="line">singletonObjects.put(beanName,instance);</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试结果:发生了循环以来问题，陷入了死循环</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">416</span>)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:<span class="number">442</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">74</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">at com.youga.beans.CycleRely.getBean(CycleRely.java:<span class="number">93</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h1 id="如何解决循环依赖？"><a href="#如何解决循环依赖？" class="headerlink" title="如何解决循环依赖？"></a>如何解决循环依赖？</h1><p>spring是通过三级缓存来解决的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级缓存：用来存放完整的Bean</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// 三级缓存：这里理解为用来处理动态代理的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 二级缓存:用来存储不成熟的Bean,只是实例化，并没有赋值的bean。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p><strong>看spring源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总体逻辑：首先会去一级缓存中找寻，如果一级缓存中没有并且标记正在创建的Bean，就会尝试去二级缓存找寻，如果二级缓存也没有就回去三级缓存中获取singletonFactory（用来创建bean的）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一级缓存中获取</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="comment">// 判断是否是循环依赖的bean</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// 一级缓存中不存在，并且是标记为正在创建的bean，尝试去二级缓存中获取</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="comment">// 二级缓存里没有，就去三级缓存中获取</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么三级缓存是什么时候放入singletonFactory对象的呢？看下面</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三级缓存中put数据</span></span><br><span class="line"><span class="comment">// beanName,mbd(bean定义，里面有bean的相关信息)</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line"><span class="comment">// 获取bean信息,普通bean或aop的bean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加到三级缓存</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么需要三级缓存？"><a href="#为什么需要三级缓存？" class="headerlink" title="为什么需要三级缓存？"></a>为什么需要三级缓存？</h1><h3 id="先思考下为什么需要二级缓存？"><a href="#先思考下为什么需要二级缓存？" class="headerlink" title="先思考下为什么需要二级缓存？"></a>先思考下为什么需要二级缓存？</h3><p>因为在多线程的情况下，假设线程A正在创建Bean，还没有赋值，只是完成了实例化，若这是线程B过来获取该Bean,就会获取到不完整的Bean。所以二级缓存是<strong>用来将成熟的Bean和纯净的Bean分离开，避免读取到不完整的Bean</strong>。</p><h3 id="为什么需要三级缓存？-1"><a href="#为什么需要三级缓存？-1" class="headerlink" title="为什么需要三级缓存？"></a>为什么需要三级缓存？</h3><p>我们知道Bean的Aop动态代理创建时在初始化后，但是循环依赖的Bean如果使用了Aop.那就没有意义了，无法等到解决循环依赖再创建动态代理，因为这时已经注入属性了。所以如果有循环依赖需要提前使用aop.<br>可以看到上面的earlySingletonObjects存放的是一个函数接口，不管是普通的Bean还是aop的bean，只要调用了就存在二级缓存返回。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>spring不能解决构造器的循环依赖，因为在实例化之前，一二三级缓存没有任何Bean的信息。<br>此外多例的Bean也不能解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot配置多数据源</title>
    <link href="http://yoursite.com/2020/09/30/SpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <id>http://yoursite.com/2020/09/30/SpringBoot配置多数据源/</id>
    <published>2020-09-30T06:29:55.000Z</published>
    <updated>2020-09-30T07:43:43.417Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>随着业务数据量增多，单个数据库已经承受不了高并发多压力。一个项目使用多个数据库来分担数据压力变得越来越重要；也可以用来做读写分离操作。下面是记录一种方式，如何在SpringBoot项目中配置多个数据源。</p><h1 id="步骤描述"><a href="#步骤描述" class="headerlink" title="步骤描述"></a>步骤描述</h1><h3 id="在application-properties配置数据源"><a href="#在application-properties配置数据源" class="headerlink" title="在application.properties配置数据源"></a>在application.properties配置数据源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下所示这里我配置了两个数据源</span></span><br><span class="line"><span class="comment">// 一个是本地的root数据库（mysql）</span></span><br><span class="line"><span class="comment">// 另一个是远程的一个pro数据库（PostgreSql）</span></span><br><span class="line">root.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/test </span></span><br><span class="line">root.datasource.username=root </span><br><span class="line">root.datasource.password=<span class="number">123456</span> </span><br><span class="line">root.datasource.driverClassName=com.mysql.jdbc.Driver </span><br><span class="line">root.datasource.initialSize=<span class="number">3</span> </span><br><span class="line">root.datasource.minIdle=<span class="number">3</span> </span><br><span class="line">root.datasource.maxActive=<span class="number">55</span> </span><br><span class="line">root.datasource.maxWait=<span class="number">20000</span> </span><br><span class="line">root.datasource.timeBetweenEvictionRunsMillis=<span class="number">60000</span> </span><br><span class="line">root.datasource.minEvictableIdleTimeMillis=<span class="number">300000</span></span><br><span class="line">root.datasource.validationQuery=SELECT <span class="string">'x'</span> </span><br><span class="line">root.datasource.testWhileIdle=<span class="keyword">true</span> </span><br><span class="line">root.datasource.testOnBorrow=<span class="keyword">false</span> </span><br><span class="line">root.datasource.testOnReturn=<span class="keyword">false</span> </span><br><span class="line">root.datasource.filters=wall</span><br><span class="line"></span><br><span class="line">pro.datasource.url=jdbc:postgresql:<span class="comment">//192.168.95.143:5432/maycur-pro</span></span><br><span class="line">pro.datasource.username=team1</span><br><span class="line">pro.datasource.password=maycur</span><br><span class="line">pro.datasource.driverClassName=org.postgresql.Driver</span><br><span class="line">pro.datasource.initialSize=<span class="number">3</span></span><br><span class="line">pro.datasource.minIdle=<span class="number">3</span></span><br><span class="line">pro.datasource.maxActive=<span class="number">55</span></span><br><span class="line">pro.datasource.maxWait=<span class="number">20000</span></span><br><span class="line">pro.datasource.timeBetweenEvictionRunsMillis=<span class="number">60000</span></span><br><span class="line">pro.datasource.minEvictableIdleTimeMillis=<span class="number">300000</span></span><br><span class="line">pro.datasource.validationQuery=SELECT <span class="string">'x'</span></span><br><span class="line">pro.datasource.testWhileIdle=<span class="keyword">true</span></span><br><span class="line">pro.datasource.testOnBorrow=<span class="keyword">false</span></span><br><span class="line">pro.datasource.testOnReturn=<span class="keyword">false</span></span><br><span class="line">pro.datasource.filters=wall</span><br></pre></td></tr></table></figure><p><strong>配置参数介绍</strong><br><img src="https://github.com/geyou1995/picture/blob/master/dataSourcepz.jpeg?raw=true" alt=""></p><h3 id="准备数据源参数"><a href="#准备数据源参数" class="headerlink" title="准备数据源参数"></a>准备数据源参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> initialSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxActive;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWait;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis;</span><br><span class="line">    <span class="keyword">private</span> String validationQuery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn;</span><br><span class="line">    <span class="keyword">private</span> String filters;</span><br><span class="line">    <span class="keyword">private</span> String dbType;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里配置pro数据库配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"application.properties"</span>) <span class="comment">// 指定加载的配置文件</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = ProDataSourceProperties.PREFIX) <span class="comment">// 通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上,将配置文件对应的数据赋值给BaseDataSourceProperties里的成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDataSourceProperties</span> <span class="keyword">extends</span> <span class="title">BaseDataSourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"pro.datasource"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同理配置root数据库</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"application.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = RootDataSourceProperties.PREFIX)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootDataSourceProperties</span> <span class="keyword">extends</span> <span class="title">BaseDataSourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"root.datasource"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建数据源配置类"><a href="#创建数据源配置类" class="headerlink" title="创建数据源配置类"></a>创建数据源配置类</h3><p>这里我是将Mapper分包处理，不同的数据源去扫描不同的Mapper文件去操作数据库。结构如下<br><img src="https://github.com/geyou1995/picture/blob/master/dataSourcejg1.png?raw=true" alt=""></p><p><strong>开始配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置pro数据库的配置</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 申明为配置类</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.youga.springboot.dao.pro"</span>, sqlSessionTemplateRef = <span class="string">"proSessionTemplate"</span>) <span class="comment">// 扫描该路近下的mapper文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProConfigurtion</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProDataSourceProperties properties; <span class="comment">// 注入上步骤配置好的数据源配置文件类信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(properties.getDriverClassName());</span><br><span class="line">        dataSource.setUrl(properties.getUrl());</span><br><span class="line">        dataSource.setUsername(properties.getUsername());</span><br><span class="line">        dataSource.setPassword(properties.getPassword());</span><br><span class="line">        dataSource.setInitialSize(properties.getInitialSize());</span><br><span class="line">        dataSource.setMinIdle(properties.getMinIdle());</span><br><span class="line">        dataSource.setMaxActive(properties.getMaxActive());</span><br><span class="line">        dataSource.setMaxWait(properties.getMaxWait());</span><br><span class="line">       dataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis()); </span><br><span class="line">        dataSource.setValidationQuery(properties.getValidationQuery());</span><br><span class="line">        dataSource.setTestWhileIdle(properties.isTestWhileIdle());</span><br><span class="line">        dataSource.setTestOnBorrow(properties.isTestOnBorrow());</span><br><span class="line">        dataSource.setTestOnReturn(properties.isTestOnReturn());</span><br><span class="line">        dataSource.setDbType(properties.getDbType());</span><br><span class="line">        dataSource.setFilters(properties.getFilters());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// @Qualifier注解限定哪个bean应该被自动注入.</span></span><br><span class="line">  <span class="comment">// 当Spring无法判断出哪个bean应该被注入时有助于消除歧义bean的自动注入</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proDataSourceTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">(@Qualifier(<span class="string">"proDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SqlSessionFactory是MyBatis的关键对象</span></span><br><span class="line"><span class="comment">     * 它是个单个数据库映射关系经过编译后的内存镜像.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"proDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">      <span class="comment">// 配置数据源 </span></span><br><span class="line">        sessionFactory.setDataSource(dataSource);</span><br><span class="line">       <span class="comment">// 配置执行Mapper文件存放的位置</span></span><br><span class="line">        sessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:*/com/youga/springboot/dao/pro/mapper/*.xml"</span>));</span><br><span class="line">      <span class="comment">// 这里可以配置typeAliasesPackage -- 表示对应我们的实体类所在的包</span></span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SqlSessionTemplate是MyBatis-Spring的核心。</span></span><br><span class="line"><span class="comment">     * 这个类负责管理MyBatis的SqlSession,调用MyBatis的SQL方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"proSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sessionTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"proSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同理配置root数据库配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.youga.springboot.dao.root"</span>, sqlSessionTemplateRef = <span class="string">"rootSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RootDataSourceProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(properties.getDriverClassName());</span><br><span class="line">        dataSource.setUrl(properties.getUrl());</span><br><span class="line">        dataSource.setUsername(properties.getUsername());</span><br><span class="line">        dataSource.setPassword(properties.getPassword());</span><br><span class="line">        dataSource.setInitialSize(properties.getInitialSize());</span><br><span class="line">        dataSource.setMinIdle(properties.getMinIdle());</span><br><span class="line">        dataSource.setMaxActive(properties.getMaxActive());</span><br><span class="line">        dataSource.setMaxWait(properties.getMaxWait());</span><br><span class="line">       dataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis());</span><br><span class="line"> dataSource.setTimeBetweenEvictionRunsMillis(properties.getTimeBetweenEvictionRunsMillis());</span><br><span class="line">        dataSource.setValidationQuery(properties.getValidationQuery());</span><br><span class="line">        dataSource.setTestWhileIdle(properties.isTestWhileIdle());</span><br><span class="line">        dataSource.setTestOnBorrow(properties.isTestOnBorrow());</span><br><span class="line">        dataSource.setTestOnReturn(properties.isTestOnReturn());</span><br><span class="line">        dataSource.setDbType(properties.getDbType());</span><br><span class="line">        dataSource.setFilters(properties.getFilters());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootDataSourceTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">(@Qualifier(<span class="string">"rootDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"rootDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sessionFactory.setDataSource(dataSource);</span><br><span class="line">        sessionFactory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:*/com/youga/springboot/dao/root/mapper/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"rootSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sessionTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"rootSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@GetMapping</span>(<span class="string">"/dateSourceTest"</span>)</span><br><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">dateSourceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> List&lt;ProcessLogDO&gt; processLogDOS = processLogMapper.select();</span><br><span class="line">    UserDO userDO = userMapper.select(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"proData:"</span> + JSON.toJSONString(processLogDOS.get(<span class="number">0</span>)) </span><br><span class="line">          +<span class="string">"rootData:"</span> + JSON.toJSONString(userDO);</span><br><span class="line">&#125;</span><br><span class="line">---------------结果---------------</span><br><span class="line">proData:&#123;<span class="string">"entCode"</span>:<span class="string">"EC16040611HZCQGW"</span>,<span class="string">"formDataCode"</span>:<span class="string">"BX1907081H2S2SCG"</span>&#125;</span><br><span class="line">rootData:&#123;<span class="string">"age"</span>:<span class="number">27</span>,<span class="string">"ext"</span>:<span class="string">"北冥神功"</span>,<span class="string">"id"</span>:<span class="number">2</span>,<span class="string">"name"</span>:<span class="string">"虚竹"</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybaits拦截器实现水平分表</title>
    <link href="http://yoursite.com/2020/09/26/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%E4%B9%8Bmybatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/09/26/水平分表之mybatis拦截器实现/</id>
    <published>2020-09-26T10:49:55.000Z</published>
    <updated>2020-09-26T12:28:17.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>最近项目中的几张表数据行超过了1000万行，所以需要对这些表进行水平分表，提高数据查询的性能。可选的方案有sharding-jdbc中间件还有就是Mybatis拦截器。由于个别表数据涉及了复杂的sql查询，可能会有意想不到的坑，所以决定采用Mybatis拦截器的方式。所以决定记录下来实现过程。</p><h1 id="分表思路"><a href="#分表思路" class="headerlink" title="分表思路"></a>分表思路</h1><p>这里我需要分表的表名为process_log,这里不是根据正常的id字段去分表（因为这张表连id字段都没有…）,而是选择这张表的唯一字段form_data_code来作为分表字段，将form_data_code字段值进行hashCode()然后进行取模。目前这张表的数据足足5000多万，考虑之后还会增加，需要将表数据控制在百万级内，所以你决定分表20张。先来了解一下Mybatis拦截器…</p><h1 id="Mybaits拦截器"><a href="#Mybaits拦截器" class="headerlink" title="Mybaits拦截器"></a>Mybaits拦截器</h1><h2 id="对四大接口进行拦截"><a href="#对四大接口进行拦截" class="headerlink" title="对四大接口进行拦截"></a>对四大接口进行拦截</h2><p><img src="https://github.com/geyou1995/picture/blob/master/mybatisIN.png?raw=true" alt=""></p><p><strong>Executor</strong>:是mybatis的内部执行器，它通过调用StatementHandler来操作数据库<br><strong>StatementHandler</strong>:是mybatis直接和数据库执行sql脚本的对象<br><strong>ResultSetHandler</strong>:是mybaits把ResultSet集合映射成POJO的接口对象<br><strong>ParameterHandler</strong>:是mybatis实现sql入参设置的对象</p><h2 id="Interceptor-接口"><a href="#Interceptor-接口" class="headerlink" title="Interceptor 接口"></a>Interceptor 接口</h2><p>mtbatis拦截器必须实现Interceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// 拦截器执行的逻辑方法</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;  </span><br><span class="line">  <span class="comment">// 用来封装目标对象。可以返回目标对象本身也可以根据实际需要，创建一个代理对象</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  <span class="comment">// 在Mybatis进行配置插件的时候可以配置自定义相关属性</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Intercepts注解参数数名</span></span><br><span class="line"><span class="comment">// Intercepts 拦截器: 标识我的类是一个拦截器</span></span><br><span class="line"><span class="comment">// Signature 署名: 则是指明我们的拦截器需要拦截哪一个接口的哪一个方法</span></span><br><span class="line"><span class="comment">//  type 对应四类接口中的某一个，比如是 StatementHandler</span></span><br><span class="line"><span class="comment">//  method 对应接口中的哪类方法，比如 StatementHandler 的 prepare 方法</span></span><br><span class="line"><span class="comment">//  args对应接口中的哪一个方法，方法参数</span></span><br><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(type = StatementHandler.class,method = <span class="string">"prepare"</span>,args = &#123;Connection.class,Integer.class&#125;))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardTableInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实战实现"><a href="#实战实现" class="headerlink" title="实战实现"></a>实战实现</h3><p><strong>1.实现自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SegmentTable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">tableName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class <span class="title">strategyClazz</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要分表的table的Mapper接口</span></span><br><span class="line"><span class="meta">@SegmentTable</span>(tableName = <span class="string">"process_log"</span>, strategyClazz = ProcessLogStrategy.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessLogMapper</span> </span>&#123;<span class="comment">// todo&#125;</span></span><br></pre></td></tr></table></figure><p>2.<strong>使用策略模式实现算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShardTableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分表算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> statementHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">shardAlgorithm</span><span class="params">(StatementHandler statementHandler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardTableContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ShardTableStrategy tableStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShardTableContext</span><span class="params">(ShardTableStrategy tableStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tableStrategy = tableStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doShardAlgorithm</span><span class="params">(StatementHandler statementHandler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tableStrategy.shardAlgorithm(statementHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process_log表算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLogStrategy</span> <span class="keyword">implements</span> <span class="title">ShardTableStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ProcessLogStrategy.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分表20张</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer PROCESS_LOG_TABLE_NUM = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特殊处理字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PROCESS_LOG_TABLE_CONFIRM_INDEX = <span class="string">"subTableConfirmIndex"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分表字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PROCESS_LOG_TABLE_SUB_FIELD = <span class="string">"formDataCode"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PROCESS_LOG_BLANK_INDEX = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shardAlgorithm</span><span class="params">(StatementHandler statementHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (statementHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"statementHandler is null"</span>);</span><br><span class="line">            <span class="keyword">return</span> PROCESS_LOG_BLANK_INDEX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">        Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">        Map param2ValeMap = JSONObject.parseObject(JSON.toJSONString(parameterObject), Map.class);</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(param2ValeMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PROCESS_LOG_BLANK_INDEX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊处理foreach循环语句</span></span><br><span class="line">        Object confirmIndexValue = param2ValeMap.get(PROCESS_LOG_TABLE_CONFIRM_INDEX);</span><br><span class="line">        <span class="keyword">if</span> (confirmIndexValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> SHARD_TABLE_INDEX_LINE + confirmIndexValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object subFieldValue = param2ValeMap.get(PROCESS_LOG_TABLE_SUB_FIELD);</span><br><span class="line">        <span class="keyword">return</span> SHARD_TABLE_INDEX_LINE + Math.abs(subFieldValue.hashCode() % PROCESS_LOG_TABLE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.拦截器intercept()执行逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line">       <span class="comment">// 全局操作读对象</span></span><br><span class="line">       MetaObject metaObject = MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line">       <span class="comment">// @SegmentTable -- 只拦截有注解的Mapper</span></span><br><span class="line">       SegmentTable segmentTable = getSegmentTable(metaObject);</span><br><span class="line">       <span class="keyword">if</span> (segmentTable == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.对value进行算法 -&gt; 确定表名</span></span><br><span class="line">       Class strategyClazz = segmentTable.strategyClazz();</span><br><span class="line">       ShardTableStrategy strategy = (ShardTableStrategy) strategyClazz.newInstance();</span><br><span class="line">       String index = <span class="keyword">new</span> ShardTableContext(strategy).doShardAlgorithm(statementHandler);</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">"ShardTableInterceptor segmentTable=&#123;&#125;,index=&#123;&#125;"</span>, JSON.toJSONString(segmentTable), index);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.替换表名</span></span><br><span class="line">       <span class="comment">// 获取原始sql</span></span><br><span class="line">       String tableName = segmentTable.tableName();</span><br><span class="line">       String sql = (String) metaObject.getValue(BOUND_SQL_NAME);</span><br><span class="line">       metaObject.setValue(BOUND_SQL_NAME, sql.replaceFirst(tableName, tableName + index));</span><br><span class="line">       <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="总结遇到的问题"><a href="#总结遇到的问题" class="headerlink" title="总结遇到的问题"></a>总结遇到的问题</h1><p>1.这张表用了多表关联<br>现在终于明白，为什么要单表查询了，许多数据库性能的优化，都需要在单表的基础上才能更好的实施，所以现在的做法是，首先将多表关联的部分，采用单表查询在业务里处理掉.</p><p>2.分页插件pagehelper导致自定义插件无效<br>项目系统里也用了mybatis的分页插件pagehelper,pagehelper的intercept方法中没有invocation.proceed()，所以导致自定义的拦截器失效，没有传递下去。所以需要调整注册顺序。– 参考<br><a href="http://xtong.tech/2018/08/01/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%9B%A0pagehelper%E8%80%8C%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" target="_blank" rel="noopener">http://xtong.tech/2018/08/01/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%9B%A0pagehelper%E8%80%8C%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</a></p><p>3.迁移老数据<br>分表首先要做的就是老数据的迁移，由于这里是根据Java的hashcode()计算关键字段，数据库的函数也要同一种hash算法，这里用的数据库是postgreSql,里面提供了一些hash算法但是和java的不同，因为要用阿里的DataWorks迁移，经过调研，Pg可以提供自定义算法，所以可以创建于JAVA hashCode()相同的自定义算法，这样就可以保证数据的迁移。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 自定义java hashCode算法</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span>  hash_code(<span class="built_in">text</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> hash_code(<span class="built_in">text</span>) <span class="keyword">RETURNS</span> <span class="built_in">integer</span></span><br><span class="line">    <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">$$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    i <span class="built_in">integer</span> := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span></span><br><span class="line">    h <span class="built_in">bigint</span>  := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.length($<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">LOOP</span></span><br><span class="line">            h = (h * <span class="number">31</span> + <span class="keyword">ascii</span>(<span class="keyword">substring</span>($<span class="number">1</span>, i, <span class="number">1</span>))) &amp; <span class="number">4294967295</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    RETURN cast(cast(h AS bit(32)) AS int4);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://yoursite.com/2020/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/19/设计模式-策略模式/</id>
    <published>2020-09-19T07:26:55.000Z</published>
    <updated>2020-09-19T06:53:38.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义一系列的算法，把他们一个个封装起来，并且使它们可相互替换。</p><h1 id="结构及说明"><a href="#结构及说明" class="headerlink" title="结构及说明"></a>结构及说明</h1><p><img src="https://github.com/geyou1995/picture/blob/master/strategy.png?raw=true" alt=""></p><p>Strategy:策略接口，用来约束一系列具体的策略算法。Context使用这个接口来调用具体的算法。<br>ConcreteStrategy:具体的策略实现，也就是具体的算法实现。<br>Context:上下文,负责和具体的策略类交互通常会持有一个正常的策略实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 算法方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下文接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的策略实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"算法A实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h1><p>假设某公司一款产品，针对不同的客户报价不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ProductStragety stragety;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductContext</span><span class="params">(ProductStragety stragety)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stragety = stragety;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stragety.sell(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalCustomer</span> <span class="keyword">implements</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通用户/新用户，原价出售"</span>);</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldCustomer</span> <span class="keyword">implements</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老用户，95折"</span>);</span><br><span class="line">        <span class="keyword">return</span> money*<span class="number">0.95</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeCustomer</span> <span class="keyword">implements</span> <span class="title">ProductStragety</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sell</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大用户，9折"</span>);</span><br><span class="line">        <span class="keyword">return</span> money*<span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ProductContext context1 = <span class="keyword">new</span> ProductContext(<span class="keyword">new</span> NormalCustomer());</span><br><span class="line">   ProductContext context2 = <span class="keyword">new</span> ProductContext(<span class="keyword">new</span> OldCustomer());</span><br><span class="line">   ProductContext context3 = <span class="keyword">new</span> ProductContext(<span class="keyword">new</span> LargeCustomer());</span><br><span class="line">   System.out.println(context1.sell(<span class="number">1000</span>));</span><br><span class="line">   System.out.println(context2.sell(<span class="number">1000</span>));</span><br><span class="line">   System.out.println(context3.sell(<span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   -----------------------------------------</span><br><span class="line">   输出：</span><br><span class="line">   普通用户/新用户，原价出售</span><br><span class="line"><span class="number">1000.0</span></span><br><span class="line">老用户，<span class="number">95</span>折</span><br><span class="line"><span class="number">950.0</span></span><br><span class="line">大用户，<span class="number">9</span>折</span><br><span class="line"><span class="number">900.0</span></span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>JDK的Comparator就是使用了策略模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        list.sort(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = Lists.newArrayList();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>,<span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">24</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">25</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">18</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> PersonSortByName());--</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> ersonSortByAge());--</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 自定义比较策略</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">PersonSortByName</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 自定义比较策略</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ersonSortByAge</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge().compareTo(o2.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">  输出</span><br><span class="line">  [Person&#123;name=<span class="string">'d'</span>, age=<span class="number">30</span>&#125;, Person&#123;name=<span class="string">'c'</span>, age=<span class="number">24</span>&#125;, Person&#123;name=<span class="string">'b'</span>, age=<span class="number">25</span>&#125;, Person&#123;name=<span class="string">'a'</span>, age=<span class="number">18</span>&#125;]</span><br><span class="line">  </span><br><span class="line">[Person&#123;name=<span class="string">'a'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'b'</span>, age=<span class="number">25</span>&#125;, Person&#123;name=<span class="string">'c'</span>, age=<span class="number">24</span>&#125;, Person&#123;name=<span class="string">'d'</span>, age=<span class="number">30</span>&#125;]</span><br><span class="line">  </span><br><span class="line">[Person&#123;name=<span class="string">'a'</span>, age=<span class="number">18</span>&#125;, Person&#123;name=<span class="string">'c'</span>, age=<span class="number">24</span>&#125;, Person&#123;name=<span class="string">'b'</span>, age=<span class="number">25</span>&#125;, Person&#123;name=<span class="string">'d'</span>, age=<span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="http://yoursite.com/2020/09/19/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/09/19/分库分表/</id>
    <published>2020-09-19T02:01:55.000Z</published>
    <updated>2020-09-19T03:48:47.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么需要分库分表？"><a href="#为什么需要分库分表？" class="headerlink" title="为什么需要分库分表？"></a>为什么需要分库分表？</h1><p>数据库数据会随着业务的发展而不断增多，单表单库性能就存在很大的问题了，如增删改查的开销也会越来越大。<br>当一张单表的容量低于1千万以下是可接受的，这时B+Tree索引树高在3～5之间。</p><h1 id="数据库瓶颈"><a href="#数据库瓶颈" class="headerlink" title="数据库瓶颈"></a><strong>数据库瓶颈</strong></h1><h3 id="IO瓶颈"><a href="#IO瓶颈" class="headerlink" title="IO瓶颈"></a>IO瓶颈</h3><p>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询都会产生大量的IO，降低查询速度。（分库和垂直分表）<br>第二种：网络IO瓶颈，请求的数据太多，网络宽带不够。（分库）</p><h3 id="CPU瓶颈"><a href="#CPU瓶颈" class="headerlink" title="CPU瓶颈"></a>CPU瓶颈</h3><p>第一种：SQL问题，如SQL中包含join、group by、非索引字段条件等,增加CPU运算等操作(SQL优化,优化索引)<br>第二种：单表数据量太大，查询时扫描等行太多，SQL效率太多，CPU率先出现瓶颈（水平分表）</p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a><strong>垂直分库</strong></h4><p><strong>说明</strong><br>根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务进行独立划分。项目一开始是一个单体应用，所有表数据都放在一个数据库里。之后随着业务增大，根据业务拆分成多个数据库。</p><p><strong>特点</strong><br>每个库的结构都不一样.<br>每个库的数据都不一样，没有交集。<br>所有库数据的交集就是全量数据。</p><p><strong>示例图</strong></p><p><img src="https://github.com/geyou1995/picture/blob/master/czfk.png?raw=true" alt=""></p><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p><strong>说明</strong><br>把一张表的多个字段分别拆分成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。也可以叫主表和葱表,从而提升数据库性能.</p><p><strong>特点</strong><br>每个表的结构不一样。<br>每个表的数据也不一样。一般每个表至少有一列交集，一般是主键，用于关联数据。<br>所有表的数据就是全量数据。</p><p><strong>示例图</strong><br><img src="https://github.com/geyou1995/picture/blob/master/czfb.png?raw=true" alt=""></p><p>如上将商品的详情数据(冷数据)和基本信息(热数据)拆分成两张表。</p><h4 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h4><p><strong>说明</strong><br>以字段为依据，根据一定策略（hash、rangde等），将一个库中的数据拆分到多个库中。</p><p><strong>特点</strong><br>每个库的结构都一样。<br>每个库的数据都不一样。<br>所有库的数据时候全量数据。</p><p><strong>示例图</strong></p><p><img src="https://github.com/geyou1995/picture/blob/master/spfk.png?raw=true" alt=""></p><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p><strong>说明</strong><br>以<strong>字段</strong>为依据，按照一定策略（hash、range等），将一个<strong>表</strong>中的数据拆分到多个<strong>表</strong>中。一般单表数据超过1千万就要考虑水平分表了。</p><p><strong>特点</strong><br>每个表的结构都一样。<br>每个表的数据都不一样。<br>所有表的并集是全量数据。</p><p><strong>示例图</strong></p><p><img src="https://github.com/geyou1995/picture/blob/master/spfb.png?raw=true" alt=""></p><h1 id="数据分片规则"><a href="#数据分片规则" class="headerlink" title="数据分片规则"></a>数据分片规则</h1><h4 id="Hash取模分表"><a href="#Hash取模分表" class="headerlink" title="Hash取模分表"></a>Hash取模分表</h4><p>一般采用Hash取模的切分方式，例如：假设按goods_id分4张表。（goods_id%4 取整确定表）<br><img src="https://github.com/geyou1995/picture/blob/master/hash.png?raw=true" alt=""></p><h4 id="数值Range分表"><a href="#数值Range分表" class="headerlink" title="数值Range分表"></a>数值Range分表</h4><p>按照时间区间或ID区间来切分。例如：将goods_id为11000的记录分到第一个表，10012000的分到第二个表，以此类推。<br><img src="https://github.com/geyou1995/picture/blob/master/range.png?raw=true" alt=""></p><h1 id="工具及方案"><a href="#工具及方案" class="headerlink" title="工具及方案"></a>工具及方案</h1><p>1.sharding-sphere：jar，前身是sharding-jdbc.<br>2.TDDL：jar，Taobao Distribute Data Layer.<br>3.Mycat：中间件.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里总结的只是一些基础概念的东西，还需要结合实际操作增加认识与扩展。之后小编刚好会有一个实战项目，水平分表的实战，之后会结合总结的。</p><p>详细参考文章：<br><a href="https://juejin.im/post/6844903863464493064" target="_blank" rel="noopener">https://juejin.im/post/6844903863464493064</a><br><a href="https://www.cnblogs.com/qdhxhz/p/11608222.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/11608222.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之工厂方法模式</title>
    <link href="http://yoursite.com/2020/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/04/设计模式-工厂方法模式/</id>
    <published>2020-09-04T07:26:55.000Z</published>
    <updated>2020-09-04T08:25:30.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>在工厂方法模式之前，先了解简单工厂.<br>首先简单工厂不是一个标准的设计模式！简单工厂不是一个标准的设计模式！简单工厂不是一个标准的设计模式！<br>简单的本质就是选择实现。工厂就是用来创建对象的，根据传入的参数，返回对应的实例对象。<br>优点：帮助封装、解耦。<br>缺点：不符合开闭原则，有新对象就要修改工厂类的代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面分别是小米手机类、华为手机类和苹果手机类</span></span><br><span class="line"><span class="comment">// 1.正常创建使用</span></span><br><span class="line"><span class="comment">// 我们创建它们的时候需要一个一个对象去new</span></span><br><span class="line">MiPhone mi = <span class="keyword">new</span> MiPhone();</span><br><span class="line">IPhone i = <span class="keyword">new</span> IPhone();</span><br><span class="line">HwPhone i = <span class="keyword">new</span> HWPhone();</span><br><span class="line"><span class="comment">// todo...</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.使用简单工厂</span></span><br><span class="line"><span class="comment">// 都实现同一个接口或继承同一个对象Phone</span></span><br><span class="line">HWPhone implements Phone </span><br><span class="line">IPhone implements Phone </span><br><span class="line">MiPhone implements Phone</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 手机工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">makePhone</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Mi"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"I"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"HW"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HWPhone();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有该类型产品 type="</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line">Phone mi = PhoneFactory.makePhone(<span class="string">"Mi"</span>);</span><br><span class="line">Phone i = PhoneFactory.makePhone(<span class="string">"I"</span>);</span><br><span class="line">Phone hw = PhoneFactory.makePhone(<span class="string">"HW"</span>);</span><br><span class="line"><span class="comment">// todo...</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>简单工厂就是把对象全部向一个工厂里创建,根据类型参数返回不同的实力对象.<br>优点：封装、实现客户端和具体实现类的解耦.<br>缺点：不符合开闭原则，每次需要添加新的产品对象使都要修改工厂类.</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个用于创建对象的接口,让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到其子类。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://github.com/geyou1995/picture/blob/master/gcff.png?raw=true" alt=""></p><p>Creator:抽象工厂角色，是工厂方法模式的核心，与应用程序无关。<br>ConcreteCreator：具体的工厂，Product方法的具体实现。<br>Product：抽象产品角色，声明工厂方法，通常会返回一个Product类型的实例对象<br>ConcreteProduct：具体的产品对象，实现抽象产品的所有方法。</p><h3 id="具体示例代码"><a href="#具体示例代码" class="headerlink" title="具体示例代码"></a>具体示例代码</h3><p>1.定义一个抽象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">mackPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.产品各自的工厂实现这个抽象工厂,重写工厂方法，可以看到各自的工厂生产各自的产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 苹果手机工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">mackPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小米手机工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Phone <span class="title">mackPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 华为手机工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HWFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">mackPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HWPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.客户端使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MIFactory miFactory = <span class="keyword">new</span> MIFactory();</span><br><span class="line">       miFactory.mackPhone();</span><br><span class="line">       IFactory iFactory = <span class="keyword">new</span> IFactory();</span><br><span class="line">       iFactory.mackPhone();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 新增一个类型产品，只需添加新工厂，不要修改原有工厂</span></span><br><span class="line">       HWFactory hwFactory = <span class="keyword">new</span> HWFactory();</span><br><span class="line">       hwFactory.mackPhone();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>相比较于简单工厂，工厂方法模式就是将工厂抽象化，将具体的产品分布在不同的具体工厂中操作,<br>而且复合开闭原则，新的产品只要再写一个新的工厂就行，不用修改原来的工厂类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-构建者模式</title>
    <link href="http://yoursite.com/2020/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/08/29/设计模式-构建者模式/</id>
    <published>2020-08-29T11:37:55.000Z</published>
    <updated>2020-08-29T12:59:31.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h1 id="结构与说明"><a href="#结构与说明" class="headerlink" title="结构与说明"></a>结构与说明</h1><p><img src="https://github.com/geyou1995/picture/blob/master/gzq.jpg?raw=true" alt=""></p><p><strong>Builder</strong>: 构建者接口，定义创建一个Product对象所需的各个部件的操作。<br><strong>ConcreteBuilder</strong>:具体的构建器实现，实现各个部件的创建，并负责组装Product对象的各个部件，同时还提供一个让用户获取组装完成后的产品对象的方法。<br><strong>Director</strong>:指导者，主要用来使用Builder接口，以一个统一的过程来构建所需要的Product对象。<br><strong>Product</strong>: 产品，表示被构建器构建的复杂对象。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>现在有这样一个Hero类需要构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">  <span class="comment">// 代号(必须)</span></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line">  <span class="comment">// 姓名(必须)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">// 年龄(必须)</span></span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="comment">// 主技能(必须)</span></span><br><span class="line">  <span class="keyword">private</span> String skillMain;</span><br><span class="line">  <span class="comment">// 技能1（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill1;</span><br><span class="line">  <span class="comment">// 技能2（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill2;</span><br><span class="line">  <span class="comment">// 技能3（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill3;</span><br><span class="line">  <span class="comment">// 技能4（可选）</span></span><br><span class="line">  <span class="keyword">private</span> String skill4;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一种：折叠构造函数模式</strong><br>通过传参构造需要的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String code, String name, Integer age, String skillMain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String code, String name, Integer age, String skillMain, String skill1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">        <span class="keyword">this</span>.skill1 = skill1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String code, String name, Integer age, String skillMain, String skill1, String skill2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">        <span class="keyword">this</span>.skill1 = skill1;</span><br><span class="line">        <span class="keyword">this</span>.skill2 = skill2;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>第二种：JavaBean模式</strong><br>创建一个对象,对其中的成员属性依次set(),get()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> code;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.code = code;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>从上述两种方法可以看出，当一个类对象非常复杂时，以上方法都有缺点<br>第一种方式：代码阅读以及使用不方便,每次使用需要知道调用哪种构造方法，当参数很多时还需要注意参数顺序，易出错。<br>第二种方式：在构建的过程中对象的状态容易发生变化，造成错误。<br>针对以上问题，所以才有了Builder模式。<br><strong>当一个类对象非常复杂，构造的参数很多，并且这些参数是可选的，可以考虑使用构建者。</strong></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>1.在Hero类中创建一个静态内部类Builder，参数和Hero类一样。(必要的参数用final修饰)<br>2.将Hero的构造方法私有，且入参为Builder类，防止外部创建。只能由外部调用Builder类创建，<br>所以也要在Builder里提供一个方法，返回Hero对象。<br>3.Hero类的参数提供get()方法，Builder类的参数提供set()方法，返回值都为Builder对象，形成链式编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名(必须)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主技能(必须)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String skillMain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 技能1（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String skill1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 技能2（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String skill2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化Hero构造方法，外部只能通过Builder获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hero</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.skillMain = builder.skillMain;</span><br><span class="line">        <span class="keyword">this</span>.skill1 = builder.skill1;</span><br><span class="line">        <span class="keyword">this</span>.skill2 = builder.skill2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供获取成员变量的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSkillMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skillMain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSkill1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skill1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSkill2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skill2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hero&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", skillMain='"</span> + skillMain + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", skill1='"</span> + skill1 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", skill2='"</span> + skill2 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 姓名(必须)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="comment">// 主技能(必须)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String skillMain;</span><br><span class="line">        <span class="comment">// 技能1（可选）</span></span><br><span class="line">        <span class="keyword">private</span> String skill1;</span><br><span class="line">        <span class="comment">// 技能2（可选）</span></span><br><span class="line">        <span class="keyword">private</span> String skill2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * final修饰的参数为必传</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String name, String skillMain)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.skillMain = skillMain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置成员参数，返回builder对象，链式编程</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> skill1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSkill1</span><span class="params">(String skill1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.skill1 = skill1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSkill2</span><span class="params">(String skill2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.skill2 = skill2;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供一个返回Hero的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Hero <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Hero(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero.Builder builder = <span class="keyword">new</span> Hero.Builder(<span class="string">"萧峰"</span>, <span class="string">"降龙十八掌"</span>);</span><br><span class="line">        Hero hero = builder.setSkill1(<span class="string">"打狗棒法"</span>).setSkill2(<span class="string">"少林武学"</span>).builder();</span><br><span class="line">        System.out.println(hero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">Hero&#123;name=<span class="string">'萧峰'</span>, skillMain=<span class="string">'降龙十八掌'</span>, skill1=<span class="string">'打狗棒法'</span>, skill2=<span class="string">'少林武学'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看出，本文只是用了传统构建者模式的变种。这也是平时项目开发中遇到常用的方式了，继续练习～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>类加载器和双亲委派机制</title>
    <link href="http://yoursite.com/2020/08/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/22/类加载器与双亲委派机制/</id>
    <published>2020-08-22T07:52:55.000Z</published>
    <updated>2021-01-21T09:06:46.210Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p><strong>加载</strong><br>在硬盘上查找通过I/O读取字节码文件,生成类的二进制数据（.class文件）</p><p><strong>验证</strong><br>校验生成的字节码文件的正确性,例如字节码是否是”cafe babe”开头</p><p><strong>准备</strong><br>给类的静态变量分配内存,并赋予默认值，例如int 默认0,boolean默认false,对象为null.</p><p><strong>解析</strong><br>符号引用转化为直接引用</p><p><strong>初始化</strong><br>对类的静态变量初始化为指定的值,执行静态代码块</p><p><img src="https://github.com/geyou1995/picture/blob/master/jvm.png?raw=true" alt=""></p><p>注：类被加载到方法区中主要包含 <strong>运行时常量、类型信息、字段信息、方法信息、类加载器的引用（这个类到类加载器实例等引用）、对应classs实例的引用（类加载器在加载类信息放到方法区后，会创建一个对应的class类型的对象放到堆中）</strong>等信息.<br>还有主类运行过程中，如果使用到其他类，会逐步加载这些类。jar包和war包里的类都是懒加载。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><strong>引导类加载器(BootStrapClassLoader)</strong><br>负责加载支撑JVM运行的位于JRE的lib目录下的核心类库,比如rt.jar、charsets.jar等</p><p><strong>扩展类加载器(ExtClassLoader)</strong><br>负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的jar类包</p><p><strong>应用程序加载器(AppClassLoader)</strong><br>负载加载ClassPath路径下的类包,主要加载你自己写的那些类</p><p><strong>自定义类加载器</strong><br>负责加载用户自定义路径下的类包</p><p>如下代码分别输出BootStrapClassLoader、ExtClassLoader、AppClassLoader.<br>由于引导类加载器是C语言写的所以返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.class.getClassLoader());     System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</span><br><span class="line">System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure><p>类加载器之间关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"> ClassLoader extClassloader = appClassLoader.getParent();</span><br><span class="line"> ClassLoader bootstrapLoader = extClassloader.getParent();</span><br><span class="line">System.out.println(<span class="string">"the bootstrapLoader : "</span> + bootstrapLoader);</span><br><span class="line">System.out.println(<span class="string">"the extClassloader : "</span> + extClassloader);</span><br><span class="line">System.out.println(<span class="string">"the appClassLoader : "</span> + appClassLoader);</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line">the bootstrapLoader : <span class="keyword">null</span></span><br><span class="line">the extClassloader : sun.misc.Launcher$ExtClassLoader@<span class="number">776</span>ec8df</span><br><span class="line">the appClassLoader : sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure><p>如上代码可以看出JVM类加载器是有亲子层级结构的<br><strong>BootStrapClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader -&gt; 自定义类加载器</strong></p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p><img src="https://github.com/geyou1995/picture/blob/master/ljzq.png?raw=true" alt=""></p><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父类去完成，一次向上。只有当父类无法完成该加载时，子加载器才会尝试自己去加载该类。<br>这就是类加载的<strong>双亲委派机制</strong>：<strong>先找父亲加载，不行再由儿子自己加载</strong></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设现在要加载Math类，最先会找AppClassLoader加载，AppClassLoader会先判断在自己已经加载的类中有没有Math类,，有就直接返回,若没有AppClassLoader会委托ExtClassLoader加载，ExtClassLoader则又会委托BootStrapClassLoader加载，BootStrapClassLoader是顶层引导类加载器，则会在自己的类加载路径里找Math类，没有则退回BootStrapClassLoader，BootStrapClassLoader则会在自己的类加载路径里找Math类，也没有则最后退回到AppClassLoader类加载，最终在AppClassLoader的加载路径里找到Math类，最后就自己加载了。</p><h3 id="为什么要设计双亲委派机制？"><a href="#为什么要设计双亲委派机制？" class="headerlink" title="为什么要设计双亲委派机制？"></a>为什么要设计双亲委派机制？</h3><p><strong>沙箱安全机制</strong><br>这样可以防止核心类被篡改,比如rt.jar里有一个常用的java.lang.String.class类，这样你自己写的相同路径的java.lang.String.class类就不会被加载。</p><p><strong>避免类的重复加载</strong><br>当父亲已经加载过的类路径，子类就没有必要再去加载一次,保证被加载类的唯一性。</p><h3 id="全盘委托机制"><a href="#全盘委托机制" class="headerlink" title="全盘委托机制"></a>全盘委托机制</h3><p>如果一个类加载，这个类依赖的其他类，也会一起加载。</p><h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>自定义类加载器需要继承 java.lang.ClassLoader 类,这个类有两个核心方法，<br>loadClass(String, boolean)，实现了<strong>双亲委派机制</strong>。<br>findClass，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写</strong>findClass<strong>方法</strong>。<br>自定义类加载器默认父加载器是AppClassLoader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">           <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">           <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">               SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">               <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">               Class var5 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">               <span class="keyword">if</span> (var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.resolveClass(var5);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> var5;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(var1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           result = AccessController.doPrivileged(</span><br><span class="line">               <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                       String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</span><br><span class="line">                       Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                       <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                               <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, acc);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">           <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打破双亲委派机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设一种场景</span></span><br><span class="line"><span class="comment">// AppClassLoader下有一个类User,但是我们需要从自定义的目录下加载另一个User，两个类路径相同比如都是java.com.test.User.class</span></span><br><span class="line"><span class="comment">// 问题：由于双亲委派机制,那就会去加载AppClassLoader下的User类</span></span><br><span class="line"><span class="comment">// 解决：在自定义类加载器里重写loadClass方法,直接调用当前自定义类加载</span></span><br><span class="line">伪代码：</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// java.com.test目录下的类直接用当前类加载器加载</span></span><br><span class="line">                    <span class="keyword">if</span>(name.startsWith(<span class="string">"java.com.test"</span>))&#123;</span><br><span class="line">                        c = findClass(name);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 其他调用父类类加载器</span></span><br><span class="line">                        c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Syncronized关键字</title>
    <link href="http://yoursite.com/2020/08/15/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/15/Synchronized关键字/</id>
    <published>2020-08-15T09:03:55.000Z</published>
    <updated>2020-08-15T08:15:13.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Syncronized是JVM自带的关键字，主要用来解决线程并的原子性问题。Syncronized保证多个线程并发，在同一时刻只能有一个线程访问临界资源。<br>在多线程可能出现同时访问一个共享、可变资源的情况，这个资源叫临界资源（对象、变量、文件等）。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p><strong>静态方法</strong>：类锁,锁得是当前类的class对象<br><strong>普通方法</strong>：对象锁,锁得是当前实例对象<br><strong>同步代码块</strong>：锁得是括号里的对象</p><p><strong>注：一个类只有一个class,可能有多个实例对象</strong>. 若一个类有多个静态方法，可能会造成性能影响。</p><h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a><strong>历史</strong></h4><p>Synchronized在JDK1.6之前性能非常的低，使用的时候需要用户态与内核态的切换。<br>所以Doug li 写了AQS框架，实现了ReentranLock(java语言写的)，性能远远高于JVM自带的Syncronized。<br>之后甲骨文收购了java,觉得Syncronized干不过ReentranLock，为了颜面，在JDK1.6之后对Syncronized进行了优化，即锁的升级，目前Syncronized和ReentranLock的性能五五开。</p><h4 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a><strong>升级过程</strong></h4><p>锁得状态一共四种：无锁状态、偏向锁、轻量级锁、重量级锁。<br><strong>无锁状态</strong><br>当没有线程访问被syncronized修饰得方法或代码块时，就是无锁状态.</p><p><strong>偏向锁</strong><br>当第一个线程访问syncronized修饰的方法或代码块时,锁就进入了偏向模式,此时JAVA对象头里的Mark Word的结构也变为偏向锁结构.当其他线程请求锁的时候，会CAS替换JAVA对象头里的Mark Word里偏向锁的信息，替换成功就获取到锁资源。记录在Mark Word的里的线程再次请求锁资源，不需要做任何同步操作，省去大量锁申请操作，也就提升了性能。</p><p><strong>轻量级锁</strong><br>对于锁竞争激烈的场景，偏向锁就失效了。但是JVM并不会立刻升级为重量级锁,会先将Mark Word的结构变为轻量级锁的结构。轻量级锁适应的场景是线程交替执行代码块的场合，如果存在同一时间访问同一锁的场景，就会升级为重量级锁。</p><p><strong>重量级锁</strong><br>在轻量级锁失败后，jvm会先进行自选锁的操作。会先让当前想获取锁的线程做空循环,经过一定次数的循环，如果还得不到锁，就只能升级为重量级锁。</p><p><strong>注：锁得升级是不可逆的～</strong></p><h1 id="加锁信息"><a href="#加锁信息" class="headerlink" title="加锁信息"></a>加锁信息</h1><p>锁信息展示（32位虚拟机）</p><p><img src="https://github.com/geyou1995/picture/blob/master/syncronized.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发编程" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2020/08/15/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/15/Volatile关键字/</id>
    <published>2020-08-15T07:03:55.000Z</published>
    <updated>2020-08-15T08:46:41.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>volatile是Java虚拟机提供的轻量级的同步机制。<br>volatile能保证并发编程的两个问题：可见性和有序性。</p><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p><img src="https://github.com/geyou1995/picture/blob/master/jmm.png?raw=true" alt=""></p><p><strong>问题：</strong><br>从JMM模型可以知道，线程都是从总内存中加载变量到自己的工作内存，所以在多线程情况下，线程A获取了主内存的共享变量X，线程B也获取了变量X，并且将它修改。这时线程A无法立刻知道自己工作内存里的变量X与主线内存的变量X已经不同。</p><p><strong>解决：</strong><br>使用volatile修饰共享变量.</p><p><strong>缓存一致性原则MESI</strong><br>M 已修改状态 （加锁成功）<br>E  独占状态 （一个cpu读到）<br>S  共享状态（多个cpu读到）<br>I  失效状态 （收到其他cpu的消息）<br>当其他线程把主内存的值修改后，工作内存的缓存就被消除掉了。底层就是volatile 调用一个lock指令，修改值经过总线的时候会触发缓存一致性协议，将其他工作内存对应的缓存值变为失效状态，其他线程需要读取值需要重新去主内存读取。</p><h1 id="防指令重排"><a href="#防指令重排" class="headerlink" title="防指令重排"></a>防指令重排</h1><p><code></code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public  LazySingleton getInstance3() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;</span><br><span class="line">                    instance = new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>问题:</strong><br>上图是单例模式double check，LazySingleton的实例化需要经过<br><strong>分配空间 -&gt; 初始化 -&gt; 引用赋值</strong>,但是JVM底层可能会对其指令重排为<br><strong>分配空间 -&gt; 引用赋值 -&gt; 初始化</strong>，这样返回的instance可能只是赋值而未初始化，可能有npe问题。</p><p><strong>解决：</strong><br>使用volatile修饰该实例对象.</p><p><strong>内存屏障</strong><br>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。 总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发编程" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JMM模型</title>
    <link href="http://yoursite.com/2020/08/08/JMM%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/08/JMM模型/</id>
    <published>2020-08-08T10:42:55.000Z</published>
    <updated>2020-08-08T12:07:35.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是JMM模型？"><a href="#什么是JMM模型？" class="headerlink" title="什么是JMM模型？"></a>什么是JMM模型？</h1><p>JMM模型就是Java内存模型，是一种抽象的概念,并不真实存在。它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（实例字段、静态字段、构成数组对象的元素）的访问方式。<br>JVM运行程序的实体是线程，每当创建线程时JVM都会为其创建一个工作内存,每个线程都有自己独有的工作内存存储私有数据，但是JMM规定所有的变量都存储在主内存，主内存是共享区域，所有线程都可以访问，但是对变量的操作需要在各自的工作内存中操作，操作完后写回主内存,不能直接操作主内存中的变量。<br><img src="https://github.com/geyou1995/picture/blob/master/jmm.png?raw=true" alt=""></p><h1 id="数据同步八大原子操作"><a href="#数据同步八大原子操作" class="headerlink" title="数据同步八大原子操作"></a>数据同步八大原子操作</h1><p>关于主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现,JMM定义了以下8种操作完成。<br><strong>lock(锁定)</strong><br>作用与主内存的变量，把一个变量标记为一条线程独占状态。<br><strong>unlock(解锁)</strong><br>作用与主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。<br><strong>read(读取)</strong><br>将主内存的数据拷贝一份，便于随后的load使用<br><strong>load(载入)</strong><br>将read拷贝的数据加载到工作内存中<br><strong>use(使用)</strong><br>将工作内存中的数据变量给执行引擎进行逻辑修改<br><strong>assign(赋值)</strong><br>将执行引擎修改的值写回线程的工作内存<br><strong>store(存储)</strong><br>将工作内存的值拷贝一份出来<br><strong>write(写入)</strong><br>将store出来的值写回主内存</p><p>举例：假设线程A要修改主内存中的变量a = 0 -&gt; a=1<br>首先<strong>read</strong>将主内存的变量a=0拷贝一份，通过<strong>load</strong>加载到线程A的工作内存,然后<strong>use</strong>将工作内存中a=0交给执行引擎，执行引擎将a=0修改为a=1，<strong>assign</strong>将a=1写回工作内存，<strong>store</strong>将工作内存中的a=1拷贝一份出来，<strong>write</strong>将a=1写回主内存。</p><h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><p><strong>原子性</strong><br>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>通常使用 synchronized、Lock （ volatile不保证原子性）</p><p><strong>可见性</strong><br>当一个线程修改了某个共享变量 的值，其他线程是否能够马上得知这个修改的值。<br>volatile可以解决可见性（保证能否及时看到）。</p><p><strong>有序性</strong></p><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。<br>volatile可以防止指令重排。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发编程" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>MVCC机制</title>
    <link href="http://yoursite.com/2020/08/01/MVCC%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/01/MVCC机制/</id>
    <published>2020-08-01T13:53:55.000Z</published>
    <updated>2020-08-01T13:54:55.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MVCC概述"><a href="#MVCC概述" class="headerlink" title="MVCC概述"></a>MVCC概述</h1><p>Mysql在可重复读隔离级别下，同样的sql查询语句在一个事务里多次执行查询结果是相同的，就算其他事物对数据有修改也不会影响当前事物sql语句的查询结果。<br>这个隔离性就是靠MVCC（多版本并发控制）机制保证的，对一行数据的读和写两个操作默认不会通过加锁互斥来保证隔离性，避免了 频繁加锁。</p><h1 id="MVCC机制的实现"><a href="#MVCC机制的实现" class="headerlink" title="MVCC机制的实现"></a>MVCC机制的实现</h1><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo日志版本链是指一行数据被多个事务依次修改后，在每个事务修改完后，mysql会保留修改之前的数据在undo日志，并且用两个隐藏字段<strong>trx_id(事务id)和rollpoint（指针</strong>）把这些日志记录连接起来，形成一个历史记录版本链。如下图</p><p><img src="https://github.com/geyou1995/picture/blob/master/undo-1.jpg?raw=true" alt=""></p><p><strong>红色代表id=1的这行历史修改记录，蓝色代表最新数据。</strong><br>undo日志只有一份。</p><h3 id="Read-view-一致性视图"><a href="#Read-view-一致性视图" class="headerlink" title="Read-view 一致性视图"></a>Read-view 一致性视图</h3><p>每个事务开启都会维护一份自己的一致性视图。<br><strong>视图组成</strong><br>执行查询时所有未提交事务的id数组 + 已创建的最大事务id组成</p><p><strong>视图生成时机</strong><br>可重复读隔离级别，在第一次查询就会生成Read view。<br>读已提交隔离级别， 每次读都会生成一份最新的Read view</p><p><strong>版本对比举例</strong><br>事务里的任何sql查询结果需要从对应的版本链的最新数据开始逐条做对比得到最终的结果。<br>拿上图数据举例：假设事务A的视图为[200] 300，去查询id=1的数据<br>                                首先找到蓝色最新的数据,事务id是200,200在事务A的一致性视图中是属于未提交的，所以数据                                不可见，再找下一条事务id也是200,还是不可见，逐一比对，到事务id=100时，100不在事务A<br>                                的一致性视图里，说明是已提交的事务，所以最终得到的值就是’lilei2’。</p><h3 id="版本链对比规则"><a href="#版本链对比规则" class="headerlink" title="版本链对比规则"></a>版本链对比规则</h3><p><img src="https://github.com/geyou1995/picture/blob/master/undo-2.jpg?raw=true" alt=""></p><p>如果undo日志里的数据行trx_id(事务id)落在绿色部分，说明这个版本是已提交的事务生成的，所以数据可见。<br>如果undo日志里的数据行trx_id(事务id)落在红色部分，说明这个版本是由将来启动的事务生成，肯定不可见。<br>如果undo日志里的数据行trx_id(事务id)落在黄色部分，就需要判断了<br>    a.trx_id在视图数组里，说明这个版本是由还没提交的事务生成的，数据不可见。<br>    b.trx_id不在视图数组里,说明这个版本是已经提交的事务生成的,数据可见。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MVCC机制的实现就是通过<strong>read-view机制</strong>与<strong>undo版本链对比机制</strong>，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上不同版本的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql事务隔离级别与锁机制</title>
    <link href="http://yoursite.com/2020/08/01/Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/08/01/Mysql事务隔离级别与锁机制/</id>
    <published>2020-08-01T01:52:55.000Z</published>
    <updated>2020-08-01T04:26:07.902Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么要事务隔离与锁机制？"><a href="#为什么要事务隔离与锁机制？" class="headerlink" title="为什么要事务隔离与锁机制？"></a>为什么要事务隔离与锁机制？</h1><p>数据库一般都会并发执行多个事务，多个事务间可能会并发对相同的一批数据进行增删改查操作，就可能会造成一些事务隔离性问题，例如：脏写、脏读、不可重复读、幻读。</p><h1 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h1><p>事务是由一组SQL语句组成的逻辑处理单元,具有以下4个属性,简称事务的ACID属性。<br><strong><em>原子性</em></strong><br>执行事务操作，一系列对数据修改的操作，这些操作要么全部执行成功，要么全部失败。<br><strong><em>一致性</em></strong><br>事务开始到结束，数据必须保持一致性。<br>举例：银行转账操作，两个账户转钱。账户的总金额不会改变。<br><strong><em>隔离性</em></strong><br>多个事务之间相互隔离，互相不打扰。（这里可能有许多隔离性问题）<br><strong><em>永久性</em></strong><br>事务结束后，数据的修改会永久的保存在数据库里。</p><h1 id="事务隔离性问题"><a href="#事务隔离性问题" class="headerlink" title="事务隔离性问题"></a>事务隔离性问题</h1><p><strong><em>脏写</em></strong><br>假设同时开启事务A,B,选择数据表中同一行数据进行修改，A事务先完成了对数据的修改并提交了事务，之后B事务对同一数据也修改提交。最终数据库里的数据是事务B修改的数据。覆盖了A之前修改的数据。就造成了脏写。</p><p><strong><em>脏读</em></strong><br>两个事务A,B，事务B读到了事务A已经修改但是还没有提交的数据。<br>事务A对数据行进行了修改，但是还没有提交事务。这时事务B读到了A事务还没有提交的事务，还用这个数据去操作。如果A事务回滚了，那这个数据就是无效的。不符合一致性要求。</p><p><strong><em>不可重复读</em></strong><br>线程AB开启事务，A,B同时读到一行数据，A更新了这条数据，并提交了事务，B还未提交事务，重新去读这行数据，导致B一次事务里两次读到的数据不相同。</p><p><strong><em>幻读</em></strong><br>幻读类似不可重复读;不可重复读针对查询操作;幻读针对读是插入和删除操作。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>针对以上问题，Mysql数据库提供了一定的事务隔离级别机制来解决。</p><p><img src="https://github.com/geyou1995/picture/blob/master/shiwugeli.jpg?raw=true" alt=""></p><p>Mysql数据库默认的隔离级别是<strong>可重复读</strong>。</p><p><strong>查看当前数据库的事务隔离级别</strong>: show variables like ‘tx_isolation’;</p><p><strong>设置事务隔离级别</strong>：set tx_isolation=’REPEATABLE-READ’;</p><h1 id="MySql锁机制"><a href="#MySql锁机制" class="headerlink" title="MySql锁机制"></a>MySql锁机制</h1><h3 id="锁详解"><a href="#锁详解" class="headerlink" title="锁详解"></a>锁详解</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除了传统的计算资源（CPU、RAM、I/O等）竞争外，数据也是一种共享等资源。</p><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从性能上分</span><br><span class="line">乐观锁</span><br><span class="line">用版本号对比来实现，每次修改数据的时候会先比较读到数据的版本号和最新的版本号是否一致，一致就可以修改，否则不行。乐观锁实际上是不加锁的。</span><br><span class="line"></span><br><span class="line">悲观锁</span><br><span class="line">对数据进行加锁，访问资源需要竞争锁。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从对数据库操作的类型分</span><br><span class="line">分为读锁写锁，都是悲观锁。**读锁会阻塞写，写锁会阻塞读和写。</span><br><span class="line"></span><br><span class="line">读锁</span><br><span class="line">读锁也称共享锁，S锁（share），针对同一份数据，多个读操作可以进行而不会相互影响。</span><br><span class="line"></span><br><span class="line">写锁</span><br><span class="line">写锁也称排他锁，X锁（eXclusive），针对同一份数据，写操作没有完成，其他事物的读/写都会堵塞。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从对数据操作的粒度分</span><br><span class="line">MyISAM是表锁。InnoDB查询的时候有mvcc机制不会加锁，但是更新、插入、删除操作会加行锁。</span><br><span class="line"></span><br><span class="line">表锁</span><br><span class="line">每次操作都会锁住整张表。找到表就可以加锁，开销小，加锁快。锁的粒度大，不会出现死锁。发生锁冲突的概率最高，**一般用在整表数据的迁移**。</span><br><span class="line"></span><br><span class="line">行锁</span><br><span class="line">每次操作锁住操作涉及到的数据行。需要找到对应的数据行才能加锁，开销大，加锁慢。锁的粒度小，会出现死锁。</span><br></pre></td></tr></table></figure><h1 id="锁和事务隔离级别"><a href="#锁和事务隔离级别" class="headerlink" title="锁和事务隔离级别"></a>锁和事务隔离级别</h1><h3 id="隔离级别设置"><a href="#隔离级别设置" class="headerlink" title="隔离级别设置"></a>隔离级别设置</h3><p>​    <strong>读未提交</strong>  set tx_isolation=’read-uncommitted’;<br>​    <strong>读已提交</strong>  set tx_isolation=’read-committed’;<br>​    <strong>可重复读</strong>  set tx_isolation=’repeatable-read’;<br>​    <strong>串行化</strong>     set tx_isolation=’serializable’;</p><h3 id="锁和事务隔离级别-1"><a href="#锁和事务隔离级别-1" class="headerlink" title="锁和事务隔离级别"></a>锁和事务隔离级别</h3><p><strong><em>可重复读</em></strong><br>就是假设某一事务对数据行就行了<strong>更新操作</strong>就会对涉及到的数据行加行锁。<br><strong><em>序列化</em></strong><br>只要开启了事务，之后的操作，不管<strong>查询操作</strong>还是<strong>更新操作</strong>，对涉及到的数据行全部加行锁，所以性能差。<br><strong><em>间隙锁</em></strong><br>因为mysql的默认隔离级别是可重复读，会有幻读的问题。可以引入间隙锁在某些情况下可以解决该问题。</p><p><img src="https://github.com/geyou1995/picture/blob/master/jxs.jpg?raw=true" alt=""></p><p>如上表所示间隙就有id为 （3，10）、(10,20)、(20,正无穷)<br>防止幻读就是需要被涉及的数据行加锁<br>update account set name = ‘萧峰666’ where id &gt; 8 and id &lt;18;<br>上述sql会对id值有在（3，10）区间的，也有在（10，20）区间的，所以最终被锁定的区间是（3，20],其他事务没法在这区间插入或修改任何数据。<br><strong>间隙锁只在可重复读隔离级别下才生效。</strong></p><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><ul><li>尽可能让所有数据检索都通过索引完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，减小锁的范围。</li><li>尽可能减小检索条件范围，避免间隙锁。</li><li>尽量控制事务大小，减小锁定资源量和时间长度，涉及事务加锁的sql放在事务最后执行。</li><li>尽可能低级别事务隔离</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://yoursite.com/2020/07/20/SQL%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/07/20/SQL优化/</id>
    <published>2020-07-20T11:52:55.000Z</published>
    <updated>2020-07-20T11:52:09.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开发过程中,经常会碰到一些慢sql，性能低，执行时间太长、等待时间太长、sql语句欠佳、索引失效、服务器参数设置不合理需要我们对sql进行适当的优化，所以需要了解如何去优化哈.下面整理了一些mysql的sql结构以及该如何去优化sql。</p><h1 id="mysql的逻辑分层原理"><a href="#mysql的逻辑分层原理" class="headerlink" title="mysql的逻辑分层原理"></a>mysql的逻辑分层原理</h1><ul><li><p>连接层 </p><p>提供与客户端连接的服务</p></li><li><p>服务层 </p><p>提供各种用户使用的接口（增删改查）,提供sql优化器</p></li><li><p>引擎层</p><p>提供各种存储数据的方式，例如默认的InnoDB（事务优先，行锁）、MyISAM(效率优先，表锁)等</p></li><li><p>存储层</p><p>存储最终的数据</p><blockquote><p>sql 编写过程<br>select…from…join…on…where…group by…having…order by…limit..<br>sql 解析过程<br>from…on..join…where…group by…having..select…order by…limit..</p></blockquote></li></ul><h1 id="核心是优化索引"><a href="#核心是优化索引" class="headerlink" title="核心是优化索引"></a>核心是优化索引</h1><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>帮助mysql高效获取数据的数据结构，索引是数据结构.</p><h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><p>​     主键索引：与唯一基本相同（主键不能为null，唯一可以为null）<br>​     单值索引：单列（一个表可以有多个单值索引）<br>     唯一索引：不能重复（例如id）<br>     复合索引：多个列构成的索引s </p><h5 id="索引优势"><a href="#索引优势" class="headerlink" title="索引优势"></a>索引优势</h5><p>提高查询效率（降低IO的使用率)<br>降低CPU使用率（索引是排好序的结构，可以直接用）</p><h5 id="索引弊端"><a href="#索引弊端" class="headerlink" title="索引弊端"></a>索引弊端</h5><p>索引本身很大，可以存放在内存/硬盘<br>不是所有情况使用：a.少量数据 b.频繁更新的字段 c.很少使用的字段<br>索引会提高查的效率，会降低增删改的效率</p><h3 id="SQL性能问题"><a href="#SQL性能问题" class="headerlink" title="SQL性能问题"></a>SQL性能问题</h3><h5 id="分析SQL的执行计划：EXPLAIN-SQL"><a href="#分析SQL的执行计划：EXPLAIN-SQL" class="headerlink" title="分析SQL的执行计划：EXPLAIN+SQL"></a>分析SQL的执行计划：EXPLAIN+SQL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id: 编号</span><br><span class="line">id值相同，从上往下顺序执行(表的执行顺序会因为数量改变而改变，原因：笛卡尔积，数据小的表优先查询)，id值不同：越大越优先查询（在查询时先查内层再查外层）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select_type: 查询类型</span><br><span class="line">PRIMARY:主查询</span><br><span class="line">SUBQUERY:子查询</span><br><span class="line">SIMPLE:简单查询（不包含主、子查询）</span><br><span class="line">DERIVER：衍生查询（使用到临时表,From后面的查询）</span><br><span class="line">UNION：在from子查询中table1 union table2（指的table2）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table: 查询的表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type: 索引类型 system-&gt;const-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all（越往左效率越高）</span><br><span class="line">Null:MySql底层会对查询进行优化,直接查询常量</span><br><span class="line">system:查询得表里只有一条数据行</span><br><span class="line">const:结果集只有一条数据 （通过主键索引和唯一索引查询）</span><br><span class="line">eq_ref:表关联用主键或唯一键</span><br><span class="line">ref:表查询没有用到主键或唯一，但是用到了普通索引，可能返回匹配的多条数据或0条。（从索引的根节点开始找）</span><br><span class="line">range:检索指定范围的行，使用一个索引来选择行（between,&lt;,&gt;,=）</span><br><span class="line">index:扫描所有的索引（叶子结点全索引扫描），一般去扫二级索引，因为主键索引太大</span><br><span class="line">all:全表读取</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">possible_keys: 预测可能使用的索引</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key: 实际使用的索引</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">key_len:实际使用的索引的长度（作用：判断复合索引是否完全被使用）</span><br><span class="line">字符串</span><br><span class="line">char(n):3n字节长度</span><br><span class="line">varchar(n):若是utf-8，长度为3n+2 (加的2是存储字符串长度的)</span><br><span class="line">数值类型</span><br><span class="line">thinyint:1字节</span><br><span class="line">smallint:2字节</span><br><span class="line">int:4字节</span><br><span class="line">bigint:8字节</span><br><span class="line">时间类型：</span><br><span class="line">date:3字节</span><br><span class="line">timestamp:4字节</span><br><span class="line">datetime:8字节</span><br><span class="line">*如果字段允许为null，还需要加1个字节，记录是否为NULL。</span><br><span class="line">*例如：联合索引 name age address</span><br><span class="line">name varchar(20) 不为null</span><br><span class="line">age int  可为null</span><br><span class="line">address char(30) 可为null</span><br><span class="line">则key_len = （20*3+2） + （4+1）+（30*3+1） = 158</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: 联合索引关联的字段（可能是个常量值const）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const:常量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows:可能检测到的行数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Extra:展示额外信息 </span><br><span class="line">性能从好到坏:using index &gt; using where &gt; using temporary | using filesort</span><br><span class="line"></span><br><span class="line">using index: 索引覆盖，不读取原文件，只从索引文件中获取（不需要回表查询）</span><br><span class="line">（覆盖索引：使用联合索引查找没有回表查）</span><br><span class="line"></span><br><span class="line">using where: 需要回表查询(需要查询原文件)</span><br><span class="line"></span><br><span class="line">using filesort（性能损耗大）常见于order by，没有索引需要放在临时表里比较</span><br><span class="line"></span><br><span class="line">using temporary（性能损耗大，额外多使用临时表）常见于distinct 去重，没有索引需要放在临时表里比较</span><br></pre></td></tr></table></figure><h5 id="SQL优化器可能干扰我们的优化"><a href="#SQL优化器可能干扰我们的优化" class="headerlink" title="SQL优化器可能干扰我们的优化"></a>SQL优化器可能干扰我们的优化</h5><p>SQL的优化主要通过上述的属性去优化，但是SQL优化器可能会干扰我们的优化.</p><h3 id="常用SQL优化方法"><a href="#常用SQL优化方法" class="headerlink" title="常用SQL优化方法"></a>常用SQL优化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.加索引</span><br><span class="line">a.索引不能跨列，保持索引的定义和使用一致（根据sql实际解析的顺序，调整索引的顺序，从from开始节气解析）；</span><br><span class="line">b.索引要逐步优化</span><br><span class="line">c.范围查询in可能使索引失效，放到where条件最后面</span><br><span class="line"></span><br><span class="line">2. 多表</span><br><span class="line">   a.小表驱动大表</span><br><span class="line">   b.索引建立在经常查询的字段</span><br><span class="line">   </span><br><span class="line">3. 避免索引失效的一些原则</span><br><span class="line">   a.复合索引，不要跨列或无序使用（最佳左前缀）</span><br><span class="line">   b.复合索引，尽量使用全索引匹配</span><br><span class="line">   c.不要在索引上进行任何操作（计算，函数，类型转换），否则索引失效    </span><br><span class="line">   d.复合索引不能使用不等于（!=，&lt;&gt;）或is null，否则索引失效</span><br><span class="line">   e.尽量使用索引覆盖（using index）</span><br><span class="line">   f.like尽量已“常量”开头，不用以“%”开头，否则索引失效（如果必须使用，可以用索引覆盖补救一部分）</span><br><span class="line">   g.尽量不要使用类型转换（显式，隐式），否则索引失效</span><br><span class="line">   h.尽量不要使用or，否则索引失效</span><br><span class="line">   注：双层循环：（外层小内层大）性能比（外层大内层小）好</span><br></pre></td></tr></table></figure><h3 id="MySql锁机制"><a href="#MySql锁机制" class="headerlink" title="MySql锁机制"></a>MySql锁机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解决因资源共享而造成的并发问题</span><br><span class="line">- 操作类型分：</span><br><span class="line">1.读锁（共享锁）:对同一个数据，多个读操作可以同时进行（买衣服的看）</span><br><span class="line">2.写锁（互斥锁）:如果当前操作没有完毕，则无法进行读写操作（买衣服一系列操作）</span><br><span class="line">- 操作范围分：</span><br><span class="line">1.表锁：一次性对一张表整体加锁（myISAM存储引擎），开销小，加锁快，锁的范围大，无死锁，容易发生锁冲突</span><br><span class="line">2.行锁：一次性对一行数据加锁（innoDB存储引擎），开销大，加锁慢，容易出现死锁，不易发生锁冲突</span><br><span class="line">3.页锁</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql索引数据结构</title>
    <link href="http://yoursite.com/2020/07/18/Mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/07/18/Mysql索引数据结构/</id>
    <published>2020-07-18T06:33:55.000Z</published>
    <updated>2020-07-18T06:54:02.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h1><p>索引是帮助Mysql高效获取排好序的数据结构。</p><h1 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h1><p>数据库的数据都是存放在本地磁盘里的，每次查询数据都会进行磁盘IO读取数据，将读到的数据加载到内存中比较，Mysql InnoDB默认一次磁盘IO的大小是16K.</p><p>调用以下命令查询</p><p><code>SHOW GLOBAL STATUS like &#39;Innodb_page_size&#39;;</code></p><h1 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h1><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>首先看下图</p><p><img src="https://github.com/geyou1995/picture/blob/master/1.png?raw=true" alt=""></p><p>假设需要根据字段col2查询col2=22的数据，select * from table where col2 = 22。</p><h5 id="无索引"><a href="#无索引" class="headerlink" title="无索引"></a>无索引</h5><p>全表查，从上至下</p><p>34 -&gt;77 -&gt;55 -&gt;91 -&gt;<font color="#DC143C">22</font></p><p>每一次的查询都会进行一次磁盘IO，可以看出上述操作一共进行了5次磁盘IO才找到了col2=22的数据行。</p><h5 id="使用二叉树索引"><a href="#使用二叉树索引" class="headerlink" title="使用二叉树索引"></a>使用二叉树索引</h5><p>看上图右边的树，就是为上述col2字段建立的一个二叉树索引，我们都知道二叉树索引是大的元素放右边，小的元素放左边。</p><p>根据索引的查询22，首先会查询到34，判断22&lt;34就会去树的左边结点，再次查询就找到22了，所以上述查询采用索引只用了2次磁盘IO</p><h5 id="注：二叉树存储的-key是索引值，value是该索引值对应的数据行地址。"><a href="#注：二叉树存储的-key是索引值，value是该索引值对应的数据行地址。" class="headerlink" title="注：二叉树存储的 key是索引值，value是该索引值对应的数据行地址。"></a>注：二叉树存储的 key是索引值，value是该索引值对应的数据行地址。</h5><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>根据二叉树结点存放的特点，如果给Col1字段建立二叉树索引，就是如下图所示，形成一个单项的链表结构，这样的查询和全表查询没有什么区别。</p><p><img src="https://github.com/geyou1995/picture/blob/master/9.jpg?raw=true" alt=""></p><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p>为了避免上述二叉树的缺点，进而引入了一种新的数据结构那就是平衡二叉树。</p><p>它有一个非常严格的要求：必须保证左右子树高度差不超过1.</p><p><img src="https://github.com/geyou1995/picture/blob/master/10.jpg?raw=true" alt=""></p><p>它虽然避免了二叉树变成链表结构的尴尬，但是如果数据量非常非常大的情况下，树的层级就会非常的高，这样就会进行多次的磁盘IO,效率就会非常低下，所以AVL也不是Mysql InnoDB的索引结构。</p><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><p>BTree做了改进就是它每个结点不止一个元素,每个元素不重复，并且每个结点中的元素从左到右依次递增排序。每个结点都有索引和数据。</p><p><img src="https://github.com/geyou1995/picture/blob/master/2.png?raw=true" alt=""></p><p>还是回到原来的问题，当数据量很大的时候，树的层级还是会很深，又会进行多次磁盘IO，效率就低下了。而且查询不稳定，可能第一次IO就查到数据了，也可能在最后一层叶子结点查询到数据。所以它也不是Mysql InnoDB的索引结构。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://github.com/geyou1995/picture/blob/master/3.png?raw=true" alt=""></p><p>比较BTree 和B+Tree的结构图可以看出，B+Tree相较于BTree：</p><h5 id="数据全都存放在叶子结点。"><a href="#数据全都存放在叶子结点。" class="headerlink" title="数据全都存放在叶子结点。"></a>数据全都存放在叶子结点。</h5><p>这样可以保证每次磁盘IO读到的索引元素更多，降低树的高度，增加命中率。</p><p>还可以可以保证查询效率的稳定。</p><h5 id="叶子结点之间有结点指针"><a href="#叶子结点之间有结点指针" class="headerlink" title="叶子结点之间有结点指针"></a>叶子结点之间有结点指针</h5><p>因为索引都是排好序的，这样可以适用于范围查询，提高效率。</p><h5 id="假设下可以存储的索引数量"><a href="#假设下可以存储的索引数量" class="headerlink" title="假设下可以存储的索引数量"></a>假设下可以存储的索引数量</h5><p>一次IO是16K,假设索引是一个bigint(8B),上图空白格表示下一个磁盘地址（6B）</p><p>根节点第一次IO大概：16*1024/(8+6) = 1170</p><p>第二次IO:1170</p><p>叶子结点中有数据行：假设一行数据1KB，一次IO 16K所以可以放16</p><p>这棵树放满大约能放的索引是：1170 <em> 1170</em>  16 = 21902400（2千多万）</p><h5 id="综上：3层的B-Tree结构可以存放2千多万的索引数据-所以Mysql的InnoDB底层索引结构就是B-Tree-一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO"><a href="#综上：3层的B-Tree结构可以存放2千多万的索引数据-所以Mysql的InnoDB底层索引结构就是B-Tree-一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO" class="headerlink" title="综上：3层的B+Tree结构可以存放2千多万的索引数据;所以Mysql的InnoDB底层索引结构就是B+Tree. 一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO."></a>综上：3层的B+Tree结构可以存放2千多万的索引数据;所以Mysql的InnoDB底层索引结构就是B+Tree. 一些高版本的mysql会将根节点直接加载到内存，查询到时候可以免去第一次磁盘IO.</h5><h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><p><img src="https://github.com/geyou1995/picture/blob/master/4.png?raw=true" alt=""></p><p>Hash结构底层是数组和链表</p><h5 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h5><p>将索引的值进行hash运算，算出该元素所在的桶的位置，然后判断该位置是否有元素，没有就直接塞进去，有的话说明hash冲突，用链表连接。</p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>查询数据的时候也先将值进行hash运算，找到具体的位置查找。类似于HashMap的底层原理吧。</p><h5 id="综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。"><a href="#综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。" class="headerlink" title="综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。"></a>综上：hash运算非常的开，所以hash结构查询效率非常快，但是它无法支持范围查询。</h5><h1 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h1><p><img src="https://github.com/geyou1995/picture/blob/master/5.png?raw=true" alt=""></p><p>上述是一行一行的数据…</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p><img src="https://github.com/geyou1995/picture/blob/master/6.png?raw=true" alt=""></p><p>聚集索引：叶子结点包含数据的，索引和数据放在一起的。</p><p>聚集索引的确定（依次选择）：B+tree默认首先获取主键 -&gt; 不为null的唯一键列 -&gt; 默认生成一个id行</p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p><img src="https://github.com/geyou1995/picture/blob/master/7.png?raw=true" alt=""></p><p>非聚集索引：叶子结点不包含数据的，放的是主键的id。</p><p>这样做是为了节约存储空间；也保证一致性，数据行修改了不用两棵树都去修改。</p><h1 id="InnoDB-表建立主键，主键通常都用整型且自增的原因"><a href="#InnoDB-表建立主键，主键通常都用整型且自增的原因" class="headerlink" title="InnoDB 表建立主键，主键通常都用整型且自增的原因"></a>InnoDB 表建立主键，主键通常都用整型且自增的原因</h1><p>用整型的原因：索引用整型比较大小快。</p><p>自增的原因：因为叶子结点都是排好序的，如果不自增，可能会导致树结构的自平衡，影响效率。</p><h1 id="联合索引-复合索引为什么是最左前缀原理？"><a href="#联合索引-复合索引为什么是最左前缀原理？" class="headerlink" title="联合索引/复合索引为什么是最左前缀原理？"></a>联合索引/复合索引为什么是最左前缀原理？</h1><p>首先看下联合索引的索引结构图</p><p><img src="https://github.com/geyou1995/picture/blob/master/8.png?raw=true" alt=""></p><p>可以看到联合索引的顺序是：name、age、position</p><p>因为索引都是排好序的，按上面的结构，必须先找到name,</p><p>假设是Bill，在Bill的基础上，age是排好序的</p><p>不然人工直接找age，它就是没有顺序的</p><h5 id="综上：联合索引是一级一级查询的，所以按最左前缀原理。"><a href="#综上：联合索引是一级一级查询的，所以按最左前缀原理。" class="headerlink" title="综上：联合索引是一级一级查询的，所以按最左前缀原理。"></a>综上：联合索引是一级一级查询的，所以按最左前缀原理。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Idea 查看源码</title>
    <link href="http://yoursite.com/2020/07/15/Idea%E5%A6%82%E4%BD%95%E7%9C%8B%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2020/07/15/Idea如何看源码/</id>
    <published>2020-07-15T07:34:45.000Z</published>
    <updated>2020-07-15T07:45:59.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>平时开发代码，避开不了需要查看源码，例如JDK、spring的源码那都是精华，非常值我们去推敲学习的，但是在Idea直接点开下载源码是不能在上面做笔记的，所以希望看源码的时候可以把自己理解的内容写注释，方便下次观看立即能回忆起来。而且能够Debug调试。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>就拿JDK的源码为例。<br>1.找到JDK的zip包然后解压<br>2.打开Idea的SKDs,在sourcepath配置解压好的jdk包<br><img src="https://github.com/geyou1995/picture/blob/master/1594798922200.jpg?raw=true" alt=""><br>3.最后就能在源码写注释了(以HashMap源码为例)<br><img src="https://github.com/geyou1995/picture/blob/master/1594799091404.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://yoursite.com/2020/07/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/15/设计模式-单例模式/</id>
    <published>2020-07-15T07:30:55.000Z</published>
    <updated>2020-08-02T08:54:59.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单例模式：保证一个类仅有一个实例，并提供一个全局访问它的全局访问点。<br>应用场景:  线程池、数据库连接等。</p><h2 id="单例实现"><a href="#单例实现" class="headerlink" title="单例实现"></a>单例实现</h2><p>实例单例模式主要分为两种：懒汉式和饿汉式。<br>1.构造方法私有化。<br>2.提供一个全局访问点.</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 自行创建实例</span><br><span class="line">    private static HungrySingleton instance = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过该函数向整个系统提供获取方法</span><br><span class="line">    public HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用static修饰了成员变量instance,这样类初始化的过程中被收集进类构造器即“clinit”方法中，在多线程下JVM会保证只有一个线程会执行clinit方法，其他会阻塞等待。等到唯一的一次clinit方法执行完成，其他线程将不会再执行该方法，转而执行自己的代码。也就是说static修饰的成员变量instatnce只会被初始化一次。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以保证多线程情况下实例的唯一性，getInstatce方法直接返回实例，性能非常高。<br>缺点：在类成员变量比较多活比较大的情况下，可能在没有使用类的时候一直占用着堆内存，造成内存的浪费。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉模式就是为了避免直接加载类对象造成堆内存浪费的一种单例模式。</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1.原始方法</span><br><span class="line">    // 这样虽然避免了类加载提前创建实例，但是在多线程运行下，就会出现多个实例创建的情况。</span><br><span class="line">    public LazySingleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象 -- 多个线程会创建多个对象</span><br><span class="line">            instance = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    // 2.饿汉式 + synchronized</span><br><span class="line">    // 这样虽然可以避免多线程问题，但是同步锁会增加锁竞争，每次获取实例对象都会通过getInstance方法，带来系统性能开销，导致系统性能下降。</span><br><span class="line">    public synchronized LazySingleton getInstance1() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象</span><br><span class="line">            instance = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 3.饿汉式 + synchronized 减小锁的粒度</span><br><span class="line">    // 在创建实例对象的时候加同步锁，但是依然存在可能创建多个实例，因为在进入null判断的时候可能有多个线程</span><br><span class="line">    public  LazySingleton getInstance2() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁  -- 这里可能多个线程等待，最终也会导致多个对象创建</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                instance = new LazySingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private volatile LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    // 4.饿汉式 + synchronized double check</span><br><span class="line">    // 当线程拿到锁准备创建对象时，再判断一次实例是否已经创建。这种方法被称为Double-Check,它可以大大提高懒汉模式性能。</span><br><span class="line">    // 但是也不能保证万无一失。以防万一变量添加volatile 防止指令重排序。</span><br><span class="line">    // 创建一个对象底层字节码的执行顺序是1.分配空间 2.初始化 3. 引用赋值 </span><br><span class="line">     -&gt; 指令重排后可能变为1.分配空间 2.引用赋值  3.初始化 </span><br><span class="line">     当第一个线程引用赋值后，第二个线程进来发现instance不为null,就直接返回使用，但是这时instance可能还 没有初始化，所以可能会npe;</span><br><span class="line">    public  LazySingleton getInstance3() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;</span><br><span class="line">                    instance = new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过内部类实现</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 4.通过内部类实现</span><br><span class="line">    // 通过饿汉式可以知道通关键字static修饰变量，在类初始化加载的时候只有一个线程可以执行clinit方法，其他会阻塞等待。</span><br><span class="line">    // 所以可以利用这个特性在Singleton类中创建一个内部类来实现。内部类的静态成员变量是懒加载，并且内部类可以调外部类的私有构造方法。</span><br><span class="line">    public static class InnerSingleton &#123;</span><br><span class="line">        private static LazySingleton instance = new LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public LazySingleton getInstance4() &#123;</span><br><span class="line">        return InnerSingleton.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.枚举类(核心就是内部类)</span><br></pre></td></tr></table></figure><h3 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private volatile LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.通过内部类实现</span><br><span class="line">    // 通过饿汉式可以知道通关键字static修饰变量，在类初始化加载的时候只有一个线程可以执行clinit方法，其他会阻塞等待。</span><br><span class="line">    // 所以可以利用这个特性在Singleton类中创建一个内部类来实现。内部类的静态成员变量是懒加载，并且内部类可以调外部类的私有构造方法。</span><br><span class="line">    public static class InnerSingleton &#123;</span><br><span class="line">        private static LazySingleton instance = new LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public LazySingleton getInstance4() &#123;</span><br><span class="line">        return InnerSingleton.instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h3><p>枚举类(核心就是内部类)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实单例模式的本质就是控制对象实例的个数。懒汉式和饿汉式各有各的优缺点，可以适当根据应用场景使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Idea永久破解</title>
    <link href="http://yoursite.com/2020/07/15/Idea%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/15/Idea永久破解/</id>
    <published>2020-07-15T07:00:45.000Z</published>
    <updated>2020-07-15T07:32:16.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>最近刚好换了工作，要换台电脑工作了，安装了Idea,忘记了原来Idea破解的方法，于是网上查找，果然好记性不如烂笔头，决定总结一下，记录下来。就是把idea激活，不需要使用有期限的激活码.</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.首先下载jetbrains-agent.jar<br>2.在Idea里创建idea.vmoptions<br><img src="https://github.com/geyou1995/picture/blob/master/idea%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB.jpg?raw=true" alt=""><br>3.在idea.vmoptions 填写jetbrains-agent.jar的文件路径<br><img src="https://github.com/geyou1995/picture/blob/master/1594798247034.jpg?raw=true" alt=""><br>4.填写 <a href="http://fls.jetbrains-agent.com" target="_blank" rel="noopener">http://fls.jetbrains-agent.com</a> 最后激活<br><img src="https://github.com/geyou1995/picture/blob/master/1594797538198.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>springBoot入门</title>
    <link href="http://yoursite.com/2019/05/27/springBoot%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/05/27/springBoot入门/</id>
    <published>2019-05-27T12:46:55.000Z</published>
    <updated>2020-07-15T06:31:45.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>为基于spring开发提供更快的入门体检.</li><li>开箱即用.</li><li>springBoot不是对spring的增强，而是提供了更快的使用方式</li><li>嵌入式服务器，健康检测，安全、外部配置等非功能性特性.</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>起步依赖<br>将具备某一功能的坐标打包到一起，提供默认的功能</li><li>自动配置<br>自动帮你配置某个对象需要的配置,例如tomcat的端口号默认8080等</li></ol><h2 id="必须引用的坐标"><a href="#必须引用的坐标" class="headerlink" title="必须引用的坐标"></a>必须引用的坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">父级依赖</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支持web的模块</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>springBoot是基于约定的所有很多配置都有默认值，若想使用自己的配置，可以使用配置文件（properties,yml).</p><h4 id="1-properties"><a href="#1-properties" class="headerlink" title="1. properties"></a>1. properties</h4><p>key = value </p><h4 id="2-yml（yaml）"><a href="#2-yml（yaml）" class="headerlink" title="2. yml（yaml）"></a>2. yml（yaml）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.普通数据的配置（冒号后需要空格）</span><br><span class="line">name: zhangsan </span><br><span class="line">2. 对象的配置(同一级别的缩进保持一致)</span><br><span class="line">person:</span><br><span class="line">name: zhangsan</span><br><span class="line">age: 18</span><br><span class="line">address: hangzhou</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">port: 8088</span><br><span class="line">3. 行内对象配置(不常用)</span><br><span class="line">person： &#123;name: zhangsan,age: 18, address: hangzhou&#125;</span><br><span class="line"></span><br><span class="line">4.配置数据集合</span><br><span class="line">city:</span><br><span class="line">- beijing</span><br><span class="line">- hangzhou</span><br><span class="line">- taizhou</span><br><span class="line">- zhoushan</span><br><span class="line">city：[beijing,hangzhou,taizhou]</span><br><span class="line"></span><br><span class="line">5. 配置对象集合数据</span><br><span class="line">student:</span><br><span class="line">-name: zhangsan</span><br><span class="line">age: 18</span><br><span class="line">address: hangzhou</span><br><span class="line">-name: lisi</span><br><span class="line">age: 16</span><br><span class="line">address: taizhou</span><br><span class="line">6. map配置</span><br><span class="line">map:</span><br><span class="line">key1: value1</span><br><span class="line">key2: value2</span><br></pre></td></tr></table></figure></code></pre><h2 id="加载配置文件的顺序"><a href="#加载配置文件的顺序" class="headerlink" title="加载配置文件的顺序"></a>加载配置文件的顺序</h2><p>springBoot一些数据会有默认值，如果你想更改则可以使用配置来覆盖，配置文件后加载的也会覆盖之前加载的.它会先加载yml，最后加载properties.<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（spring-boot-starter-parent）</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">&lt;excludes&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.yml&lt;/exclude&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.yaml&lt;/exclude&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.properties&lt;/exclude&gt;</span><br><span class="line">&lt;/excludes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure></p><h2 id="在业务代码中获取配置信息"><a href="#在业务代码中获取配置信息" class="headerlink" title="在业务代码中获取配置信息"></a>在业务代码中获取配置信息</h2><p>有如下两种方式：</p><ol><li><p>@value(“${name}”)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;oss.endPoint&#125;&quot;)</span><br><span class="line">private String endPoint;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oss:</span><br><span class="line">endPoint: oss-cn-hangzhou-internal.aliyuncs.com</span><br><span class="line">accessKeyId: ALIYUN_ACCESS_KEY</span><br><span class="line">accessKeySecret: ALIYUN_SECRET_KEY</span><br><span class="line">defaultBucket: salary-prod</span><br></pre></td></tr></table></figure></code></pre></li><li><p>@ConfigurationProperties(prefix =”person”)<br> 需要set,get方法</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">private String clusterNodes;</span><br><span class="line"></span><br><span class="line">private String redisHost;</span><br><span class="line"></span><br><span class="line">private int redisPort;</span><br><span class="line"></span><br><span class="line">private String redisPasswd;</span><br><span class="line"></span><br><span class="line">set()..</span><br><span class="line">get()..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">clusterNodes:</span><br><span class="line">redisHost: r-bp1d75e29eop202ee4.redis.rds.aliyuncs.com</span><br><span class="line">redisPort: 6377</span><br><span class="line">redisPasswd: REDIS_PASSWORD</span><br><span class="line">timeout: 3000</span><br><span class="line">database: 0</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>excel读写及Zip打包下载</title>
    <link href="http://yoursite.com/2019/01/02/excel%E8%AF%BB%E5%86%99%E5%8F%8AZIp%E6%89%93%E5%8C%85%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/01/02/excel读写及ZIp打包下载/</id>
    <published>2019-01-02T09:41:55.000Z</published>
    <updated>2020-07-15T06:38:34.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>针对2019个税专项附加扣除做的需求：帮助Hr快速收集员工申报信息，及处理信息，由员工填写表单提交信息，对信息进行处理写入到个税局提供的个税专项附加扣除信息excel模版，最后ZIP打包导出.</p><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>首先需要收集处理员工数据，将excel模版放在服务器上，导出时在服务器上创建一个临时文件夹，读取模版excel文件,将数据循环写入excel模版中(一个员工对应一张excel),将写好数据的excel文件流依次写入该文件夹中，接着打包下载该文件夹，最后删除这个临时文件夹.</p><ul><li>将excel模版放在服务器上<br>将个税局提供的模版放到服务器上，用于读取</li><li>收集处理导出的数据<br>数据是map形式，userId-data,一个员工对应自己的数据</li><li>在服务器上创建一个临时文件夹<br>打包时需要一个文件夹存放一个个excel文件</li><li>将数据写入<br>循环数据，获取excel模版，创建WorkBook写入数据</li><li>处理excel<br>将写好的excel文件命名并写到临时文件夹去</li><li>zip打包下载<br>写完所有数据后，对该临时文件夹打包导出</li><li>删除文件<br>导出后删除临时文件夹</li></ul><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><h5 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static void writeDataToModelExcel(HttpServletRequest request, HttpServletResponse response, Map&lt;String, SalaryTaxExportVO&gt; dataMap, String corpId, String opUserId) throws Exception &#123;</span><br><span class="line">final String folderPath = PATH + FILE_NAME_SPECIAL + LINE + corpId + LINE + opUserId + LINE + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">//创建唯一临时文件夹路径</span><br><span class="line">//创建扣件单位文件路径集合</span><br><span class="line">List&lt;String&gt; companyPathList = Lists.newArrayList();</span><br><span class="line">//遍历数据写入excel</span><br><span class="line">for (Map.Entry&lt;String, SalaryTaxExportVO&gt; entry : dataMap.entrySet()) &#123;</span><br><span class="line">//获取模版文件excel</span><br><span class="line">ClassPathResource classPathResource = new ClassPathResource(&quot;xls/latestSalaryTaxDeductTemplate.xls&quot;);</span><br><span class="line">//LOGGER.warn(&quot;qqqqq&quot; + Cipher.getMaxAllowedKeyLength(&quot;AES&quot;));</span><br><span class="line">Workbook wb = WorkbookFactory.create(classPathResource.getInputStream());</span><br><span class="line">//3.获取数据</span><br><span class="line">SalaryTaxExportVO salaryTaxExportVO = entry.getValue();</span><br><span class="line">String userId = salaryTaxExportVO.getUserId();</span><br><span class="line">//将数据写到excel模版中</span><br><span class="line">writeDataToTemplate(salaryTaxExportVO, wb);</span><br><span class="line">//将文件写入服务器(创建临时文件夹)</span><br><span class="line">File newFile = new File(folderPath);</span><br><span class="line">if (!newFile.exists()) &#123;</span><br><span class="line">boolean mkdirs = newFile.mkdirs();</span><br><span class="line">if (!mkdirs) &#123;</span><br><span class="line">throw new ExcelException(&quot;文件路径生成失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取扣缴单位名称 地区 身份证</span><br><span class="line">String companyName = salaryTaxExportVO.getCompanyName();</span><br><span class="line">if(StringUtils.isBlank(companyName))&#123;</span><br><span class="line">companyName = &quot;无扣缴单位&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String area = salaryTaxExportVO.getArea();</span><br><span class="line">String certNo = salaryTaxExportVO.getCertNo();</span><br><span class="line">//创建扣缴单位文件路径</span><br><span class="line">String companyPath = folderPath + SYMBOL + companyName + SYMBOL;</span><br><span class="line">if (!companyPathList.contains(companyPath)) &#123;</span><br><span class="line">File file = new File(companyPath);</span><br><span class="line">if (!file.exists()) &#123;</span><br><span class="line">file.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">companyPathList.add(companyPath);</span><br><span class="line">&#125;</span><br><span class="line">// 向扣缴单位文件夹写文件 地区+扣缴单位名称+个人身份号码</span><br><span class="line">List&lt;String&gt; names = Lists.newArrayList();</span><br><span class="line">names.add(area);</span><br><span class="line">names.add(companyName);</span><br><span class="line">names.add(certNo);</span><br><span class="line">names.add(&quot;.xls&quot;);</span><br><span class="line">String fileName = StringUtils.join(names.stream().filter(Objects::nonNull).collect(Collectors.toList()), &quot;&quot;);</span><br><span class="line">FileOutputStream out = new FileOutputStream(companyPath + fileName);</span><br><span class="line">wb.write(out);</span><br><span class="line">wb.close();</span><br><span class="line">&#125;</span><br><span class="line">// 获取zip文件名称 （余杭、建德）+扣缴单位名称</span><br><span class="line">String folderName = &quot;个人所得税专项附加扣除申报文件.zip&quot;;</span><br><span class="line">//打包下载文件</span><br><span class="line">packToDownload(request, response, folderName, folderPath);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;writeDataToModelExcel error, corpId=&#123;&#125;, userId=&#123;&#125;.&quot;, corpId, opUserId,e);</span><br><span class="line">throw e;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// 删除文件</span><br><span class="line">delFolder(folderPath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建zip包"><a href="#创建zip包" class="headerlink" title="创建zip包"></a>创建zip包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 创建ZIP文件</span><br><span class="line">*</span><br><span class="line">* @param folderPath 文件或文件夹路径</span><br><span class="line">*/</span><br><span class="line">private static void packToDownload(HttpServletRequest request, HttpServletResponse response, String folderName, String folderPath) &#123;</span><br><span class="line">try (</span><br><span class="line">ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(outputStream)) &#123;</span><br><span class="line">//设置响应头,必须在写文件前</span><br><span class="line">DownloadUtil.setFileDownloadHeader(request, response, folderName);</span><br><span class="line">writeZip(new File(folderPath), &quot;&quot;, zos);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*</span><br><span class="line">*写文件</span><br><span class="line">*/</span><br><span class="line">private static void writeZip(File file, String parentPath, ZipOutputStream zos) &#123;</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">if (file.isDirectory()) &#123;</span><br><span class="line">//处理文件夹</span><br><span class="line">String filename = file.getName();</span><br><span class="line">if (filename.contains(FILE_NAME_SPECIAL))&#123;</span><br><span class="line">filename = &quot;个人所得税专项附加扣除申报文件&quot;;</span><br><span class="line">&#125;</span><br><span class="line">parentPath += filename + File.separator;</span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line">if (files.length != 0) &#123;</span><br><span class="line">for (File f : files) &#123;</span><br><span class="line">writeZip(f, parentPath, zos);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;       //空目录则创建当前目录</span><br><span class="line">try &#123;</span><br><span class="line">zos.putNextEntry(new ZipEntry(parentPath));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">FileInputStream fis = null;</span><br><span class="line">try &#123;</span><br><span class="line">fis = new FileInputStream(file);</span><br><span class="line">ZipEntry ze = new ZipEntry(parentPath + file.getName());</span><br><span class="line">zos.putNextEntry(ze);</span><br><span class="line">byte[] content = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = fis.read(content)) != -1) &#123;</span><br><span class="line">zos.write(content, 0, len);</span><br><span class="line">zos.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (fis != null) &#123;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*</span><br><span class="line">*设置响应头</span><br><span class="line">*/</span><br><span class="line">public static void setFileDownloadHeader(HttpServletRequest request, HttpServletResponse response, String fileName) &#123;</span><br><span class="line">final String userAgent = request.getHeader(&quot;User-Agent&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">String finalFileName = getEncodeFileName(userAgent, fileName);</span><br><span class="line">response.setContentType(&quot;application/octet-stream&quot;);</span><br><span class="line">response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; &quot; + finalFileName);</span><br><span class="line">&#125; catch (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 删除文件</span><br><span class="line">*</span><br><span class="line">* @param folderPath</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">private static void delFolder(String folderPath) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//删除完里面所有内容</span><br><span class="line">delAllFile(folderPath);</span><br><span class="line">java.io.File myFilePath = new java.io.File(folderPath);</span><br><span class="line">//删除空文件夹</span><br><span class="line">myFilePath.delete();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil delFolder 删除文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean delAllFile(String path) &#123;</span><br><span class="line">boolean flag = false;</span><br><span class="line">File file = new File(path);</span><br><span class="line">if (!file.exists()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (!file.isDirectory()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">String[] tempList = file.list();</span><br><span class="line">if (ArrayUtils.isEmpty(tempList)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">for (String aTempList : tempList) &#123;</span><br><span class="line">File temp;</span><br><span class="line">if (path.endsWith(File.separator)) &#123;</span><br><span class="line">temp = new File(path + aTempList);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">temp = new File(path + File.separator + aTempList);</span><br><span class="line">&#125;</span><br><span class="line">if (temp.isFile()) &#123;</span><br><span class="line">temp.delete();</span><br><span class="line">&#125;</span><br><span class="line">if (temp.isDirectory()) &#123;</span><br><span class="line">//先删除文件夹里面的文件</span><br><span class="line">delAllFile(path + &quot;/&quot; + aTempList);</span><br><span class="line">//再删除空文件夹</span><br><span class="line">delFolder(path + &quot;/&quot; + aTempList);</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li>创建临时文件时，一定要保证文件名唯一（防止同一时间并发，导出串数据），这里采用了corpId-userId-UUID</li><li>后缀.xls表示07之前的版本 使用HSSFWookBook，.xlsx是07之后的版本XSSFWookBook，这里使用POI兼容的方式，自动帮你识别：Workbook wb = WorkbookFactory.create(classPathResource.getInputStream())；</li><li>在循环中每写完一个excel都要关流 wb.close() — 因为是多个excel</li><li>最后一定要删除服务器上的文件（防止文件堆积占用内存）</li><li>HSSF对excel函数方法较多不支持导致导出的文件一些版本的excel内容不可读，不过用WPS可以正常打开</li><li>设置响应头,必须在写文件前</li><li>JCE策略文件-读取excel加密文件时，jdk版本需要在”1.8.0_161以上，否则需要安装第三方jar包（US_export_policy.jar , local_policy.jar　）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>maven基本知识</title>
    <link href="http://yoursite.com/2018/12/23/maven%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/23/maven基础知识/</id>
    <published>2018-12-22T23:49:55.000Z</published>
    <updated>2020-07-15T06:39:22.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>maven是项目管理工具，主要有两个特性: 依赖管理和一键构建.</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h5 id="依赖管理就是对jar包的管理过程"><a href="#依赖管理就是对jar包的管理过程" class="headerlink" title="依赖管理就是对jar包的管理过程."></a>依赖管理就是对jar包的管理过程.</h5><p>传统的工程项目是直接放置jar包，maven工程真正的jar包在仓库中放置，项目中只放置jar包的坐标(pom.xml). </p><h5 id="仓库分三类-："><a href="#仓库分三类-：" class="headerlink" title="仓库分三类 ："></a>仓库分三类 ：</h5><p>本地仓库,远程仓库【私服】,中央仓库.<br>本地仓库是我们运行项目第一步必须本地仓库有对应的坐标，如果没有默认自动去中央仓库下载，在公司中会先从远程仓库下载，远程仓库没有，会从中央仓库下载或本地上传.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ….&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.dintalent.salary&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; </span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt; </span><br><span class="line">&lt;name&gt;mavenDemo&lt;/name&gt;  </span><br><span class="line">&lt;url&gt;http://maven.apache.org&lt;/url&gt;  </span><br><span class="line">&lt;dependencies&gt;  </span><br><span class="line">&lt;dependency&gt;   </span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;   </span><br><span class="line">&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><ul><li>groupId : 标识公司,组织,团体(taobao.com对应com.taobao,apche.org对应org.apache)</li><li>artifactId ：工程名</li><li>version :版本号 （SNAPSHOT表示测试版本）</li><li>packaging ： 打成什么包(jar,war,pom)</li><li>scope : 依赖范围（例如test 表示对测试代码classpath有效）</li></ul><h2 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h2><p>一键构建就是我们使用maven集成的tomcat插件对项目进行编译，测试，打包，安装等操作.</p><ul><li>清理生命周期：clean</li><li>默认生命周期：compile(编译),test(测试),package(打包),install(安装).</li></ul><h2 id="jar包冲突问题"><a href="#jar包冲突问题" class="headerlink" title="jar包冲突问题"></a>jar包冲突问题</h2><p>简单理解就是应用程序依赖的同一个jar包出现了多个不同的版本，选择了错误的版本导致JVM加载不到类或加载了错误版本的类.</p><ul><li>直接依赖： A项目导入了B包，A直接依赖B包</li><li>传递依赖： A项目导入了B包，B包直接依赖C包，最终A可以使用C</li></ul><h5 id="解决jar冲突的三个原则"><a href="#解决jar冲突的三个原则" class="headerlink" title="解决jar冲突的三个原则"></a>解决jar冲突的三个原则</h5><ol><li>第一声明原则：哪个jar包的坐标靠上，这个jar包就是第一声明的包，最终进入项目的就是它.</li><li>路径近者优先原则：直接依赖路径比传递依赖近，进入项目的就是路径近的.</li><li>直接排除法： 使用<exlusions></exlusions>标签直接排除某个包的依赖包.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义注解简单使用</title>
    <link href="http://yoursite.com/2018/10/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/21/自定义注解使用/</id>
    <published>2018-10-20T23:03:55.000Z</published>
    <updated>2020-07-15T06:38:53.017Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>需要对一些用户行为的接口进行日志埋点统计,如果在业务代码写的话代码比较杂乱,而且之后改动也不方便,于是便决定使用自定义注解，使用spring的切面注解@Aspect.</p><h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>Java文件叫做Annotation，用@interface表示。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>@interface上面按需要注解上一些东西，包括@Retention、@Target、@Document、@Inherited四种.</p><ul><li>@Target 表示该注解可以用于什么地方</li><li>@Retention 注解的声明周期，用于定义注解的存活阶段，可以存活在源码级别、编译级别(字节码级别)、运行时级别</li><li>@Document 将注解包含在Javadoc中</li><li>@Inherited 允许子类继承父类中的注解</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p> 基于注解的知识，自己创建一个注解</p><ul><li>实现过程<br>首先创建一个自定义注解 -&gt; 采用spring的@Aspect创建一个切面类,在这个切中获取信息并且打印日志 -&gt; 在记录的接口上写上注解</li><li>简单示例代码<br><img src="https://github.com/geyou1995/picture/blob/master/Annotations1.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations2.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations3.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations4.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations5.png?raw=true" alt=""><blockquote><p>参考：项目中的操作日志的方法</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8新特性Lambda和Stream</title>
    <link href="http://yoursite.com/2018/09/18/Java8%E6%96%B0%E7%89%B9%E6%80%A7Lambda%E5%92%8CStream/"/>
    <id>http://yoursite.com/2018/09/18/Java8新特性Lambda和Stream/</id>
    <published>2018-09-18T01:10:55.000Z</published>
    <updated>2020-07-15T06:39:04.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目前项目应用的是Java 1.8版本,在项目中看到其他小伙伴使用了奇特的编码方式，许多行代码简化成了一行，原来是Java8的特性Lambda和Stream,结合代码和网上查资料学习了一下，并将相关的的知识做了下总结.</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda简单的理解就是一个匿名方法，一段带有输入参数的可执行语句块.</p><ul><li>语法：（）-&gt; {}   (小括号里是参数，大括号里是方法体)</li><li>特点：<pre><code>1.参数类型可以省略，编译器可以从上下文环境中推断出来2.当lambda表达式的参数个数只有一个的时候，小括号可以省略3.当lambda表达式只包含一条语句时，可以省略大括号，return，语句结尾的分号4.lambda表达式可以访问外部变量，但是要求这个变量不可变（final修饰）</code></pre></li><li>方法引用：<pre><code>1.类实例引用：   Person::getName2.类静态方法引用：Max::max </code></pre></li><li>构造器引用：<pre><code>Person::new（等同于 x-&gt;new Person(x)）</code></pre></li></ul><hr><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作。数据源一般是数组或集合等，进行聚合操作可以获取想要的结果。</p><ul><li>基本步骤：获取一个数据源（source）-&gt; 数据转化 -&gt; 执行操作获取想要的结果.(简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果)</li><li>创建Stream<pre><code>1.Stream静态方法：Stream.of();2.Collection子类获取Stream（最常用）：list.Stream();</code></pre></li><li>Stream流操作<br>  *Intermediate（中间）: 一个流可以跟多个中间操作，主要是打开流对数据进行某种映射或过滤.<pre><code>常见操作:    map() - 对stream里的元素进行映射转化    filter() - 对Stream包含对元素按给定的条件过滤    distinct() - 对stream包含对元素进行去重    sorted() - 对stream包含对元素排序    peek() -  生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数        limit() - 对Stream里的元素取前n个    skip(n) - 对stream里的元素丢弃前n个，获取之后的元素    parallel() - 将一个顺序执行的流转变成一个并发的流（还有一种Collection.parallelStream()）    sequential() - 一个并行流转换成一个顺序流        unordered() - 实现无序流</code></pre></li><li>Terminal(终端): 一个流只能有一个终端操作，这是流对最后一个操作，用来处理结果数据。<pre><code>常见操作:     forEach() - 遍历结果数据（并行处理）    forEachOrdered - 遍历结果数据（顺序处理）    toArray（） - 将数据输入到数组中    reduce（） - 把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合    collect（） - 实现了很多归约操作，例如将流转换成集合和聚合元素    count() - 获取stream里的元素个数    min() - 最小值    max() - 最大值    anyMatch() - Stream中是否存在任何一个元素满足匹配条件    allMatch() - 是不是Stream中的所有元素都满足给定的匹配条件    noneMatch() - 是不是Stream中的所有元素都不满足给定的匹配条件    findFirst() - 返回Stream中的第一个元素，如果Stream为空，返回空Optional    findAny() - 返回这个Stream中，取到的任何一个对象</code></pre></li><li>简单示例代码</li><li>七牛云大坑逼！！！！！<br><img src="https://github.com/geyou1995/geyou1995.github.io/blob/master/wallhave.n-664820.jpg?raw=true" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test1.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test2.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test3.1.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test3.2.png" alt=""><blockquote><p>参考：<a href="https://yuque.antfin-inc.com/mdc/doc/rhihn7" target="_blank" rel="noopener">https://yuque.antfin-inc.com/mdc/doc/rhihn7</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac系统Idea常用快捷键</title>
    <link href="http://yoursite.com/2018/09/09/Mac%E7%B3%BB%E7%BB%9F%E4%B8%8BIdea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/09/09/Mac系统下Idea快捷键/</id>
    <published>2018-09-09T02:24:45.000Z</published>
    <updated>2020-07-15T06:42:32.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直使用的Java编译工具是eclipse,进新公司之后,公司配了一台Mac并且后端都用IntelliJ IDEA开发,不能脱离团队呀,果断入手了IDEA,不得不说比eclipse更加的智能好用,为了提高开发效率，所以决定整理一下IDEA的常用快捷键,不想每次都配,所以就决定用IDEA默认的快捷键,用的是Mac OS X 10.5+ 但是Mac系统中与IDEA的快捷键有些冲突,可以把Mac相关冲突的快捷键更改或取消掉.下面整理了平常开发中常用的快捷键，以便于更好的记忆和熟练使用.</p><h2 id="Mac键盘符号和修饰健说明"><a href="#Mac键盘符号和修饰健说明" class="headerlink" title="Mac键盘符号和修饰健说明"></a>Mac键盘符号和修饰健说明</h2><p>⌘ Command<br>⇧ Shift<br>⌥ Option<br>⌃ Control<br>↩︎ Return/Enter<br>⌫ Delete<br>⌦ 向前删除键（Fn+Delete）<br>↑ 上箭头<br>↓ 下箭头<br>← 左箭头<br>→ 右箭头<br>⇞ Page Up（Fn+↑）<br>⇟ Page Down（Fn+↓）<br>Home Fn + ←<br>End Fn + →<br>⇥ 右制表符（Tab键）<br>⇤ 左制表符（Shift+Tab）<br>⎋ Escape (Esc)</p><h2 id="Editing编辑"><a href="#Editing编辑" class="headerlink" title="Editing编辑"></a>Editing编辑</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Control+Space 基本的代码补全(补全任何类,方法,变量) 注意这里与Mac系统的输入法快捷键冲突</span><br><span class="line">Control+Shift+Space 智能代码补全 (过滤器方法列表和变量的预期类型）</span><br><span class="line">Command+Shift+Enter 自动结束代码,行末添加分号</span><br><span class="line">Command+P  显示方法的参数</span><br><span class="line">Control+J  快速显示文档</span><br><span class="line">Command+鼠标放在代码上  显示代码简要信息</span><br><span class="line">Command+N  生成代码（getter、setter、构造函数、hashCode/equals,toString,实现接口方法）这个还有其他快捷键我只记这一种了</span><br><span class="line">Control+O  覆盖方法(重写父类方法)</span><br><span class="line">Control+I  实现接口方法(我直接记Command+N,也能实现接口方法)</span><br><span class="line">Command+Option+T 包围代码(try catch,if else,do while等)</span><br><span class="line">Command+/ 行注释代码(再按一次就是取消注释)</span><br><span class="line">Command+Option+/ 块注释</span><br><span class="line">Option+方向上  连续选中代码块</span><br><span class="line">Option+方向下  减少选中的代码块</span><br><span class="line">Control+Shift+Q 显示上下文信息</span><br><span class="line">Option+Enter  显示意向动作和快速修复代码</span><br><span class="line">Command+Option+L 格式化代码</span><br><span class="line">Control+Option+O 优化import</span><br><span class="line">Tab  缩进代码</span><br><span class="line">Command+C 复制</span><br><span class="line">Command+V 粘贴</span><br><span class="line">Command+X 剪切</span><br><span class="line">Command+D 复制当前行或选定的块</span><br><span class="line">Command+Delete 删除当前行或选定的行的块</span><br><span class="line">Control+Shift+J 智能的将代码拼接成一行</span><br><span class="line">Command+Enter 智能的拆分拼接的行</span><br><span class="line">Command+加号/减号 展开/折叠代码块</span><br><span class="line">Command+Shift+加号/减号 展开/折叠所有代码块</span><br><span class="line">Command+W 关闭活动的编辑器选项</span><br><span class="line">Command+Shift+上下  上下移动代码</span><br></pre></td></tr></table></figure><h2 id="Search-Replace（查询-替换"><a href="#Search-Replace（查询-替换" class="headerlink" title="Search/Replace（查询/替换)"></a>Search/Replace（查询/替换)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command+F 文件内查找</span><br><span class="line">Command+Shift+F 全局查找</span><br><span class="line">Command+G 查找模式下向下查找</span><br><span class="line">Command+Shift+G 查找模式下向上查找</span><br></pre></td></tr></table></figure><h2 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Option+F7 在文件中查找用到的地方</span><br><span class="line">Command+F7 在类中查找用到的地方</span><br><span class="line">Command+Shift+F7 在类中显示(颜色标记)用到的地方</span><br><span class="line">Command+Option+F7 显示用法</span><br></pre></td></tr></table></figure><h2 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Command+F9 编译Project</span><br><span class="line">Command+Shift+F9 编译选择的文件,包或模块</span><br><span class="line">Control+Option+R 弹出Run的可选菜单</span><br><span class="line">Control+Option+R 弹出Debug的可选菜单</span><br><span class="line">Control+D 调试</span><br></pre></td></tr></table></figure><h2 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F8 进入下一步,不进入当前方法内</span><br><span class="line">F7 进入下一步,如果当前断点式方法,则进入方法内</span><br><span class="line">Shift+F8 跳出</span><br><span class="line">Option+F9 运行到光标停留处</span><br><span class="line">F9 放开debug </span><br><span class="line">Command+Shift+F8 查看断点信息</span><br></pre></td></tr></table></figure><h2 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shift+Shift 查找文件</span><br><span class="line">Command+L 跳转行</span><br><span class="line">Command+E 显示最近打开的文件记录列表</span><br><span class="line">Command+Option+方向键左/右  退回/前进到上一个操作的地方</span><br><span class="line">Command+B 或Command+鼠标左键  进入方法或变量的接口或是定义处</span><br><span class="line">Command+Option+B 越过接口,直接跳掉实现处</span><br></pre></td></tr></table></figure><h2 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F5 复制文件到指定目录</span><br><span class="line">Command+delete 在文件上安全删除文件,弹出确认框</span><br><span class="line">Shift+F6 重命名文件</span><br><span class="line">Command+Option+M 将选中的代码提取为方法</span><br></pre></td></tr></table></figure><h2 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+, 打开idea系统设置</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
