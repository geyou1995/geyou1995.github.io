<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我就是胖着玩玩的</title>
  
  <subtitle>坚持产生意外✊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-15T07:45:59.303Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Youga</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Idea 查看源码</title>
    <link href="http://yoursite.com/2020/07/15/Idea%E5%A6%82%E4%BD%95%E7%9C%8B%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2020/07/15/Idea如何看源码/</id>
    <published>2020-07-15T07:34:45.000Z</published>
    <updated>2020-07-15T07:45:59.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>平时开发代码，避开不了需要查看源码，例如JDK、spring的源码那都是精华，非常值我们去推敲学习的，但是在Idea直接点开下载源码是不能在上面做笔记的，所以希望看源码的时候可以把自己理解的内容写注释，方便下次观看立即能回忆起来。而且能够Debug调试。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>就拿JDK的源码为例。<br>1.找到JDK的zip包然后解压<br>2.打开Idea的SKDs,在sourcepath配置解压好的jdk包<br><img src="https://github.com/geyou1995/picture/blob/master/1594798922200.jpg?raw=true" alt=""><br>3.最后就能在源码写注释了(以HashMap源码为例)<br><img src="https://github.com/geyou1995/picture/blob/master/1594799091404.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://yoursite.com/2020/07/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/15/设计模式-单例模式/</id>
    <published>2020-07-15T07:30:55.000Z</published>
    <updated>2020-07-15T06:30:57.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单例模式：保证一个类仅有一个实例，并提供一个全局访问它的全局访问点。</p><h2 id="单例实现"><a href="#单例实现" class="headerlink" title="单例实现"></a>单例实现</h2><p>实例单例模式主要分为两种：懒汉式和饿汉式。<br>1.构造方法私有化。<br>2.提供一个全局访问点.</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 自行创建实例</span><br><span class="line">    private static HungrySingleton instance = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    // 构造方法私有化</span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过该函数向整个系统提供获取方法</span><br><span class="line">    public HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用static修饰了成员变量instance,这样类初始化的过程中被收集进类构造器即“clinit”方法中，在多线程下JVM会保证只有一个线程会执行clinit方法，其他会阻塞等待。等到唯一的一次clinit方法执行完成，其他线程将不会再执行该方法，转而执行自己的代码。也就是说static修饰的成员变量instatnce只会被初始化一次。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以保证多线程情况下实例的唯一性，getInstatce方法直接返回实例，性能非常高。<br>缺点：在类成员变量比较多活比较大的情况下，可能在没有使用类的时候一直占用着堆内存，造成内存的浪费。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉模式就是为了避免直接加载类对象造成堆内存浪费的一种单例模式。</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1.原始方法</span><br><span class="line">    // 这样虽然避免了类加载提前创建实例，但是在多线程运行下，就会出现多个实例创建的情况。</span><br><span class="line">    public LazySingleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象 -- 多个线程会创建多个对象</span><br><span class="line">            instance = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    // 2.饿汉式 + synchronized</span><br><span class="line">    // 这样虽然可以避免多线程问题，但是同步锁会增加锁竞争，每次获取实例对象都会通过getInstance方法，带来系统性能开销，导致系统性能下降。</span><br><span class="line">    public synchronized LazySingleton getInstance1() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象</span><br><span class="line">            instance = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private  LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 3.饿汉式 + synchronized 减小锁的粒度</span><br><span class="line">    // 在创建实例对象的时候加同步锁，但是依然存在可能创建多个实例，因为在进入null判断的时候可能有多个线程</span><br><span class="line">    public  LazySingleton getInstance2() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁  -- 这里可能多个线程等待，最终也会导致多个对象创建</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                instance = new LazySingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private volatile LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    // 4.饿汉式 + synchronized double check</span><br><span class="line">    // 当线程拿到锁准备创建对象时，再判断一次实例是否已经创建。这种方法被称为Double-Check,它可以大大提高懒汉模式性能。</span><br><span class="line">    // 但是也不能保证万无一失。以防万一变量添加volatile 防止指令重排序。</span><br><span class="line">    public  LazySingleton getInstance3() &#123;</span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 实例化对象  加锁</span><br><span class="line">            synchronized(LazySingleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;</span><br><span class="line">                    instance = new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过内部类实现</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 4.通过内部类实现</span><br><span class="line">    // 通过饿汉式可以知道通关键字static修饰变量，在类初始化加载的时候只有一个线程可以执行clinit方法，其他会阻塞等待。</span><br><span class="line">    // 所以可以利用这个特性在Singleton类中创建一个内部类来实现。内部类的静态成员变量是懒加载，并且内部类可以调外部类的私有构造方法。</span><br><span class="line">    public static class InnerSingleton &#123;</span><br><span class="line">        private static LazySingleton instance = new LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public LazySingleton getInstance4() &#123;</span><br><span class="line">        return InnerSingleton.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.枚举类(核心就是内部类)</span><br></pre></td></tr></table></figure><h3 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    // 不实例化</span><br><span class="line">    private volatile LazySingleton instance = null;</span><br><span class="line"></span><br><span class="line">    // 构造方法实例化</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.通过内部类实现</span><br><span class="line">    // 通过饿汉式可以知道通关键字static修饰变量，在类初始化加载的时候只有一个线程可以执行clinit方法，其他会阻塞等待。</span><br><span class="line">    // 所以可以利用这个特性在Singleton类中创建一个内部类来实现。内部类的静态成员变量是懒加载，并且内部类可以调外部类的私有构造方法。</span><br><span class="line">    public static class InnerSingleton &#123;</span><br><span class="line">        private static LazySingleton instance = new LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public LazySingleton getInstance4() &#123;</span><br><span class="line">        return InnerSingleton.instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h3><p>枚举类(核心就是内部类)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实单例模式的本质就是控制对象实例的个数。懒汉式和饿汉式各有各的优缺点，可以适当根据应用场景使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Idea永久破解</title>
    <link href="http://yoursite.com/2020/07/15/Idea%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/15/Idea永久破解/</id>
    <published>2020-07-15T07:00:45.000Z</published>
    <updated>2020-07-15T07:32:16.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>最近刚好换了工作，要换台电脑工作了，安装了Idea,忘记了原来Idea破解的方法，于是网上查找，果然好记性不如烂笔头，决定总结一下，记录下来。就是把idea激活，不需要使用有期限的激活码.</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.首先下载jetbrains-agent.jar<br>2.在Idea里创建idea.vmoptions<br><img src="https://github.com/geyou1995/picture/blob/master/idea%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB.jpg?raw=true" alt=""><br>3.在idea.vmoptions 填写jetbrains-agent.jar的文件路径<br><img src="https://github.com/geyou1995/picture/blob/master/1594798247034.jpg?raw=true" alt=""><br>4.填写 <a href="http://fls.jetbrains-agent.com" target="_blank" rel="noopener">http://fls.jetbrains-agent.com</a> 最后激活<br><img src="https://github.com/geyou1995/picture/blob/master/1594797538198.jpg?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>sql优化</title>
    <link href="http://yoursite.com/2019/06/07/sql%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/06/07/sql优化/</id>
    <published>2019-06-07T08:01:55.000Z</published>
    <updated>2020-07-15T06:36:52.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开发过程中,经常会碰到一些慢sql，就是性能低，执行时间太长、等待时间太长、sql语句欠佳、索引失效、服务器参数设置不合理需要我们对sql进行适当的优化，所以需要了解如何去优化哈.下面整理了一些mysql的sql结构以及该如何去优化sql。</p><h2 id="mysql的逻辑分层原理"><a href="#mysql的逻辑分层原理" class="headerlink" title="mysql的逻辑分层原理"></a>mysql的逻辑分层原理</h2><ul><li>连接层<br>提供与客户端连接的服务</li><li>服务层<br>提供各种用户使用的接口（增删改查）<br>提供sql优化器</li><li>引擎层<br>提供各种存储数据的方式，例如默认的InnoDB（事务优先，行锁）、MyISAM(效率优先，表锁)等</li><li>存储层<br>存储最终的数据</li></ul><blockquote><p>sql 编写过程<br>select…from…join…on…where…group by…having…order by…limit..<br>sql 解析过程<br>from…on..join…where…group by…having..select…order by…limit..</p></blockquote><h2 id="核心是优化索引"><a href="#核心是优化索引" class="headerlink" title="核心是优化索引"></a>核心是优化索引</h2><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ol><li>定义 </li></ol><p>帮助mysql高效获取数据的数据结构，索引是数据结构.</p><ol start="2"><li>索引分类<br>  主键索引：与唯一基本相同（主键不能为null，唯一可以为null）<br> 单值索引：单列（一个表可以有多个单值索引）<br>  唯一索引：不能重复（例如id）<br>  复合索引：多个列构成的索引s </li></ol><ol start="3"><li><p>索引优势<br> 提高查询效率（降低IO的使用率)<br> 降低CPU使用率（索引是排好序的结构，可以直接用）</p></li><li><p>索引弊端：<br> 索引本身很大，可以存放在内存/硬盘<br> 不是所有情况使用：a.少量数据 b.频繁更新的字段 c.很少使用的字段<br> 索引会提高查的效率，会降低增删改的效率</p></li></ol><h4 id="Sql性能问题"><a href="#Sql性能问题" class="headerlink" title="Sql性能问题"></a>Sql性能问题</h4><ol><li><p>分析sql的执行计划：explain<br> 查询执行计划：explain + sql</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: 编号,id值相同，从上往下顺序执行(表的执行顺序会因为数量改变而改变，原因：笛卡尔积，数据小的表优先查询)，id值不同：越大越优先查询（在查询时先查内层再查外层）</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select_type: 查询类型</span><br><span class="line"></span><br><span class="line">PRIMARY:主查询</span><br><span class="line">SUBQUERY:子查询</span><br><span class="line">SIMPLE:简单查询（不包含主、子查询）</span><br><span class="line">DERIVER：衍生查询（使用到临时表-a.在from子查询中只有一张表 b.在from子查询中table1  union table2）</span><br><span class="line">UNION：在from子查询中table1 union table2（指的table2）</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table: 表(代表你查的表)</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type: </span><br><span class="line">索引类型 system-&gt;const-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all（越往左效率越高）</span><br><span class="line">system:只有一条数据的系统表 或 衍生表(子查询)只有一条数据的主查询</span><br><span class="line">const:结果只有一条数据 （用于主键索引和唯一索引）</span><br><span class="line">eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</span><br><span class="line">ref:非唯一性索引，返回匹配的多条数据或0条</span><br><span class="line">range:检索指定范围的行，使用一个索引来选择行（between,&lt;,&gt;,=）</span><br><span class="line">index:读取所有的索引</span><br><span class="line">all:全表读取</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">possible_keys: 预测可能使用的索引</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key: 实际使用的索引</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key_len:实际使用的索引的长度（作用：判断复合索引是否完全被使用）</span><br><span class="line">key len的长度还和字符集有关,latin1一个字符占用1个字节,gbk一个字符占用2个字节,utf8一个字符占用3个字节(如果索引字段可以为空，会给1个字节标示)。</span><br><span class="line">utf-8情况下：name char(20) 不为null--20*3=60，若可为null--20*3+1=61</span><br><span class="line">name varchar(20)不为null--20*3+2=62，若可为null--20*3+2+1=63</span><br><span class="line">id int(3) 不为null--4，若可为null--4+1=5</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: 作用-指明当前表参照的字段</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const:常量</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows:被索引优化查询的数据个数</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Extra: 性能从好到坏:using index &gt; using where &gt; using temporary | using filesort</span><br><span class="line">* using filesort（性能损耗大）常见于order by:</span><br><span class="line">1.需要额外的一次排序或查找（单索引）--排序和查找不是同一个字段会出现</span><br><span class="line">2.最佳左前缀（复合索引）--不按照复合索引的顺序使用</span><br><span class="line"></span><br><span class="line">* using temporary（性能损耗大，额外多使用临时表）常见于group by: 根据字段查确不用该字段分组</span><br><span class="line"></span><br><span class="line">* using index: 索引覆盖，不读取原文件，只从索引文件中获取（不需要回表查询）</span><br><span class="line">如果用到了索引覆盖：</span><br><span class="line">1.如果有where,索引出现在key和possible_keys中</span><br><span class="line">2.如果没有where,索引只出现在key中</span><br><span class="line">select age from student where age = 13 ---age 是索引</span><br><span class="line"></span><br><span class="line">* using where: 需要回表查询(需要查询原文件)</span><br><span class="line">select age，name from student where name = &apos;&apos; ---age 是索引</span><br><span class="line"></span><br><span class="line">* Impossible where：这个值强调了where语句会导致没有符合条件的行</span><br><span class="line"></span><br><span class="line">总结:如果（a,b,c,d）复合索引和使用的顺序一致，则复合索引全部使用。如果部分一致（且不夸列），则部分使用</span><br></pre></td></tr></table></figure></li><li><p>sql优化器可能干扰我们的优化<br>sql的优化主要通过上述的属性去优化，但是sql优化器可能会干扰我们的优化.</p></li></ol><h2 id="常用sql优化方法"><a href="#常用sql优化方法" class="headerlink" title="常用sql优化方法"></a>常用sql优化方法</h2><pre><code>1. 加索引    a.索引不能跨列，保持索引的定义和使用一致（根据sql实际解析的顺序，调整索引的顺序，从from开始节气解析）；    b.索引要逐步优化    c.范围查询in可能使索引失效，放到where条件最后面2. 多表    a.小表驱动大表    b.索引建立在经常查询的字段3. 避免索引失效的一些原则    a.复合索引，不要跨列或无序使用（最佳左前缀）    b.复合索引，尽量使用全索引匹配    c.不要在索引上进行任何操作（计算，函数，类型转换），否则索引失效        d.复合索引不能使用不等于（!=，&lt;&gt;）或is null，否则索引失效    e.尽量使用索引覆盖（using index）    f.like尽量已“常量”开头，不用以“%”开头，否则索引失效（如果必须使用，可以用索引覆盖补救一部分）    g.尽量不要使用类型转换（显式，隐式），否则索引失效    h.尽量不要使用or，否则索引失效注：双层循环：（外层小内层大）性能比（外层大内层小）好</code></pre><h2 id="mysql锁机制"><a href="#mysql锁机制" class="headerlink" title="mysql锁机制"></a>mysql锁机制</h2><p>解决因资源共享而造成的并发问题</p><ul><li>操作类型分：<br>  1.读锁（共享锁）:对同一个数据，多个读操作可以同时进行（买衣服的看）<br>  2.写锁（互斥锁）:如果当前操作没有完毕，则无法进行读写操作（买衣服一系列操作）</li><li>操作范围分：<br>  1.表锁：一次性对一张表整体加锁（myISAM存储引擎），开销小，加锁快，锁的范围大，无死锁，容易发生锁冲突<br>  2.行锁：一次性对一行数据加锁（innoDB存储引擎），开销大，加锁慢，容易出现死锁，不易发生锁冲突<br>  3.页锁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>springBoot入门</title>
    <link href="http://yoursite.com/2019/05/27/springBoot%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/05/27/springBoot入门/</id>
    <published>2019-05-27T12:46:55.000Z</published>
    <updated>2020-07-15T06:31:45.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>为基于spring开发提供更快的入门体检.</li><li>开箱即用.</li><li>springBoot不是对spring的增强，而是提供了更快的使用方式</li><li>嵌入式服务器，健康检测，安全、外部配置等非功能性特性.</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>起步依赖<br>将具备某一功能的坐标打包到一起，提供默认的功能</li><li>自动配置<br>自动帮你配置某个对象需要的配置,例如tomcat的端口号默认8080等</li></ol><h2 id="必须引用的坐标"><a href="#必须引用的坐标" class="headerlink" title="必须引用的坐标"></a>必须引用的坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">父级依赖</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支持web的模块</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>springBoot是基于约定的所有很多配置都有默认值，若想使用自己的配置，可以使用配置文件（properties,yml).</p><h4 id="1-properties"><a href="#1-properties" class="headerlink" title="1. properties"></a>1. properties</h4><p>key = value </p><h4 id="2-yml（yaml）"><a href="#2-yml（yaml）" class="headerlink" title="2. yml（yaml）"></a>2. yml（yaml）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.普通数据的配置（冒号后需要空格）</span><br><span class="line">name: zhangsan </span><br><span class="line">2. 对象的配置(同一级别的缩进保持一致)</span><br><span class="line">person:</span><br><span class="line">name: zhangsan</span><br><span class="line">age: 18</span><br><span class="line">address: hangzhou</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">port: 8088</span><br><span class="line">3. 行内对象配置(不常用)</span><br><span class="line">person： &#123;name: zhangsan,age: 18, address: hangzhou&#125;</span><br><span class="line"></span><br><span class="line">4.配置数据集合</span><br><span class="line">city:</span><br><span class="line">- beijing</span><br><span class="line">- hangzhou</span><br><span class="line">- taizhou</span><br><span class="line">- zhoushan</span><br><span class="line">city：[beijing,hangzhou,taizhou]</span><br><span class="line"></span><br><span class="line">5. 配置对象集合数据</span><br><span class="line">student:</span><br><span class="line">-name: zhangsan</span><br><span class="line">age: 18</span><br><span class="line">address: hangzhou</span><br><span class="line">-name: lisi</span><br><span class="line">age: 16</span><br><span class="line">address: taizhou</span><br><span class="line">6. map配置</span><br><span class="line">map:</span><br><span class="line">key1: value1</span><br><span class="line">key2: value2</span><br></pre></td></tr></table></figure></code></pre><h2 id="加载配置文件的顺序"><a href="#加载配置文件的顺序" class="headerlink" title="加载配置文件的顺序"></a>加载配置文件的顺序</h2><p>springBoot一些数据会有默认值，如果你想更改则可以使用配置来覆盖，配置文件后加载的也会覆盖之前加载的.它会先加载yml，最后加载properties.<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（spring-boot-starter-parent）</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">&lt;excludes&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.yml&lt;/exclude&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.yaml&lt;/exclude&gt;</span><br><span class="line">&lt;exclude&gt;**/application*.properties&lt;/exclude&gt;</span><br><span class="line">&lt;/excludes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure></p><h2 id="在业务代码中获取配置信息"><a href="#在业务代码中获取配置信息" class="headerlink" title="在业务代码中获取配置信息"></a>在业务代码中获取配置信息</h2><p>有如下两种方式：</p><ol><li><p>@value(“${name}”)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;oss.endPoint&#125;&quot;)</span><br><span class="line">private String endPoint;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oss:</span><br><span class="line">endPoint: oss-cn-hangzhou-internal.aliyuncs.com</span><br><span class="line">accessKeyId: ALIYUN_ACCESS_KEY</span><br><span class="line">accessKeySecret: ALIYUN_SECRET_KEY</span><br><span class="line">defaultBucket: salary-prod</span><br></pre></td></tr></table></figure></code></pre></li><li><p>@ConfigurationProperties(prefix =”person”)<br> 需要set,get方法</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">private String clusterNodes;</span><br><span class="line"></span><br><span class="line">private String redisHost;</span><br><span class="line"></span><br><span class="line">private int redisPort;</span><br><span class="line"></span><br><span class="line">private String redisPasswd;</span><br><span class="line"></span><br><span class="line">set()..</span><br><span class="line">get()..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">clusterNodes:</span><br><span class="line">redisHost: r-bp1d75e29eop202ee4.redis.rds.aliyuncs.com</span><br><span class="line">redisPort: 6377</span><br><span class="line">redisPasswd: REDIS_PASSWORD</span><br><span class="line">timeout: 3000</span><br><span class="line">database: 0</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>excel读写及Zip打包下载</title>
    <link href="http://yoursite.com/2019/01/02/excel%E8%AF%BB%E5%86%99%E5%8F%8AZIp%E6%89%93%E5%8C%85%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/01/02/excel读写及ZIp打包下载/</id>
    <published>2019-01-02T09:41:55.000Z</published>
    <updated>2020-07-15T06:38:34.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>针对2019个税专项附加扣除做的需求：帮助Hr快速收集员工申报信息，及处理信息，由员工填写表单提交信息，对信息进行处理写入到个税局提供的个税专项附加扣除信息excel模版，最后ZIP打包导出.</p><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>首先需要收集处理员工数据，将excel模版放在服务器上，导出时在服务器上创建一个临时文件夹，读取模版excel文件,将数据循环写入excel模版中(一个员工对应一张excel),将写好数据的excel文件流依次写入该文件夹中，接着打包下载该文件夹，最后删除这个临时文件夹.</p><ul><li>将excel模版放在服务器上<br>将个税局提供的模版放到服务器上，用于读取</li><li>收集处理导出的数据<br>数据是map形式，userId-data,一个员工对应自己的数据</li><li>在服务器上创建一个临时文件夹<br>打包时需要一个文件夹存放一个个excel文件</li><li>将数据写入<br>循环数据，获取excel模版，创建WorkBook写入数据</li><li>处理excel<br>将写好的excel文件命名并写到临时文件夹去</li><li>zip打包下载<br>写完所有数据后，对该临时文件夹打包导出</li><li>删除文件<br>导出后删除临时文件夹</li></ul><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><h5 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static void writeDataToModelExcel(HttpServletRequest request, HttpServletResponse response, Map&lt;String, SalaryTaxExportVO&gt; dataMap, String corpId, String opUserId) throws Exception &#123;</span><br><span class="line">final String folderPath = PATH + FILE_NAME_SPECIAL + LINE + corpId + LINE + opUserId + LINE + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">//创建唯一临时文件夹路径</span><br><span class="line">//创建扣件单位文件路径集合</span><br><span class="line">List&lt;String&gt; companyPathList = Lists.newArrayList();</span><br><span class="line">//遍历数据写入excel</span><br><span class="line">for (Map.Entry&lt;String, SalaryTaxExportVO&gt; entry : dataMap.entrySet()) &#123;</span><br><span class="line">//获取模版文件excel</span><br><span class="line">ClassPathResource classPathResource = new ClassPathResource(&quot;xls/latestSalaryTaxDeductTemplate.xls&quot;);</span><br><span class="line">//LOGGER.warn(&quot;qqqqq&quot; + Cipher.getMaxAllowedKeyLength(&quot;AES&quot;));</span><br><span class="line">Workbook wb = WorkbookFactory.create(classPathResource.getInputStream());</span><br><span class="line">//3.获取数据</span><br><span class="line">SalaryTaxExportVO salaryTaxExportVO = entry.getValue();</span><br><span class="line">String userId = salaryTaxExportVO.getUserId();</span><br><span class="line">//将数据写到excel模版中</span><br><span class="line">writeDataToTemplate(salaryTaxExportVO, wb);</span><br><span class="line">//将文件写入服务器(创建临时文件夹)</span><br><span class="line">File newFile = new File(folderPath);</span><br><span class="line">if (!newFile.exists()) &#123;</span><br><span class="line">boolean mkdirs = newFile.mkdirs();</span><br><span class="line">if (!mkdirs) &#123;</span><br><span class="line">throw new ExcelException(&quot;文件路径生成失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取扣缴单位名称 地区 身份证</span><br><span class="line">String companyName = salaryTaxExportVO.getCompanyName();</span><br><span class="line">if(StringUtils.isBlank(companyName))&#123;</span><br><span class="line">companyName = &quot;无扣缴单位&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String area = salaryTaxExportVO.getArea();</span><br><span class="line">String certNo = salaryTaxExportVO.getCertNo();</span><br><span class="line">//创建扣缴单位文件路径</span><br><span class="line">String companyPath = folderPath + SYMBOL + companyName + SYMBOL;</span><br><span class="line">if (!companyPathList.contains(companyPath)) &#123;</span><br><span class="line">File file = new File(companyPath);</span><br><span class="line">if (!file.exists()) &#123;</span><br><span class="line">file.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">companyPathList.add(companyPath);</span><br><span class="line">&#125;</span><br><span class="line">// 向扣缴单位文件夹写文件 地区+扣缴单位名称+个人身份号码</span><br><span class="line">List&lt;String&gt; names = Lists.newArrayList();</span><br><span class="line">names.add(area);</span><br><span class="line">names.add(companyName);</span><br><span class="line">names.add(certNo);</span><br><span class="line">names.add(&quot;.xls&quot;);</span><br><span class="line">String fileName = StringUtils.join(names.stream().filter(Objects::nonNull).collect(Collectors.toList()), &quot;&quot;);</span><br><span class="line">FileOutputStream out = new FileOutputStream(companyPath + fileName);</span><br><span class="line">wb.write(out);</span><br><span class="line">wb.close();</span><br><span class="line">&#125;</span><br><span class="line">// 获取zip文件名称 （余杭、建德）+扣缴单位名称</span><br><span class="line">String folderName = &quot;个人所得税专项附加扣除申报文件.zip&quot;;</span><br><span class="line">//打包下载文件</span><br><span class="line">packToDownload(request, response, folderName, folderPath);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;writeDataToModelExcel error, corpId=&#123;&#125;, userId=&#123;&#125;.&quot;, corpId, opUserId,e);</span><br><span class="line">throw e;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// 删除文件</span><br><span class="line">delFolder(folderPath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建zip包"><a href="#创建zip包" class="headerlink" title="创建zip包"></a>创建zip包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 创建ZIP文件</span><br><span class="line">*</span><br><span class="line">* @param folderPath 文件或文件夹路径</span><br><span class="line">*/</span><br><span class="line">private static void packToDownload(HttpServletRequest request, HttpServletResponse response, String folderName, String folderPath) &#123;</span><br><span class="line">try (</span><br><span class="line">ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(outputStream)) &#123;</span><br><span class="line">//设置响应头,必须在写文件前</span><br><span class="line">DownloadUtil.setFileDownloadHeader(request, response, folderName);</span><br><span class="line">writeZip(new File(folderPath), &quot;&quot;, zos);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*</span><br><span class="line">*写文件</span><br><span class="line">*/</span><br><span class="line">private static void writeZip(File file, String parentPath, ZipOutputStream zos) &#123;</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">if (file.isDirectory()) &#123;</span><br><span class="line">//处理文件夹</span><br><span class="line">String filename = file.getName();</span><br><span class="line">if (filename.contains(FILE_NAME_SPECIAL))&#123;</span><br><span class="line">filename = &quot;个人所得税专项附加扣除申报文件&quot;;</span><br><span class="line">&#125;</span><br><span class="line">parentPath += filename + File.separator;</span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line">if (files.length != 0) &#123;</span><br><span class="line">for (File f : files) &#123;</span><br><span class="line">writeZip(f, parentPath, zos);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;       //空目录则创建当前目录</span><br><span class="line">try &#123;</span><br><span class="line">zos.putNextEntry(new ZipEntry(parentPath));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">FileInputStream fis = null;</span><br><span class="line">try &#123;</span><br><span class="line">fis = new FileInputStream(file);</span><br><span class="line">ZipEntry ze = new ZipEntry(parentPath + file.getName());</span><br><span class="line">zos.putNextEntry(ze);</span><br><span class="line">byte[] content = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = fis.read(content)) != -1) &#123;</span><br><span class="line">zos.write(content, 0, len);</span><br><span class="line">zos.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (fis != null) &#123;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*</span><br><span class="line">*设置响应头</span><br><span class="line">*/</span><br><span class="line">public static void setFileDownloadHeader(HttpServletRequest request, HttpServletResponse response, String fileName) &#123;</span><br><span class="line">final String userAgent = request.getHeader(&quot;User-Agent&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">String finalFileName = getEncodeFileName(userAgent, fileName);</span><br><span class="line">response.setContentType(&quot;application/octet-stream&quot;);</span><br><span class="line">response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; &quot; + finalFileName);</span><br><span class="line">&#125; catch (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 删除文件</span><br><span class="line">*</span><br><span class="line">* @param folderPath</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">private static void delFolder(String folderPath) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//删除完里面所有内容</span><br><span class="line">delAllFile(folderPath);</span><br><span class="line">java.io.File myFilePath = new java.io.File(folderPath);</span><br><span class="line">//删除空文件夹</span><br><span class="line">myFilePath.delete();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOGGER.error(&quot;TaxDeductExcelUtil delFolder 删除文件失败&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean delAllFile(String path) &#123;</span><br><span class="line">boolean flag = false;</span><br><span class="line">File file = new File(path);</span><br><span class="line">if (!file.exists()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (!file.isDirectory()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">String[] tempList = file.list();</span><br><span class="line">if (ArrayUtils.isEmpty(tempList)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">for (String aTempList : tempList) &#123;</span><br><span class="line">File temp;</span><br><span class="line">if (path.endsWith(File.separator)) &#123;</span><br><span class="line">temp = new File(path + aTempList);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">temp = new File(path + File.separator + aTempList);</span><br><span class="line">&#125;</span><br><span class="line">if (temp.isFile()) &#123;</span><br><span class="line">temp.delete();</span><br><span class="line">&#125;</span><br><span class="line">if (temp.isDirectory()) &#123;</span><br><span class="line">//先删除文件夹里面的文件</span><br><span class="line">delAllFile(path + &quot;/&quot; + aTempList);</span><br><span class="line">//再删除空文件夹</span><br><span class="line">delFolder(path + &quot;/&quot; + aTempList);</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li>创建临时文件时，一定要保证文件名唯一（防止同一时间并发，导出串数据），这里采用了corpId-userId-UUID</li><li>后缀.xls表示07之前的版本 使用HSSFWookBook，.xlsx是07之后的版本XSSFWookBook，这里使用POI兼容的方式，自动帮你识别：Workbook wb = WorkbookFactory.create(classPathResource.getInputStream())；</li><li>在循环中每写完一个excel都要关流 wb.close() — 因为是多个excel</li><li>最后一定要删除服务器上的文件（防止文件堆积占用内存）</li><li>HSSF对excel函数方法较多不支持导致导出的文件一些版本的excel内容不可读，不过用WPS可以正常打开</li><li>设置响应头,必须在写文件前</li><li>JCE策略文件-读取excel加密文件时，jdk版本需要在”1.8.0_161以上，否则需要安装第三方jar包（US_export_policy.jar , local_policy.jar　）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>maven基本知识</title>
    <link href="http://yoursite.com/2018/12/23/maven%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/23/maven基础知识/</id>
    <published>2018-12-22T23:49:55.000Z</published>
    <updated>2020-07-15T06:39:22.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>maven是项目管理工具，主要有两个特性: 依赖管理和一键构建.</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h5 id="依赖管理就是对jar包的管理过程"><a href="#依赖管理就是对jar包的管理过程" class="headerlink" title="依赖管理就是对jar包的管理过程."></a>依赖管理就是对jar包的管理过程.</h5><p>传统的工程项目是直接放置jar包，maven工程真正的jar包在仓库中放置，项目中只放置jar包的坐标(pom.xml). </p><h5 id="仓库分三类-："><a href="#仓库分三类-：" class="headerlink" title="仓库分三类 ："></a>仓库分三类 ：</h5><p>本地仓库,远程仓库【私服】,中央仓库.<br>本地仓库是我们运行项目第一步必须本地仓库有对应的坐标，如果没有默认自动去中央仓库下载，在公司中会先从远程仓库下载，远程仓库没有，会从中央仓库下载或本地上传.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ….&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.dintalent.salary&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; </span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt; </span><br><span class="line">&lt;name&gt;mavenDemo&lt;/name&gt;  </span><br><span class="line">&lt;url&gt;http://maven.apache.org&lt;/url&gt;  </span><br><span class="line">&lt;dependencies&gt;  </span><br><span class="line">&lt;dependency&gt;   </span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;   </span><br><span class="line">&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><ul><li>groupId : 标识公司,组织,团体(taobao.com对应com.taobao,apche.org对应org.apache)</li><li>artifactId ：工程名</li><li>version :版本号 （SNAPSHOT表示测试版本）</li><li>packaging ： 打成什么包(jar,war,pom)</li><li>scope : 依赖范围（例如test 表示对测试代码classpath有效）</li></ul><h2 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h2><p>一键构建就是我们使用maven集成的tomcat插件对项目进行编译，测试，打包，安装等操作.</p><ul><li>清理生命周期：clean</li><li>默认生命周期：compile(编译),test(测试),package(打包),install(安装).</li></ul><h2 id="jar包冲突问题"><a href="#jar包冲突问题" class="headerlink" title="jar包冲突问题"></a>jar包冲突问题</h2><p>简单理解就是应用程序依赖的同一个jar包出现了多个不同的版本，选择了错误的版本导致JVM加载不到类或加载了错误版本的类.</p><ul><li>直接依赖： A项目导入了B包，A直接依赖B包</li><li>传递依赖： A项目导入了B包，B包直接依赖C包，最终A可以使用C</li></ul><h5 id="解决jar冲突的三个原则"><a href="#解决jar冲突的三个原则" class="headerlink" title="解决jar冲突的三个原则"></a>解决jar冲突的三个原则</h5><ol><li>第一声明原则：哪个jar包的坐标靠上，这个jar包就是第一声明的包，最终进入项目的就是它.</li><li>路径近者优先原则：直接依赖路径比传递依赖近，进入项目的就是路径近的.</li><li>直接排除法： 使用<exlusions></exlusions>标签直接排除某个包的依赖包.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义注解简单使用</title>
    <link href="http://yoursite.com/2018/10/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/21/自定义注解使用/</id>
    <published>2018-10-20T23:03:55.000Z</published>
    <updated>2020-07-15T06:38:53.017Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>需要对一些用户行为的接口进行日志埋点统计,如果在业务代码写的话代码比较杂乱,而且之后改动也不方便,于是便决定使用自定义注解，使用spring的切面注解@Aspect.</p><h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>Java文件叫做Annotation，用@interface表示。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>@interface上面按需要注解上一些东西，包括@Retention、@Target、@Document、@Inherited四种.</p><ul><li>@Target 表示该注解可以用于什么地方</li><li>@Retention 注解的声明周期，用于定义注解的存活阶段，可以存活在源码级别、编译级别(字节码级别)、运行时级别</li><li>@Document 将注解包含在Javadoc中</li><li>@Inherited 允许子类继承父类中的注解</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p> 基于注解的知识，自己创建一个注解</p><ul><li>实现过程<br>首先创建一个自定义注解 -&gt; 采用spring的@Aspect创建一个切面类,在这个切中获取信息并且打印日志 -&gt; 在记录的接口上写上注解</li><li>简单示例代码<br><img src="https://github.com/geyou1995/picture/blob/master/Annotations1.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations2.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations3.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations4.png?raw=true" alt=""><br><img src="https://github.com/geyou1995/picture/blob/master/Annotations5.png?raw=true" alt=""><blockquote><p>参考：项目中的操作日志的方法</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8新特性Lambda和Stream</title>
    <link href="http://yoursite.com/2018/09/18/Java8%E6%96%B0%E7%89%B9%E6%80%A7Lambda%E5%92%8CStream/"/>
    <id>http://yoursite.com/2018/09/18/Java8新特性Lambda和Stream/</id>
    <published>2018-09-18T01:10:55.000Z</published>
    <updated>2020-07-15T06:39:04.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目前项目应用的是Java 1.8版本,在项目中看到其他小伙伴使用了奇特的编码方式，许多行代码简化成了一行，原来是Java8的特性Lambda和Stream,结合代码和网上查资料学习了一下，并将相关的的知识做了下总结.</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda简单的理解就是一个匿名方法，一段带有输入参数的可执行语句块.</p><ul><li>语法：（）-&gt; {}   (小括号里是参数，大括号里是方法体)</li><li>特点：<pre><code>1.参数类型可以省略，编译器可以从上下文环境中推断出来2.当lambda表达式的参数个数只有一个的时候，小括号可以省略3.当lambda表达式只包含一条语句时，可以省略大括号，return，语句结尾的分号4.lambda表达式可以访问外部变量，但是要求这个变量不可变（final修饰）</code></pre></li><li>方法引用：<pre><code>1.类实例引用：   Person::getName2.类静态方法引用：Max::max </code></pre></li><li>构造器引用：<pre><code>Person::new（等同于 x-&gt;new Person(x)）</code></pre></li></ul><hr><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作。数据源一般是数组或集合等，进行聚合操作可以获取想要的结果。</p><ul><li>基本步骤：获取一个数据源（source）-&gt; 数据转化 -&gt; 执行操作获取想要的结果.(简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果)</li><li>创建Stream<pre><code>1.Stream静态方法：Stream.of();2.Collection子类获取Stream（最常用）：list.Stream();</code></pre></li><li>Stream流操作<br>  *Intermediate（中间）: 一个流可以跟多个中间操作，主要是打开流对数据进行某种映射或过滤.<pre><code>常见操作:    map() - 对stream里的元素进行映射转化    filter() - 对Stream包含对元素按给定的条件过滤    distinct() - 对stream包含对元素进行去重    sorted() - 对stream包含对元素排序    peek() -  生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数        limit() - 对Stream里的元素取前n个    skip(n) - 对stream里的元素丢弃前n个，获取之后的元素    parallel() - 将一个顺序执行的流转变成一个并发的流（还有一种Collection.parallelStream()）    sequential() - 一个并行流转换成一个顺序流        unordered() - 实现无序流</code></pre></li><li>Terminal(终端): 一个流只能有一个终端操作，这是流对最后一个操作，用来处理结果数据。<pre><code>常见操作:     forEach() - 遍历结果数据（并行处理）    forEachOrdered - 遍历结果数据（顺序处理）    toArray（） - 将数据输入到数组中    reduce（） - 把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合    collect（） - 实现了很多归约操作，例如将流转换成集合和聚合元素    count() - 获取stream里的元素个数    min() - 最小值    max() - 最大值    anyMatch() - Stream中是否存在任何一个元素满足匹配条件    allMatch() - 是不是Stream中的所有元素都满足给定的匹配条件    noneMatch() - 是不是Stream中的所有元素都不满足给定的匹配条件    findFirst() - 返回Stream中的第一个元素，如果Stream为空，返回空Optional    findAny() - 返回这个Stream中，取到的任何一个对象</code></pre></li><li>简单示例代码</li><li>七牛云大坑逼！！！！！<br><img src="https://github.com/geyou1995/geyou1995.github.io/blob/master/wallhave.n-664820.jpg?raw=true" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test1.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test2.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test3.1.png" alt=""><br><img src="http://pdufbfyi3.bkt.clouddn.com/test3.2.png" alt=""><blockquote><p>参考：<a href="https://yuque.antfin-inc.com/mdc/doc/rhihn7" target="_blank" rel="noopener">https://yuque.antfin-inc.com/mdc/doc/rhihn7</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/Java%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac系统Idea常用快捷键</title>
    <link href="http://yoursite.com/2018/09/09/Mac%E7%B3%BB%E7%BB%9F%E4%B8%8BIdea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/09/09/Mac系统下Idea快捷键/</id>
    <published>2018-09-09T02:24:45.000Z</published>
    <updated>2020-07-15T06:42:32.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直使用的Java编译工具是eclipse,进新公司之后,公司配了一台Mac并且后端都用IntelliJ IDEA开发,不能脱离团队呀,果断入手了IDEA,不得不说比eclipse更加的智能好用,为了提高开发效率，所以决定整理一下IDEA的常用快捷键,不想每次都配,所以就决定用IDEA默认的快捷键,用的是Mac OS X 10.5+ 但是Mac系统中与IDEA的快捷键有些冲突,可以把Mac相关冲突的快捷键更改或取消掉.下面整理了平常开发中常用的快捷键，以便于更好的记忆和熟练使用.</p><h2 id="Mac键盘符号和修饰健说明"><a href="#Mac键盘符号和修饰健说明" class="headerlink" title="Mac键盘符号和修饰健说明"></a>Mac键盘符号和修饰健说明</h2><p>⌘ Command<br>⇧ Shift<br>⌥ Option<br>⌃ Control<br>↩︎ Return/Enter<br>⌫ Delete<br>⌦ 向前删除键（Fn+Delete）<br>↑ 上箭头<br>↓ 下箭头<br>← 左箭头<br>→ 右箭头<br>⇞ Page Up（Fn+↑）<br>⇟ Page Down（Fn+↓）<br>Home Fn + ←<br>End Fn + →<br>⇥ 右制表符（Tab键）<br>⇤ 左制表符（Shift+Tab）<br>⎋ Escape (Esc)</p><h2 id="Editing编辑"><a href="#Editing编辑" class="headerlink" title="Editing编辑"></a>Editing编辑</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Control+Space 基本的代码补全(补全任何类,方法,变量) 注意这里与Mac系统的输入法快捷键冲突</span><br><span class="line">Control+Shift+Space 智能代码补全 (过滤器方法列表和变量的预期类型）</span><br><span class="line">Command+Shift+Enter 自动结束代码,行末添加分号</span><br><span class="line">Command+P  显示方法的参数</span><br><span class="line">Control+J  快速显示文档</span><br><span class="line">Command+鼠标放在代码上  显示代码简要信息</span><br><span class="line">Command+N  生成代码（getter、setter、构造函数、hashCode/equals,toString,实现接口方法）这个还有其他快捷键我只记这一种了</span><br><span class="line">Control+O  覆盖方法(重写父类方法)</span><br><span class="line">Control+I  实现接口方法(我直接记Command+N,也能实现接口方法)</span><br><span class="line">Command+Option+T 包围代码(try catch,if else,do while等)</span><br><span class="line">Command+/ 行注释代码(再按一次就是取消注释)</span><br><span class="line">Command+Option+/ 块注释</span><br><span class="line">Option+方向上  连续选中代码块</span><br><span class="line">Option+方向下  减少选中的代码块</span><br><span class="line">Control+Shift+Q 显示上下文信息</span><br><span class="line">Option+Enter  显示意向动作和快速修复代码</span><br><span class="line">Command+Option+L 格式化代码</span><br><span class="line">Control+Option+O 优化import</span><br><span class="line">Tab  缩进代码</span><br><span class="line">Command+C 复制</span><br><span class="line">Command+V 粘贴</span><br><span class="line">Command+X 剪切</span><br><span class="line">Command+D 复制当前行或选定的块</span><br><span class="line">Command+Delete 删除当前行或选定的行的块</span><br><span class="line">Control+Shift+J 智能的将代码拼接成一行</span><br><span class="line">Command+Enter 智能的拆分拼接的行</span><br><span class="line">Command+加号/减号 展开/折叠代码块</span><br><span class="line">Command+Shift+加号/减号 展开/折叠所有代码块</span><br><span class="line">Command+W 关闭活动的编辑器选项</span><br><span class="line">Command+Shift+上下  上下移动代码</span><br></pre></td></tr></table></figure><h2 id="Search-Replace（查询-替换"><a href="#Search-Replace（查询-替换" class="headerlink" title="Search/Replace（查询/替换)"></a>Search/Replace（查询/替换)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command+F 文件内查找</span><br><span class="line">Command+Shift+F 全局查找</span><br><span class="line">Command+G 查找模式下向下查找</span><br><span class="line">Command+Shift+G 查找模式下向上查找</span><br></pre></td></tr></table></figure><h2 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Option+F7 在文件中查找用到的地方</span><br><span class="line">Command+F7 在类中查找用到的地方</span><br><span class="line">Command+Shift+F7 在类中显示(颜色标记)用到的地方</span><br><span class="line">Command+Option+F7 显示用法</span><br></pre></td></tr></table></figure><h2 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Command+F9 编译Project</span><br><span class="line">Command+Shift+F9 编译选择的文件,包或模块</span><br><span class="line">Control+Option+R 弹出Run的可选菜单</span><br><span class="line">Control+Option+R 弹出Debug的可选菜单</span><br><span class="line">Control+D 调试</span><br></pre></td></tr></table></figure><h2 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F8 进入下一步,不进入当前方法内</span><br><span class="line">F7 进入下一步,如果当前断点式方法,则进入方法内</span><br><span class="line">Shift+F8 跳出</span><br><span class="line">Option+F9 运行到光标停留处</span><br><span class="line">F9 放开debug </span><br><span class="line">Command+Shift+F8 查看断点信息</span><br></pre></td></tr></table></figure><h2 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shift+Shift 查找文件</span><br><span class="line">Command+L 跳转行</span><br><span class="line">Command+E 显示最近打开的文件记录列表</span><br><span class="line">Command+Option+方向键左/右  退回/前进到上一个操作的地方</span><br><span class="line">Command+B 或Command+鼠标左键  进入方法或变量的接口或是定义处</span><br><span class="line">Command+Option+B 越过接口,直接跳掉实现处</span><br></pre></td></tr></table></figure><h2 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F5 复制文件到指定目录</span><br><span class="line">Command+delete 在文件上安全删除文件,弹出确认框</span><br><span class="line">Shift+F6 重命名文件</span><br><span class="line">Command+Option+M 将选中的代码提取为方法</span><br></pre></td></tr></table></figure><h2 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+, 打开idea系统设置</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
