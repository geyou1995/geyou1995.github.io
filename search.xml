<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sql优化]]></title>
    <url>%2F2019%2F06%2F07%2Fsql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[开发过程中,经常会碰到一些慢sql，就是性能低，执行时间太长、等待时间太长、sql语句欠佳、索引失效、服务器参数设置不合理需要我们对sql进行适当的优化，所以需要了解如何去优化哈.下面整理了一些mysql的sql结构以及该如何去优化sql。 mysql的逻辑分层原理 连接层提供与客户端连接的服务 服务层提供各种用户使用的接口（增删改查）提供sql优化器 引擎层提供各种存储数据的方式，例如默认的InnoDB（事务优先，行锁）、MyISAM(效率优先，表锁)等 存储层存储最终的数据 sql 编写过程select…from…join…on…where…group by…having…order by…limit..sql 解析过程from…on..join…where…group by…having..select…order by…limit.. 核心是优化索引索引 定义 帮助mysql高效获取数据的数据结构，索引是数据结构. 索引分类 主键索引：与唯一基本相同（主键不能为null，唯一可以为null） 单值索引：单列（一个表可以有多个单值索引） 唯一索引：不能重复（例如id） 复合索引：多个列构成的索引s 索引优势 提高查询效率（降低IO的使用率) 降低CPU使用率（索引是排好序的结构，可以直接用） 索引弊端： 索引本身很大，可以存放在内存/硬盘 不是所有情况使用：a.少量数据 b.频繁更新的字段 c.很少使用的字段 索引会提高查的效率，会降低增删改的效率 Sql性能问题 分析sql的执行计划：explain 查询执行计划：explain + sql 1id: 编号,id值相同，从上往下顺序执行(表的执行顺序会因为数量改变而改变，原因：笛卡尔积，数据 小的表优先查询)，id值不同：越大越优先查询（在查询时先查内层再查外层） 1234567select_type: 查询类型 PRIMARY:主查询 SUBQUERY:子查询 SIMPLE:简单查询（不包含主、子查询） DERIVER：衍生查询（使用到临时表-a.在from子查询中只有一张表 b.在from子查询中table1 union table2） UNION：在from子查询中table1 union table2（指的table2） 1table: 表(代表你查的表) 123456789type: 索引类型 system-&gt;const-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all（越往左效率越高） system:只有一条数据的系统表 或 衍生表(子查询)只有一条数据的主查询 const:结果只有一条数据 （用于主键索引和唯一索引） eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引 扫描 ref:非唯一性索引，返回匹配的多条数据或0条 range:检索指定范围的行，使用一个索引来选择行（between,&lt;,&gt;,=） index:读取所有的索引 all:全表读取 1possible_keys: 预测可能使用的索引 1key: 实际使用的索引 12345key_len:实际使用的索引的长度（作用：判断复合索引是否完全被使用） key len的长度还和字符集有关,latin1一个字符占用1个字节,gbk一个字符占用2个字节,utf8一个字符占用3个字节(如果索引字段可 以为空，会给1个字节标示)。 utf-8情况下：name char(20) 不为null--20*3=60，若可为null--20*3+1=61 name varchar(20)不为null--20*3+2=62，若可为null--20*3+2+1=63 id int(3) 不为null--4，若可为null--4+1=5 1ref: 作用-指明当前表参照的字段 1const:常量 1rows:被索引优化查询的数据个数 12345678910111213141516171819Extra: 性能从好到坏:using index &gt; using where &gt; using temporary | using filesort * using filesort（性能损耗大）常见于order by: 1.需要额外的一次排序或查找（单索引）--排序和查找不是同一个字段会出现 2.最佳左前缀（复合索引）--不按照复合索引的顺序使用 * using temporary（性能损耗大，额外多使用临时表）常见于group by: 根据字段查确不用该字段分组 * using index: 索引覆盖，不读取原文件，只从索引文件中获取（不需要回表查询） 如果用到了索引覆盖： 1.如果有where,索引出现在key和possible_keys中 2.如果没有where,索引只出现在key中 select age from student where age = 13 ---age 是索引 * using where: 需要回表查询(需要查询原文件) select age，name from student where name = &apos;&apos; ---age 是索引 * Impossible where：这个值强调了where语句会导致没有符合条件的行 总结:如果（a,b,c,d）复合索引和使用的顺序一致，则复合索引全部使用。如果部分一致（且不夸列），则部分使用 sql优化器可能干扰我们的优化sql的优化主要通过上述的属性去优化，但是sql优化器可能会干扰我们的优化. 常用sql优化方法1. 加索引 a.索引不能跨列，保持索引的定义和使用一致（根据sql实际解析的顺序，调整索引的顺序，从from开始节气解析）； b.索引要逐步优化 c.范围查询in可能使索引失效，放到where条件最后面 2. 多表 a.小表驱动大表 b.索引建立在经常查询的字段 3. 避免索引失效的一些原则 a.复合索引，不要跨列或无序使用（最佳左前缀） b.复合索引，尽量使用全索引匹配 c.不要在索引上进行任何操作（计算，函数，类型转换），否则索引失效 d.复合索引不能使用不等于（!=，&lt;&gt;）或is null，否则索引失效 e.尽量使用索引覆盖（using index） f.like尽量已“常量”开头，不用以“%”开头，否则索引失效（如果必须使用，可以用索引覆盖补救一部分） g.尽量不要使用类型转换（显式，隐式），否则索引失效 h.尽量不要使用or，否则索引失效 注：双层循环：（外层小内层大）性能比（外层大内层小）好 mysql锁机制解决因资源共享而造成的并发问题 操作类型分： 1.读锁（共享锁）:对同一个数据，多个读操作可以同时进行（买衣服的看） 2.写锁（互斥锁）:如果当前操作没有完毕，则无法进行读写操作（买衣服一系列操作） 操作范围分： 1.表锁：一次性对一张表整体加锁（myISAM存储引擎），开销小，加锁快，锁的范围大，无死锁，容易发生锁冲突 2.行锁：一次性对一行数据加锁（innoDB存储引擎），开销大，加锁慢，容易出现死锁，不易发生锁冲突 3.页锁]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springBoot入门]]></title>
    <url>%2F2019%2F05%2F27%2FspringBoot%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。 特点 为基于spring开发提供更快的入门体检. 开箱即用. springBoot不是对spring的增强，而是提供了更快的使用方式 嵌入式服务器，健康检测，安全、外部配置等非功能性特性. 核心功能 起步依赖将具备某一功能的坐标打包到一起，提供默认的功能 自动配置自动帮你配置某个对象需要的配置,例如tomcat的端口号默认8080等 必须引用的坐标123456789父级依赖&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.0.3.RELEASE&lt;/version&gt;&lt;relativePath/&gt;&lt;/parent&gt;&lt;/resource&gt; 123456支持web的模块&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件springBoot是基于约定的所有很多配置都有默认值，若想使用自己的配置，可以使用配置文件（properties,yml). 1. propertieskey = value 2. yml（yaml）1234567891011121314151617181920212223242526272829303132331.普通数据的配置（冒号后需要空格）name: zhangsan 2. 对象的配置(同一级别的缩进保持一致)person:name: zhangsanage: 18address: hangzhouserver:port: 80883. 行内对象配置(不常用)person： &#123;name: zhangsan,age: 18, address: hangzhou&#125;4.配置数据集合city:- beijing- hangzhou- taizhou- zhoushancity：[beijing,hangzhou,taizhou]5. 配置对象集合数据student:-name: zhangsanage: 18address: hangzhou-name: lisiage: 16address: taizhou6. map配置map:key1: value1key2: value2 加载配置文件的顺序springBoot一些数据会有默认值，如果你想更改则可以使用配置来覆盖，配置文件后加载的也会覆盖之前加载的.它会先加载yml，最后加载properties. 123456789（spring-boot-starter-parent）&lt;resource&gt;&lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt;&lt;excludes&gt;&lt;exclude&gt;**/application*.yml&lt;/exclude&gt;&lt;exclude&gt;**/application*.yaml&lt;/exclude&gt;&lt;exclude&gt;**/application*.properties&lt;/exclude&gt;&lt;/excludes&gt;&lt;/resource&gt; 在业务代码中获取配置信息有如下两种方式： @value(“${name}”) 12@Value(&quot;$&#123;oss.endPoint&#125;&quot;)private String endPoint; 12345oss:endPoint: oss-cn-hangzhou-internal.aliyuncs.comaccessKeyId: ALIYUN_ACCESS_KEYaccessKeySecret: ALIYUN_SECRET_KEYdefaultBucket: salary-prod @ConfigurationProperties(prefix =”person”) 需要set,get方法 12345678910111213141516@Configuration@ConfigurationProperties(prefix = &quot;redis&quot;)public class RedisConfig &#123;private String clusterNodes;private String redisHost;private int redisPort;private String redisPasswd;set()..get()..&#125; 1234567redis:clusterNodes:redisHost: r-bp1d75e29eop202ee4.redis.rds.aliyuncs.comredisPort: 6377redisPasswd: REDIS_PASSWORDtimeout: 3000database: 0]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[excel读写及Zip打包下载]]></title>
    <url>%2F2019%2F01%2F02%2Fexcel%E8%AF%BB%E5%86%99%E5%8F%8AZIp%E6%89%93%E5%8C%85%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[针对2019个税专项附加扣除做的需求：帮助Hr快速收集员工申报信息，及处理信息，由员工填写表单提交信息，对信息进行处理写入到个税局提供的个税专项附加扣除信息excel模版，最后ZIP打包导出. 大致思路首先需要收集处理员工数据，将excel模版放在服务器上，导出时在服务器上创建一个临时文件夹，读取模版excel文件,将数据循环写入excel模版中(一个员工对应一张excel),将写好数据的excel文件流依次写入该文件夹中，接着打包下载该文件夹，最后删除这个临时文件夹. 将excel模版放在服务器上将个税局提供的模版放到服务器上，用于读取 收集处理导出的数据数据是map形式，userId-data,一个员工对应自己的数据 在服务器上创建一个临时文件夹打包时需要一个文件夹存放一个个excel文件 将数据写入循环数据，获取excel模版，创建WorkBook写入数据 处理excel将写好的excel文件命名并写到临时文件夹去 zip打包下载写完所有数据后，对该临时文件夹打包导出 删除文件导出后删除临时文件夹 相关代码主要流程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static void writeDataToModelExcel(HttpServletRequest request, HttpServletResponse response, Map&lt;String, SalaryTaxExportVO&gt; dataMap, String corpId, String opUserId) throws Exception &#123;final String folderPath = PATH + FILE_NAME_SPECIAL + LINE + corpId + LINE + opUserId + LINE + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);try &#123;//创建唯一临时文件夹路径//创建扣件单位文件路径集合List&lt;String&gt; companyPathList = Lists.newArrayList();//遍历数据写入excelfor (Map.Entry&lt;String, SalaryTaxExportVO&gt; entry : dataMap.entrySet()) &#123;//获取模版文件excelClassPathResource classPathResource = new ClassPathResource(&quot;xls/latestSalaryTaxDeductTemplate.xls&quot;);//LOGGER.warn(&quot;qqqqq&quot; + Cipher.getMaxAllowedKeyLength(&quot;AES&quot;));Workbook wb = WorkbookFactory.create(classPathResource.getInputStream());//3.获取数据SalaryTaxExportVO salaryTaxExportVO = entry.getValue();String userId = salaryTaxExportVO.getUserId();//将数据写到excel模版中writeDataToTemplate(salaryTaxExportVO, wb);//将文件写入服务器(创建临时文件夹)File newFile = new File(folderPath);if (!newFile.exists()) &#123;boolean mkdirs = newFile.mkdirs();if (!mkdirs) &#123;throw new ExcelException(&quot;文件路径生成失败&quot;);&#125;&#125;//获取扣缴单位名称 地区 身份证String companyName = salaryTaxExportVO.getCompanyName();if(StringUtils.isBlank(companyName))&#123;companyName = &quot;无扣缴单位&quot;;&#125;String area = salaryTaxExportVO.getArea();String certNo = salaryTaxExportVO.getCertNo();//创建扣缴单位文件路径String companyPath = folderPath + SYMBOL + companyName + SYMBOL;if (!companyPathList.contains(companyPath)) &#123;File file = new File(companyPath);if (!file.exists()) &#123;file.mkdirs();&#125;companyPathList.add(companyPath);&#125;// 向扣缴单位文件夹写文件 地区+扣缴单位名称+个人身份号码List&lt;String&gt; names = Lists.newArrayList();names.add(area);names.add(companyName);names.add(certNo);names.add(&quot;.xls&quot;);String fileName = StringUtils.join(names.stream().filter(Objects::nonNull).collect(Collectors.toList()), &quot;&quot;);FileOutputStream out = new FileOutputStream(companyPath + fileName);wb.write(out);wb.close();&#125;// 获取zip文件名称 （余杭、建德）+扣缴单位名称String folderName = &quot;个人所得税专项附加扣除申报文件.zip&quot;;//打包下载文件packToDownload(request, response, folderName, folderPath);&#125; catch (Exception e) &#123;LOGGER.error(&quot;writeDataToModelExcel error, corpId=&#123;&#125;, userId=&#123;&#125;.&quot;, corpId, opUserId,e);throw e;&#125; finally &#123;// 删除文件delFolder(folderPath);&#125;&#125; 创建zip包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/*** 创建ZIP文件** @param folderPath 文件或文件夹路径*/private static void packToDownload(HttpServletRequest request, HttpServletResponse response, String folderName, String folderPath) &#123;try (ServletOutputStream outputStream = response.getOutputStream();ZipOutputStream zos = new ZipOutputStream(outputStream)) &#123;//设置响应头,必须在写文件前DownloadUtil.setFileDownloadHeader(request, response, folderName);writeZip(new File(folderPath), &quot;&quot;, zos);&#125; catch (Exception e) &#123;LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);&#125;&#125;/****写文件*/private static void writeZip(File file, String parentPath, ZipOutputStream zos) &#123;if (file.exists()) &#123;if (file.isDirectory()) &#123;//处理文件夹String filename = file.getName();if (filename.contains(FILE_NAME_SPECIAL))&#123;filename = &quot;个人所得税专项附加扣除申报文件&quot;;&#125;parentPath += filename + File.separator;File[] files = file.listFiles();if (files.length != 0) &#123;for (File f : files) &#123;writeZip(f, parentPath, zos);&#125;&#125; else &#123; //空目录则创建当前目录try &#123;zos.putNextEntry(new ZipEntry(parentPath));&#125; catch (IOException e) &#123;LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);&#125;&#125;&#125; else &#123;FileInputStream fis = null;try &#123;fis = new FileInputStream(file);ZipEntry ze = new ZipEntry(parentPath + file.getName());zos.putNextEntry(ze);byte[] content = new byte[1024];int len;while ((len = fis.read(content)) != -1) &#123;zos.write(content, 0, len);zos.flush();&#125;&#125; catch (Exception e) &#123;LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);&#125; finally &#123;try &#123;if (fis != null) &#123;fis.close();&#125;&#125; catch (Exception e) &#123;LOGGER.error(&quot;TaxDeductExcelUtil packToDownload 创建ZIP文件失败&quot;, e);&#125;&#125;&#125;&#125;&#125;/****设置响应头*/public static void setFileDownloadHeader(HttpServletRequest request, HttpServletResponse response, String fileName) &#123;final String userAgent = request.getHeader(&quot;User-Agent&quot;);try &#123;String finalFileName = getEncodeFileName(userAgent, fileName);response.setContentType(&quot;application/octet-stream&quot;);response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; &quot; + finalFileName);&#125; catch (Exception ignored) &#123;&#125;&#125; 删除文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*** 删除文件** @param folderPath* @return*/private static void delFolder(String folderPath) &#123;try &#123;//删除完里面所有内容delAllFile(folderPath);java.io.File myFilePath = new java.io.File(folderPath);//删除空文件夹myFilePath.delete();&#125; catch (Exception e) &#123;LOGGER.error(&quot;TaxDeductExcelUtil delFolder 删除文件失败&quot;, e);&#125;&#125;private static boolean delAllFile(String path) &#123;boolean flag = false;File file = new File(path);if (!file.exists()) &#123;return false;&#125;if (!file.isDirectory()) &#123;return false;&#125;String[] tempList = file.list();if (ArrayUtils.isEmpty(tempList)) &#123;return true;&#125;for (String aTempList : tempList) &#123;File temp;if (path.endsWith(File.separator)) &#123;temp = new File(path + aTempList);&#125; else &#123;temp = new File(path + File.separator + aTempList);&#125;if (temp.isFile()) &#123;temp.delete();&#125;if (temp.isDirectory()) &#123;//先删除文件夹里面的文件delAllFile(path + &quot;/&quot; + aTempList);//再删除空文件夹delFolder(path + &quot;/&quot; + aTempList);flag = true;&#125;&#125;return flag;&#125; 注意点 创建临时文件时，一定要保证文件名唯一（防止同一时间并发，导出串数据），这里采用了corpId-userId-UUID 后缀.xls表示07之前的版本 使用HSSFWookBook，.xlsx是07之后的版本XSSFWookBook，这里使用POI兼容的方式，自动帮你识别：Workbook wb = WorkbookFactory.create(classPathResource.getInputStream())； 在循环中每写完一个excel都要关流 wb.close() — 因为是多个excel 最后一定要删除服务器上的文件（防止文件堆积占用内存） HSSF对excel函数方法较多不支持导致导出的文件一些版本的excel内容不可读，不过用WPS可以正常打开 设置响应头,必须在写文件前 JCE策略文件-读取excel加密文件时，jdk版本需要在”1.8.0_161以上，否则需要安装第三方jar包（US_export_policy.jar , local_policy.jar ）]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[maven基本知识]]></title>
    <url>%2F2018%2F12%2F23%2Fmaven%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[maven是项目管理工具，主要有两个特性: 依赖管理和一键构建. 依赖管理依赖管理就是对jar包的管理过程.传统的工程项目是直接放置jar包，maven工程真正的jar包在仓库中放置，项目中只放置jar包的坐标(pom.xml). 仓库分三类 ：本地仓库,远程仓库【私服】,中央仓库.本地仓库是我们运行项目第一步必须本地仓库有对应的坐标，如果没有默认自动去中央仓库下载，在公司中会先从远程仓库下载，远程仓库没有，会从中央仓库下载或本地上传. 1234567891011121314151617&lt;project ….&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.dintalent.salary&lt;/groupId&gt; &lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mavenDemo&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;/project&gt; groupId : 标识公司,组织,团体(taobao.com对应com.taobao,apche.org对应org.apache) artifactId ：工程名 version :版本号 （SNAPSHOT表示测试版本） packaging ： 打成什么包(jar,war,pom) scope : 依赖范围（例如test 表示对测试代码classpath有效） 一键构建一键构建就是我们使用maven集成的tomcat插件对项目进行编译，测试，打包，安装等操作. 清理生命周期：clean 默认生命周期：compile(编译),test(测试),package(打包),install(安装). jar包冲突问题简单理解就是应用程序依赖的同一个jar包出现了多个不同的版本，选择了错误的版本导致JVM加载不到类或加载了错误版本的类. 直接依赖： A项目导入了B包，A直接依赖B包 传递依赖： A项目导入了B包，B包直接依赖C包，最终A可以使用C 解决jar冲突的三个原则 第一声明原则：哪个jar包的坐标靠上，这个jar包就是第一声明的包，最终进入项目的就是它. 路径近者优先原则：直接依赖路径比传递依赖近，进入项目的就是路径近的. 直接排除法： 使用标签直接排除某个包的依赖包.]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义注解简单使用]]></title>
    <url>%2F2018%2F10%2F21%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[需要对一些用户行为的接口进行日志埋点统计,如果在业务代码写的话代码比较杂乱,而且之后改动也不方便,于是便决定使用自定义注解，使用spring的切面注解@Aspect. 注解的定义Java文件叫做Annotation，用@interface表示。 元注解@interface上面按需要注解上一些东西，包括@Retention、@Target、@Document、@Inherited四种. @Target 表示该注解可以用于什么地方 @Retention 注解的声明周期，用于定义注解的存活阶段，可以存活在源码级别、编译级别(字节码级别)、运行时级别 @Document 将注解包含在Javadoc中 @Inherited 允许子类继承父类中的注解 自定义注解 基于注解的知识，自己创建一个注解 实现过程首先创建一个自定义注解 -&gt; 采用spring的@Aspect创建一个切面类,在这个切中获取信息并且打印日志 -&gt; 在记录的接口上写上注解 简单示例代码 参考：项目中的操作日志的方法]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性Lambda和Stream]]></title>
    <url>%2F2018%2F09%2F18%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7Lambda%E5%92%8CStream%2F</url>
    <content type="text"><![CDATA[目前项目应用的是Java 1.8版本,在项目中看到其他小伙伴使用了奇特的编码方式，许多行代码简化成了一行，原来是Java8的特性Lambda和Stream,结合代码和网上查资料学习了一下，并将相关的的知识做了下总结. lambda表达式lambda简单的理解就是一个匿名方法，一段带有输入参数的可执行语句块. 语法：（）-&gt; {} (小括号里是参数，大括号里是方法体) 特点：1.参数类型可以省略，编译器可以从上下文环境中推断出来 2.当lambda表达式的参数个数只有一个的时候，小括号可以省略 3.当lambda表达式只包含一条语句时，可以省略大括号，return，语句结尾的分号 4.lambda表达式可以访问外部变量，但是要求这个变量不可变（final修饰） 方法引用：1.类实例引用： Person::getName 2.类静态方法引用：Max::max 构造器引用：Person::new（等同于 x-&gt;new Person(x)） StreamStream（流）是一个来自数据源的元素队列并支持聚合操作。数据源一般是数组或集合等，进行聚合操作可以获取想要的结果。 基本步骤：获取一个数据源（source）-&gt; 数据转化 -&gt; 执行操作获取想要的结果.(简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果) 创建Stream1.Stream静态方法：Stream.of(); 2.Collection子类获取Stream（最常用）：list.Stream(); Stream流操作 *Intermediate（中间）: 一个流可以跟多个中间操作，主要是打开流对数据进行某种映射或过滤.常见操作: map() - 对stream里的元素进行映射转化 filter() - 对Stream包含对元素按给定的条件过滤 distinct() - 对stream包含对元素进行去重 sorted() - 对stream包含对元素排序 peek() - 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数 limit() - 对Stream里的元素取前n个 skip(n) - 对stream里的元素丢弃前n个，获取之后的元素 parallel() - 将一个顺序执行的流转变成一个并发的流（还有一种Collection.parallelStream()） sequential() - 一个并行流转换成一个顺序流 unordered() - 实现无序流 Terminal(终端): 一个流只能有一个终端操作，这是流对最后一个操作，用来处理结果数据。常见操作: forEach() - 遍历结果数据（并行处理） forEachOrdered - 遍历结果数据（顺序处理） toArray（） - 将数据输入到数组中 reduce（） - 把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合 collect（） - 实现了很多归约操作，例如将流转换成集合和聚合元素 count() - 获取stream里的元素个数 min() - 最小值 max() - 最大值 anyMatch() - Stream中是否存在任何一个元素满足匹配条件 allMatch() - 是不是Stream中的所有元素都满足给定的匹配条件 noneMatch() - 是不是Stream中的所有元素都不满足给定的匹配条件 findFirst() - 返回Stream中的第一个元素，如果Stream为空，返回空Optional findAny() - 返回这个Stream中，取到的任何一个对象 简单示例代码 七牛云大坑逼！！！！！ 参考：https://yuque.antfin-inc.com/mdc/doc/rhihn7]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac系统Idea常用快捷键]]></title>
    <url>%2F2018%2F09%2F09%2FMac%E7%B3%BB%E7%BB%9F%E4%B8%8BIdea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[之前一直使用的Java编译工具是eclipse,进新公司之后,公司配了一台Mac并且后端都用IntelliJ IDEA开发,不能脱离团队呀,果断入手了IDEA,不得不说比eclipse更加的智能好用,为了提高开发效率，所以决定整理一下IDEA的常用快捷键,不想每次都配,所以就决定用IDEA默认的快捷键,用的是Mac OS X 10.5+ 但是Mac系统中与IDEA的快捷键有些冲突,可以把Mac相关冲突的快捷键更改或取消掉.下面整理了平常开发中常用的快捷键，以便于更好的记忆和熟练使用. Mac键盘符号和修饰健说明⌘ Command⇧ Shift⌥ Option⌃ Control↩︎ Return/Enter⌫ Delete⌦ 向前删除键（Fn+Delete）↑ 上箭头↓ 下箭头← 左箭头→ 右箭头⇞ Page Up（Fn+↑）⇟ Page Down（Fn+↓）Home Fn + ←End Fn + →⇥ 右制表符（Tab键）⇤ 左制表符（Shift+Tab）⎋ Escape (Esc) Editing编辑123456789101112131415161718192021222324252627282930Control+Space 基本的代码补全(补全任何类,方法,变量) 注意这里与Mac系统的输入法快捷键冲突Control+Shift+Space 智能代码补全 (过滤器方法列表和变量的预期类型）Command+Shift+Enter 自动结束代码,行末添加分号Command+P 显示方法的参数Control+J 快速显示文档Command+鼠标放在代码上 显示代码简要信息Command+N 生成代码（getter、setter、构造函数、hashCode/equals,toString,实现接口方法）这个还有其他快捷键我只记这一种了Control+O 覆盖方法(重写父类方法)Control+I 实现接口方法(我直接记Command+N,也能实现接口方法)Command+Option+T 包围代码(try catch,if else,do while等)Command+/ 行注释代码(再按一次就是取消注释)Command+Option+/ 块注释Option+方向上 连续选中代码块Option+方向下 减少选中的代码块Control+Shift+Q 显示上下文信息Option+Enter 显示意向动作和快速修复代码Command+Option+L 格式化代码Control+Option+O 优化importTab 缩进代码Command+C 复制Command+V 粘贴Command+X 剪切Command+D 复制当前行或选定的块Command+Delete 删除当前行或选定的行的块Control+Shift+J 智能的将代码拼接成一行Command+Enter 智能的拆分拼接的行Command+加号/减号 展开/折叠代码块Command+Shift+加号/减号 展开/折叠所有代码块Command+W 关闭活动的编辑器选项Command+Shift+上下 上下移动代码 Search/Replace（查询/替换)1234Command+F 文件内查找Command+Shift+F 全局查找Command+G 查找模式下向下查找Command+Shift+G 查找模式下向上查找 Usage Search（使用查询）1234Option+F7 在文件中查找用到的地方Command+F7 在类中查找用到的地方Command+Shift+F7 在类中显示(颜色标记)用到的地方Command+Option+F7 显示用法 Compile and Run（编译和运行）12345Command+F9 编译ProjectCommand+Shift+F9 编译选择的文件,包或模块Control+Option+R 弹出Run的可选菜单Control+Option+R 弹出Debug的可选菜单Control+D 调试 Debug调试123456F8 进入下一步,不进入当前方法内F7 进入下一步,如果当前断点式方法,则进入方法内Shift+F8 跳出Option+F9 运行到光标停留处F9 放开debug Command+Shift+F8 查看断点信息 Navigation（导航）123456Shift+Shift 查找文件Command+L 跳转行Command+E 显示最近打开的文件记录列表Command+Option+方向键左/右 退回/前进到上一个操作的地方Command+B 或Command+鼠标左键 进入方法或变量的接口或是定义处Command+Option+B 越过接口,直接跳掉实现处 Refactoring（重构）1234F5 复制文件到指定目录Command+delete 在文件上安全删除文件,弹出确认框Shift+F6 重命名文件Command+Option+M 将选中的代码提取为方法 General（通用）1Command+, 打开idea系统设置]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
</search>
